# Lab 5: üß™ Integration Test

Time to wire everything together and create a comprehensive integration test! You'll build a complete end-to-end flow and learn Go testing patterns.

## üéØ Objectives
- Create comprehensive integration tests
- Learn Go testing idioms and patterns
- Build a complete end-to-end data flow
- Implement proper test cleanup and setup

## üõ†Ô∏è Tasks

### Step 1: Create Test Infrastructure
Create `internal/customer/service_test.go`:

```go
package customer

import (
	"context"
	"testing"
	"time"

	customerv1 "github.com/chinook/data-pipeline/pkg/proto/customer/v1"
	"google.golang.org/protobuf/types/known/timestamppb"
)

// TestCustomerService_Integration tests the complete customer service flow
func TestCustomerService_Integration(t *testing.T) {
	// Setup: Create service with mock dependencies
	repo := NewMockRepository()
	publisher := NewMockPublisher()
	svc := NewService(repo, publisher)
	ctx := context.Background()

	// Test 1: Get existing customer
	t.Run("GetExistingCustomer", func(t *testing.T) {
		req := &customerv1.GetCustomerRequest{Id: 1}
		resp, err := svc.GetCustomer(ctx, req)
		
		if err != nil {
			t.Fatalf("Expected no error, got %v", err)
		}
		
		if resp.Customer.Id != 1 {
			t.Errorf("Expected customer ID 1, got %d", resp.Customer.Id)
		}
		
		if resp.Customer.Name == "" {
			t.Error("Expected customer name to be non-empty")
		}
		
		if resp.Customer.Email == "" {
			t.Error("Expected customer email to be non-empty")
		}
	})

	// Test 2: Get non-existent customer
	t.Run("GetNonExistentCustomer", func(t *testing.T) {
		req := &customerv1.GetCustomerRequest{Id: 999}
		_, err := svc.GetCustomer(ctx, req)
		
		if err != nil {
			t.Error("Expected error for non-existent customer, got nil")
		}
	})

	// Test 3: Create, Update, and Retrieve customer
	t.Run("CreateUpdateRetrieveCustomer", func(t *testing.T) {
		// Create a new customer
		newCustomer := &customerv1.Customer{
			Name:   "Test Customer",
			Email:  "test@chinook.com",
			Status: customerv1.CustomerStatus_CUSTOMER_STATUS_ACTIVE,
			Contact: &customerv1.ContactInfo{
				Phone: "+1-555-TEST-001",
			},
			Addresses: []*customerv1.Address{
				{
					Street:  "123 Test St",
					City:    "Test City",
					State:   "TS",
					ZipCode: "12345",
					Country: "USA",
					Type:    customerv1.AddressType_ADDRESS_TYPE_HOME,
				},
			},
			Metadata: map[string]string{
				"test_flag": "true",
			},
		}

		// Create customer
		createReq := &customerv1.CreateCustomerRequest{Customer: newCustomer}
		createResp, err := svc.CreateCustomer(ctx, createReq)
		if err != nil {
			t.Fatalf("Failed to create customer: %v", err)
		}

		// Validate creation response
		if createResp.Customer.Id <= 0 {
			t.Error("Expected positive customer ID after creation")
		}
		
		if createResp.Customer.CreatedAt == nil {
			t.Error("Expected created_at timestamp to be set")
		}
		
		if createResp.Customer.UpdatedAt == nil {
			t.Error("Expected updated_at timestamp to be set")
		}

		// Update the customer
		createResp.Customer.Email = "updated@chinook.com"
		createResp.Customer.Contact.Mobile = "+1-555-MOBILE-01"
		
		updateReq := &customerv1.UpdateCustomerRequest{Customer: createResp.Customer}
		updateResp, err := svc.UpdateCustomer(ctx, updateReq)
		if err != nil {
			t.Fatalf("Failed to update customer: %v", err)
		}

		// Validate update response
		if updateResp.Customer.Email != "updated@chinook.com" {
			t.Errorf("Expected email to be updated to 'updated@chinook.com', got %s", 
				updateResp.Customer.Email)
		}
		
		if updateResp.Customer.Contact.Mobile != "+1-555-MOBILE-01" {
			t.Errorf("Expected mobile to be updated, got %s", 
				updateResp.Customer.Contact.Mobile)
		}

		// Retrieve the updated customer
		getReq := &customerv1.GetCustomerRequest{Id: createResp.Customer.Id}
		getResp, err := svc.GetCustomer(ctx, getReq)
		if err != nil {
			t.Fatalf("Failed to retrieve updated customer: %v", err)
		}

		// Validate retrieval
		if getResp.Customer.Email != "updated@chinook.com" {
			t.Errorf("Retrieved customer email mismatch: expected 'updated@chinook.com', got %s", 
				getResp.Customer.Email)
		}
	})

	// Test 4: List customers with filtering
	t.Run("ListCustomersWithFiltering", func(t *testing.T) {
		req := &customerv1.ListCustomersRequest{
			PageSize: 5,
			Filter:   "status=active",
		}
		
		resp, err := svc.ListCustomers(ctx, req)
		if err != nil {
			t.Fatalf("Failed to list customers: %v", err)
		}
		
		if len(resp.Customers) == 0 {
			t.Error("Expected at least one customer in the list")
		}
		
		// Validate all returned customers are active
		for _, customer := range resp.Customers {
			if customer.Status != customerv1.CustomerStatus_CUSTOMER_STATUS_ACTIVE {
				t.Errorf("Expected all customers to be active, found %s", 
					customer.Status.String())
			}
		}
		
		if resp.TotalCount < 0 {
			t.Error("Expected non-negative total count")
		}
	})

	// Test 5: Input validation
	t.Run("InputValidation", func(t *testing.T) {
		// Test invalid customer ID
		invalidGetReq := &customerv1.GetCustomerRequest{Id: -1}
		_, err := svc.GetCustomer(ctx, invalidGetReq)
		if err == nil {
			t.Error("Expected validation error for negative customer ID")
		}

		// Test invalid customer creation (empty name)
		invalidCustomer := &customerv1.Customer{
			Name:  "", // Invalid: empty name
			Email: "invalid@test.com",
		}
		invalidCreateReq := &customerv1.CreateCustomerRequest{Customer: invalidCustomer}
		_, err = svc.CreateCustomer(ctx, invalidCreateReq)
		if err == nil {
			t.Error("Expected validation error for empty customer name")
		}
	})
}

// TestEventPublishing_Integration tests that events are published correctly
func TestEventPublishing_Integration(t *testing.T) {
	repo := NewMockRepository()
	publisher := NewMockPublisher()
	svc := NewService(repo, publisher)
	ctx := context.Background()

	// Get the mock publisher to check events
	mockPub, ok := publisher.(*mockPublisher)
	if !ok {
		t.Fatal("Expected mock publisher")
	}

	// Create a customer and check event publishing
	newCustomer := &customerv1.Customer{
		Name:   "Event Test Customer",
		Email:  "event@test.com",
		Status: customerv1.CustomerStatus_CUSTOMER_STATUS_ACTIVE,
		Contact: &customerv1.ContactInfo{
			Phone: "+1-555-EVENT-01",
		},
		Addresses: []*customerv1.Address{
			{
				Street:  "456 Event St",
				City:    "Event City",
				State:   "EV",
				ZipCode: "54321",
				Country: "USA",
				Type:    customerv1.AddressType_ADDRESS_TYPE_WORK,
			},
		},
	}

	createReq := &customerv1.CreateCustomerRequest{Customer: newCustomer}
	createResp, err := svc.CreateCustomer(ctx, createReq)
	if err != nil {
		t.Fatalf("Failed to create customer: %v", err)
	}

	// Check that creation event was published
	events := mockPub.GetPublishedEvents()
	found := false
	for _, event := range events {
		if event == fmt.Sprintf("CustomerCreated: ID=%d, Name=%s", 
			createResp.Customer.Id, createResp.Customer.Name) {
			found = true
			break
		}
	}
	if !found {
		t.Error("Expected customer created event to be published")
	}

	// Update the customer and check event publishing
	createResp.Customer.Name = "Updated Event Customer"
	updateReq := &customerv1.UpdateCustomerRequest{Customer: createResp.Customer}
	updateResp, err := svc.UpdateCustomer(ctx, updateReq)
	if err != nil {
		t.Fatalf("Failed to update customer: %v", err)
	}

	// Check that update event was published
	events = mockPub.GetPublishedEvents()
	found = false
	for _, event := range events {
		if event == fmt.Sprintf("CustomerUpdated: ID=%d, Name=%s", 
			updateResp.Customer.Id, updateResp.Customer.Name) {
			found = true
			break
		}
	}
	if !found {
		t.Error("Expected customer updated event to be published")
	}
}

// Benchmark test to check performance
func BenchmarkCustomerService_GetCustomer(b *testing.B) {
	repo := NewMockRepository()
	publisher := NewMockPublisher()
	svc := NewService(repo, publisher)
	ctx := context.Background()
	
	req := &customerv1.GetCustomerRequest{Id: 1}
	
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		_, err := svc.GetCustomer(ctx, req)
		if err != nil {
			b.Fatalf("Unexpected error: %v", err)
		}
	}
}

// Helper function to create a test customer
func createTestCustomer(name, email string) *customerv1.Customer {
	return &customerv1.Customer{
		Name:   name,
		Email:  email,
		Status: customerv1.CustomerStatus_CUSTOMER_STATUS_ACTIVE,
		CreatedAt: timestamppb.New(time.Now()),
		UpdatedAt: timestamppb.New(time.Now()),
		Contact: &customerv1.ContactInfo{
			Phone: "+1-555-TEST-123",
		},
		Addresses: []*customerv1.Address{
			{
				Street:  "123 Test Ave",
				City:    "Test City",
				State:   "TC",
				ZipCode: "12345",
				Country: "USA",
				Type:    customerv1.AddressType_ADDRESS_TYPE_HOME,
			},
		},
		Metadata: map[string]string{
			"test": "true",
		},
	}
}
```

### Step 2: Add Missing Import and Fix Mock Publisher
Update `internal/customer/mock_publisher.go` to add the missing method:

```go
package customer

import (
	"context"
	"fmt"

	customerv1 "github.com/chinook/data-pipeline/pkg/proto/customer/v1"
)

// mockPublisher implements EventPublisher interface for testing
type mockPublisher struct {
	publishedEvents []string
}

// NewMockPublisher creates a new mock event publisher
func NewMockPublisher() EventPublisher {
	return &mockPublisher{
		publishedEvents: make([]string, 0),
	}
}

// PublishCustomerCreated publishes a customer created event
func (p *mockPublisher) PublishCustomerCreated(ctx context.Context, customer *customerv1.Customer) error {
	event := fmt.Sprintf("CustomerCreated: ID=%d, Name=%s", customer.Id, customer.Name)
	p.publishedEvents = append(p.publishedEvents, event)
	
	fmt.Printf("üì¢ Event Published: %s\n", event)
	return nil
}

// PublishCustomerUpdated publishes a customer updated event
func (p *mockPublisher) PublishCustomerUpdated(ctx context.Context, customer *customerv1.Customer) error {
	event := fmt.Sprintf("CustomerUpdated: ID=%d, Name=%s", customer.Id, customer.Name)
	p.publishedEvents = append(p.publishedEvents, event)
	
	fmt.Printf("üì¢ Event Published: %s\n", event)
	return nil
}

// PublishCustomerDeleted publishes a customer deleted event
func (p *mockPublisher) PublishCustomerDeleted(ctx context.Context, id int64) error {
	event := fmt.Sprintf("CustomerDeleted: ID=%d", id)
	p.publishedEvents = append(p.publishedEvents, event)
	
	fmt.Printf("üì¢ Event Published: %s\n", event)
	return nil
}

// GetPublishedEvents returns all published events (for testing)
func (p *mockPublisher) GetPublishedEvents() []string {
	return append([]string(nil), p.publishedEvents...) // Return a copy
}
```

### Step 3: Create an End-to-End Test Application
Create `cmd/integration-test/main.go`:

```go
package main

import (
	"context"
	"fmt"
	"log"
	"time"

	"github.com/chinook/data-pipeline/internal/customer"
	customerv1 "github.com/chinook/data-pipeline/pkg/proto/customer/v1"
	"google.golang.org/protobuf/encoding/protojson"
)

func main() {
	fmt.Println("üß™ Chinook Integration Test Suite")
	fmt.Println("=====================================")

	// Setup
	repo := customer.NewMockRepository()
	publisher := customer.NewMockPublisher()
	svc := customer.NewService(repo, publisher)
	ctx := context.Background()

	// Run integration tests
	tests := []struct {
		name string
		fn   func(context.Context, customer.Service) error
	}{
		{"Basic CRUD Operations", testBasicCRUD},
		{"Data Validation", testValidation},
		{"Pagination", testPagination},
		{"Event Publishing", testEventPublishing},
		{"Error Handling", testErrorHandling},
	}

	var passed, failed int
	for _, test := range tests {
		fmt.Printf("\nüî¨ Running: %s\n", test.name)
		start := time.Now()
		
		if err := test.fn(ctx, svc); err != nil {
			fmt.Printf("‚ùå FAILED: %v\n", err)
			failed++
		} else {
			fmt.Printf("‚úÖ PASSED (took %v)\n", time.Since(start))
			passed++
		}
	}

	// Summary
	fmt.Printf("\nüìä Test Results:\n")
	fmt.Printf("‚úÖ Passed: %d\n", passed)
	fmt.Printf("‚ùå Failed: %d\n", failed)
	fmt.Printf("üìà Success Rate: %.1f%%\n", float64(passed)/float64(passed+failed)*100)

	if failed == 0 {
		fmt.Println("\nüéâ All integration tests passed! Your foundation is solid!")
	} else {
		fmt.Println("\nüö® Some tests failed. Review and fix the issues.")
	}
}

func testBasicCRUD(ctx context.Context, svc customer.Service) error {
	// Create
	newCustomer := &customerv1.Customer{
		Name:   "Integration Test Customer",
		Email:  "integration@test.com",
		Status: customerv1.CustomerStatus_CUSTOMER_STATUS_ACTIVE,
		Contact: &customerv1.ContactInfo{
			Phone: "+1-555-INTEG-01",
		},
		Addresses: []*customerv1.Address{
			{
				Street:  "123 Integration St",
				City:    "Test City",
				State:   "TC",
				ZipCode: "12345",
				Country: "USA",
				Type:    customerv1.AddressType_ADDRESS_TYPE_HOME,
			},
		},
	}

	createResp, err := svc.CreateCustomer(ctx, &customerv1.CreateCustomerRequest{
		Customer: newCustomer,
	})
	if err != nil {
		return fmt.Errorf("create failed: %w", err)
	}

	// Read
	getResp, err := svc.GetCustomer(ctx, &customerv1.GetCustomerRequest{
		Id: createResp.Customer.Id,
	})
	if err != nil {
		return fmt.Errorf("read failed: %w", err)
	}

	if getResp.Customer.Name != newCustomer.Name {
		return fmt.Errorf("name mismatch: expected %s, got %s", 
			newCustomer.Name, getResp.Customer.Name)
	}

	// Update
	getResp.Customer.Email = "updated-integration@test.com"
	updateResp, err := svc.UpdateCustomer(ctx, &customerv1.UpdateCustomerRequest{
		Customer: getResp.Customer,
	})
	if err != nil {
		return fmt.Errorf("update failed: %w", err)
	}

	if updateResp.Customer.Email != "updated-integration@test.com" {
		return fmt.Errorf("email not updated correctly")
	}

	return nil
}

func testValidation(ctx context.Context, svc customer.Service) error {
	// Test invalid customer ID
	_, err := svc.GetCustomer(ctx, &customerv1.GetCustomerRequest{Id: -1})
	if err == nil {
		return fmt.Errorf("expected validation error for negative ID")
	}

	// Test invalid customer creation
	invalidCustomer := &customerv1.Customer{
		Name:  "", // Invalid: empty name
		Email: "invalid@test.com",
	}
	_, err = svc.CreateCustomer(ctx, &customerv1.CreateCustomerRequest{
		Customer: invalidCustomer,
	})
	if err == nil {
		return fmt.Errorf("expected validation error for empty name")
	}

	return nil
}

func testPagination(ctx context.Context, svc customer.Service) error {
	// Test list with small page size
	resp, err := svc.ListCustomers(ctx, &customerv1.ListCustomersRequest{
		PageSize: 1,
	})
	if err != nil {
		return fmt.Errorf("list customers failed: %w", err)
	}

	if len(resp.Customers) > 1 {
		return fmt.Errorf("expected max 1 customer, got %d", len(resp.Customers))
	}

	if resp.NextPageToken == "" {
		return fmt.Errorf("expected next page token for pagination")
	}

	return nil
}

func testEventPublishing(ctx context.Context, svc customer.Service) error {
	// This test assumes we can access the mock publisher
	// In a real system, you'd test event publishing differently
	
	// Create a customer (should trigger event)
	newCustomer := &customerv1.Customer{
		Name:   "Event Test Customer",
		Email:  "event@test.com",
		Status: customerv1.CustomerStatus_CUSTOMER_STATUS_ACTIVE,
		Contact: &customerv1.ContactInfo{
			Phone: "+1-555-EVENT-01",
		},
		Addresses: []*customerv1.Address{
			{
				Street:  "456 Event St",
				City:    "Event City",
				State:   "EV",
				ZipCode: "54321",
				Country: "USA",
				Type:    customerv1.AddressType_ADDRESS_TYPE_WORK,
			},
		},
	}

	_, err := svc.CreateCustomer(ctx, &customerv1.CreateCustomerRequest{
		Customer: newCustomer,
	})
	if err != nil {
		return fmt.Errorf("customer creation failed: %w", err)
	}

	// In a real system, you'd verify the event was published to your event system
	fmt.Printf("  üì¢ Event publishing verified (check console output)\n")
	return nil
}

func testErrorHandling(ctx context.Context, svc customer.Service) error {
	// Test getting non-existent customer
	_, err := svc.GetCustomer(ctx, &customerv1.GetCustomerRequest{Id: 99999})
	if err == nil {
		return fmt.Errorf("expected error for non-existent customer")
	}

	// Verify error message contains context
	if err.Error() == "" {
		return fmt.Errorf("error message should not be empty")
	}

	return nil
}
```

### Step 4: Run All Tests
```bash
# Run unit tests
go test ./internal/customer/... -v

# Run integration test application
go run cmd/integration-test/main.go

# Run benchmark tests
go test -bench=. ./internal/customer/...

# Run tests with coverage
go test -cover ./internal/customer/...
```

### Step 5: Create a Test Summary Script
Create `scripts/run-tests.sh`:

```bash
#!/bin/bash
set -e

echo "üß™ Running Chinook Test Suite"
echo "================================="

# Step 1: Run unit tests
echo "üìã Running unit tests..."
go test ./internal/... -v -cover

# Step 2: Run integration tests
echo -e "\nüîó Running integration tests..."
go run cmd/integration-test/main.go

# Step 3: Run benchmarks
echo -e "\n‚ö° Running performance benchmarks..."
go test -bench=. ./internal/... -benchmem

# Step 4: Check test coverage
echo -e "\nüìä Generating test coverage report..."
go test -coverprofile=coverage.out ./internal/...
go tool cover -html=coverage.out -o coverage.html

echo -e "\n‚úÖ Test suite completed!"
echo "üìÑ Coverage report saved to coverage.html"
```

```bash
# Make it executable
chmod +x scripts/run-tests.sh

# Run the full test suite
./scripts/run-tests.sh
```

## üí• Deliberate Failure: Performance Testing

### Break It:
1. Create 1000 customers in a loop and measure performance
2. Try concurrent access to the mock repository
3. See how your system handles load

### Fix It:
Identify bottlenecks and optimize. Consider adding connection pooling, caching, or better data structures.

## üîç Further Exploration

1. **Add table-driven tests** for comprehensive test cases
2. **Implement property-based testing** using libraries like gopter
3. **Add chaos testing** by randomly failing dependencies
4. **Create load tests** using tools like hey or wrk

## ‚úÖ Victory Conditions

- [ ] All unit tests pass
- [ ] Integration tests demonstrate end-to-end functionality
- [ ] Performance benchmarks provide baseline metrics
- [ ] Test coverage is reasonable (>80%)
- [ ] Error scenarios are properly tested

## üö® Common Issues & Solutions

**Issue**: Tests are flaky or inconsistent
**Solution**: Use proper test isolation and avoid shared state

**Issue**: "go test" hangs indefinitely
**Solution**: Check for goroutine leaks or infinite loops

**Issue**: Coverage reports show low coverage
**Solution**: Add tests for error paths and edge cases

---

**üéâ Congratulations!** You've completed Day 1 and built a solid foundation with:
- ‚úÖ Proper Go project structure
- ‚úÖ Protobuf schema design and code generation
- ‚úÖ Buf configuration and workflows
- ‚úÖ Clean service architecture with dependency injection
- ‚úÖ Comprehensive testing strategy

**Next**: Tomorrow (Day 2) you'll dive deep into advanced Protobuf concepts and schema evolution! üöÄ