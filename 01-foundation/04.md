# Lab 4: üè¢ Go Service Architecture

Time to build a proper Go service architecture! You'll learn idiomatic Go patterns, dependency injection, and service layer design.

## üéØ Objectives
- Design clean service interfaces following Go idioms
- Implement dependency injection without frameworks
- Create proper error handling patterns
- Build a testable service architecture

## üõ†Ô∏è Tasks

### Step 1: Define Service Interfaces
Create `internal/customer/interfaces.go`:

```go
package customer

import (
	"context"

	customerv1 "github.com/chinook/data-pipeline/pkg/proto/customer/v1"
)

// Repository defines the data access interface
// Small, focused interfaces are the Go way!
type Repository interface {
	// Basic CRUD operations
	GetCustomer(ctx context.Context, id int64) (*customerv1.Customer, error)
	ListCustomers(ctx context.Context, filter ListFilter) ([]*customerv1.Customer, error)
	CreateCustomer(ctx context.Context, customer *customerv1.Customer) (*customerv1.Customer, error)
	UpdateCustomer(ctx context.Context, customer *customerv1.Customer) (*customerv1.Customer, error)
	DeleteCustomer(ctx context.Context, id int64) error
}

// EventPublisher defines the event publishing interface
type EventPublisher interface {
	PublishCustomerCreated(ctx context.Context, customer *customerv1.Customer) error
	PublishCustomerUpdated(ctx context.Context, customer *customerv1.Customer) error
	PublishCustomerDeleted(ctx context.Context, id int64) error
}

// ListFilter defines filtering options for listing customers
type ListFilter struct {
	PageSize   int32
	PageToken  string
	Status     customerv1.CustomerStatus
	SearchTerm string
}

// Service defines the business logic interface
type Service interface {
	GetCustomer(ctx context.Context, req *customerv1.GetCustomerRequest) (*customerv1.GetCustomerResponse, error)
	ListCustomers(ctx context.Context, req *customerv1.ListCustomersRequest) (*customerv1.ListCustomersResponse, error)
	CreateCustomer(ctx context.Context, req *customerv1.CreateCustomerRequest) (*customerv1.CreateCustomerResponse, error)
	UpdateCustomer(ctx context.Context, req *customerv1.UpdateCustomerRequest) (*customerv1.UpdateCustomerResponse, error)
}
```

### Step 2: Implement the Service with Proper Error Handling
Update `internal/customer/service.go`:

```go
package customer

import (
	"context"
	"fmt"
	"time"

	customerv1 "github.com/chinook/data-pipeline/pkg/proto/customer/v1"
	"google.golang.org/protobuf/types/known/timestamppb"
)

// service implements the Service interface
type service struct {
	repo      Repository
	publisher EventPublisher
}

// NewService creates a new customer service with dependency injection
// This is the Go way: explicit dependencies, no magic!
func NewService(repo Repository, publisher EventPublisher) Service {
	return &service{
		repo:      repo,
		publisher: publisher,
	}
}

// GetCustomer retrieves a customer by ID
func (s *service) GetCustomer(ctx context.Context, req *customerv1.GetCustomerRequest) (*customerv1.GetCustomerResponse, error) {
	// Input validation (defense in depth!)
	if err := req.Validate(); err != nil {
		return nil, fmt.Errorf("invalid request: %w", err)
	}

	// Business logic: retrieve customer
	customer, err := s.repo.GetCustomer(ctx, req.Id)
	if err != nil {
		// Wrap errors with context - the Go way!
		return nil, fmt.Errorf("failed to get customer %d: %w", req.Id, err)
	}

	return &customerv1.GetCustomerResponse{
		Customer: customer,
	}, nil
}

// ListCustomers returns customers with pagination
func (s *service) ListCustomers(ctx context.Context, req *customerv1.ListCustomersRequest) (*customerv1.ListCustomersResponse, error) {
	if err := req.Validate(); err != nil {
		return nil, fmt.Errorf("invalid request: %w", err)
	}

	// Convert protobuf request to internal filter
	filter := ListFilter{
		PageSize:  req.PageSize,
		PageToken: req.PageToken,
	}

	// TODO: Parse req.Filter into structured filter
	// For now, we'll use a simple approach

	customers, err := s.repo.ListCustomers(ctx, filter)
	if err != nil {
		return nil, fmt.Errorf("failed to list customers: %w", err)
	}

	return &customerv1.ListCustomersResponse{
		Customers:     customers,
		NextPageToken: "next_page_token_123", // TODO: Implement real pagination
		TotalCount:    int32(len(customers)),
	}, nil
}

// CreateCustomer creates a new customer
func (s *service) CreateCustomer(ctx context.Context, req *customerv1.CreateCustomerRequest) (*customerv1.CreateCustomerResponse, error) {
	if err := req.Validate(); err != nil {
		return nil, fmt.Errorf("invalid request: %w", err)
	}

	// Business logic: set creation timestamp
	now := timestamppb.New(time.Now())
	req.Customer.CreatedAt = now
	req.Customer.UpdatedAt = now

	// Create customer in repository
	customer, err := s.repo.CreateCustomer(ctx, req.Customer)
	if err != nil {
		return nil, fmt.Errorf("failed to create customer: %w", err)
	}

	// Publish event (fire and forget pattern with error logging)
	if err := s.publisher.PublishCustomerCreated(ctx, customer); err != nil {
		// Log error but don't fail the request
		// In production, you might want to use a proper logger
		fmt.Printf("Warning: failed to publish customer created event: %v\n", err)
	}

	return &customerv1.CreateCustomerResponse{
		Customer: customer,
	}, nil
}

// UpdateCustomer updates an existing customer
func (s *service) UpdateCustomer(ctx context.Context, req *customerv1.UpdateCustomerRequest) (*customerv1.UpdateCustomerResponse, error) {
	if err := req.Validate(); err != nil {
		return nil, fmt.Errorf("invalid request: %w", err)
	}

	// Business logic: update timestamp
	req.Customer.UpdatedAt = timestamppb.New(time.Now())

	// Update customer in repository
	customer, err := s.repo.UpdateCustomer(ctx, req.Customer)
	if err != nil {
		return nil, fmt.Errorf("failed to update customer: %w", err)
	}

	// Publish event
	if err := s.publisher.PublishCustomerUpdated(ctx, customer); err != nil {
		fmt.Printf("Warning: failed to publish customer updated event: %v\n", err)
	}

	return &customerv1.UpdateCustomerResponse{
		Customer: customer,
	}, nil
}
```

### Step 3: Create a Mock Repository for Testing
Create `internal/customer/mock_repository.go`:

```go
package customer

import (
	"context"
	"fmt"
	"sync"
	"time"

	customerv1 "github.com/chinook/data-pipeline/pkg/proto/customer/v1"
	"google.golang.org/protobuf/types/known/timestamppb"
)

// mockRepository implements Repository interface for testing
type mockRepository struct {
	mu        sync.RWMutex
	customers map[int64]*customerv1.Customer
	nextID    int64
}

// NewMockRepository creates a new mock repository with sample data
func NewMockRepository() Repository {
	now := timestamppb.New(time.Now())
	
	repo := &mockRepository{
		customers: make(map[int64]*customerv1.Customer),
		nextID:    1,
	}

	// Add some sample customers
	sampleCustomers := []*customerv1.Customer{
		{
			Id:     1,
			Name:   "Alice Smith",
			Email:  "alice@chinook.com",
			Status: customerv1.CustomerStatus_CUSTOMER_STATUS_ACTIVE,
			CreatedAt: now,
			UpdatedAt: now,
			Contact: &customerv1.ContactInfo{
				Phone:  "+1-555-100-0001",
				Mobile: "+1-555-200-0001",
			},
			Addresses: []*customerv1.Address{
				{
					Street:  "123 Tech Ave",
					City:    "San Francisco",
					State:   "CA",
					ZipCode: "94105",
					Country: "USA",
					Type:    customerv1.AddressType_ADDRESS_TYPE_WORK,
				},
			},
			Metadata: map[string]string{
				"signup_source": "website",
				"tier":         "enterprise",
			},
		},
		{
			Id:     2,
			Name:   "Bob Johnson",
			Email:  "bob@example.com",
			Status: customerv1.CustomerStatus_CUSTOMER_STATUS_ACTIVE,
			CreatedAt: now,
			UpdatedAt: now,
			Contact: &customerv1.ContactInfo{
				Phone: "+1-555-100-0002",
			},
			Addresses: []*customerv1.Address{
				{
					Street:  "456 Main St",
					City:    "Austin",
					State:   "TX",
					ZipCode: "78701",
					Country: "USA",
					Type:    customerv1.AddressType_ADDRESS_TYPE_HOME,
				},
			},
			Metadata: map[string]string{
				"signup_source": "referral",
				"tier":         "standard",
			},
		},
	}

	for _, customer := range sampleCustomers {
		repo.customers[customer.Id] = customer
		if customer.Id >= repo.nextID {
			repo.nextID = customer.Id + 1
		}
	}

	return repo
}

// GetCustomer retrieves a customer by ID
func (r *mockRepository) GetCustomer(ctx context.Context, id int64) (*customerv1.Customer, error) {
	r.mu.RLock()
	defer r.mu.RUnlock()

	customer, exists := r.customers[id]
	if !exists {
		return nil, fmt.Errorf("customer with ID %d not found", id)
	}

	// Return a copy to prevent external modification
	return cloneCustomer(customer), nil
}

// ListCustomers returns customers based on filter
func (r *mockRepository) ListCustomers(ctx context.Context, filter ListFilter) ([]*customerv1.Customer, error) {
	r.mu.RLock()
	defer r.mu.RUnlock()

	var result []*customerv1.Customer
	
	for _, customer := range r.customers {
		// Apply status filter
		if filter.Status != customerv1.CustomerStatus_CUSTOMER_STATUS_UNSPECIFIED && 
		   customer.Status != filter.Status {
			continue
		}

		// Apply search term filter (simple name/email search)
		if filter.SearchTerm != "" {
			// This is a simple implementation - in real systems you'd use proper text search
			if !contains(customer.Name, filter.SearchTerm) && 
			   !contains(customer.Email, filter.SearchTerm) {
				continue
			}
		}

		result = append(result, cloneCustomer(customer))
	}

	// Simple pagination (in real systems, you'd implement proper cursor-based pagination)
	pageSize := filter.PageSize
	if pageSize <= 0 {
		pageSize = 10
	}

	if int32(len(result)) > pageSize {
		result = result[:pageSize]
	}

	return result, nil
}

// CreateCustomer creates a new customer
func (r *mockRepository) CreateCustomer(ctx context.Context, customer *customerv1.Customer) (*customerv1.Customer, error) {
	r.mu.Lock()
	defer r.mu.Unlock()

	// Assign new ID
	customer.Id = r.nextID
	r.nextID++

	// Store the customer
	r.customers[customer.Id] = cloneCustomer(customer)

	return cloneCustomer(customer), nil
}

// UpdateCustomer updates an existing customer
func (r *mockRepository) UpdateCustomer(ctx context.Context, customer *customerv1.Customer) (*customerv1.Customer, error) {
	r.mu.Lock()
	defer r.mu.Unlock()

	if _, exists := r.customers[customer.Id]; !exists {
		return nil, fmt.Errorf("customer with ID %d not found", customer.Id)
	}

	// Update the customer
	r.customers[customer.Id] = cloneCustomer(customer)

	return cloneCustomer(customer), nil
}

// DeleteCustomer deletes a customer
func (r *mockRepository) DeleteCustomer(ctx context.Context, id int64) error {
	r.mu.Lock()
	defer r.mu.Unlock()

	if _, exists := r.customers[id]; !exists {
		return fmt.Errorf("customer with ID %d not found", id)
	}

	delete(r.customers, id)
	return nil
}

// Helper functions

func cloneCustomer(customer *customerv1.Customer) *customerv1.Customer {
	// In a real implementation, you'd use proper deep cloning
	// For this example, we'll use protobuf's clone method
	return customer.ProtoReflect().New().Interface().(customerv1.Customer)
}

func contains(str, substr string) bool {
	// Simple case-insensitive contains check
	// In production, use proper string comparison
	return len(str) >= len(substr) && 
		   str[:len(substr)] == substr
}
```

### Step 4: Create a Mock Event Publisher
Create `internal/customer/mock_publisher.go`:

```go
package customer

import (
	"context"
	"fmt"

	customerv1 "github.com/chinook/data-pipeline/pkg/proto/customer/v1"
)

// mockPublisher implements EventPublisher interface for testing
type mockPublisher struct {
	// In a real implementation, you might want to track published events
	publishedEvents []string
}

// NewMockPublisher creates a new mock event publisher
func NewMockPublisher() EventPublisher {
	return &mockPublisher{
		publishedEvents: make([]string, 0),
	}
}

// PublishCustomerCreated publishes a customer created event
func (p *mockPublisher) PublishCustomerCreated(ctx context.Context, customer *customerv1.Customer) error {
	event := fmt.Sprintf("CustomerCreated: ID=%d, Name=%s", customer.Id, customer.Name)
	p.publishedEvents = append(p.publishedEvents, event)
	
	// Simulate event publishing
	fmt.Printf("üì¢ Event Published: %s\n", event)
	
	return nil
}

// PublishCustomerUpdated publishes a customer updated event
func (p *mockPublisher) PublishCustomerUpdated(ctx context.Context, customer *customerv1.Customer) error {
	event := fmt.Sprintf("CustomerUpdated: ID=%d, Name=%s", customer.Id, customer.Name)
	p.publishedEvents = append(p.publishedEvents, event)
	
	fmt.Printf("üì¢ Event Published: %s\n", event)
	
	return nil
}

// PublishCustomerDeleted publishes a customer deleted event
func (p *mockPublisher) PublishCustomerDeleted(ctx context.Context, id int64) error {
	event := fmt.Sprintf("CustomerDeleted: ID=%d", id)
	p.publishedEvents = append(p.publishedEvents, event)
	
	fmt.Printf("üì¢ Event Published: %s\n", event)
	
	return nil
}

// GetPublishedEvents returns all published events (for testing)
func (p *mockPublisher) GetPublishedEvents() []string {
	return p.publishedEvents
}
```

### Step 5: Update Your Main Application
Update `cmd/producer/main.go` to use the new architecture:

```go
package main

import (
	"context"
	"fmt"
	"log"

	"github.com/chinook/data-pipeline/internal/customer"
	customerv1 "github.com/chinook/data-pipeline/pkg/proto/customer/v1"
	"google.golang.org/protobuf/encoding/protojson"
)

func main() {
	fmt.Println("üè≠ Chinook Data Producer with Service Architecture!")

	// Dependency injection - the Go way!
	repo := customer.NewMockRepository()
	publisher := customer.NewMockPublisher()
	customerSvc := customer.NewService(repo, publisher)

	ctx := context.Background()

	// Test GetCustomer
	fmt.Println("\nüîç Testing GetCustomer...")
	getReq := &customerv1.GetCustomerRequest{Id: 1}
	getResp, err := customerSvc.GetCustomer(ctx, getReq)
	if err != nil {
		log.Fatalf("Failed to get customer: %v", err)
	}

	fmt.Printf("Retrieved: %s (%s)\n", getResp.Customer.Name, getResp.Customer.Email)

	// Test ListCustomers
	fmt.Println("\nüìã Testing ListCustomers...")
	listReq := &customerv1.ListCustomersRequest{
		PageSize: 10,
		Filter:   "status=active",
	}
	listResp, err := customerSvc.ListCustomers(ctx, listReq)
	if err != nil {
		log.Fatalf("Failed to list customers: %v", err)
	}

	fmt.Printf("Found %d customers:\n", len(listResp.Customers))
	for _, c := range listResp.Customers {
		fmt.Printf("  - %s (%s) [%s]\n", c.Name, c.Email, c.Status.String())
	}

	// Test CreateCustomer
	fmt.Println("\n‚ú® Testing CreateCustomer...")
	newCustomer := &customerv1.Customer{
		Name:   "Charlie Brown",
		Email:  "charlie@chinook.com",
		Status: customerv1.CustomerStatus_CUSTOMER_STATUS_ACTIVE,
		Contact: &customerv1.ContactInfo{
			Phone: "+1-555-300-0003",
		},
		Addresses: []*customerv1.Address{
			{
				Street:  "789 New St",
				City:    "Denver",
				State:   "CO",
				ZipCode: "80202",
				Country: "USA",
				Type:    customerv1.AddressType_ADDRESS_TYPE_HOME,
			},
		},
		Metadata: map[string]string{
			"signup_source": "mobile_app",
			"tier":         "premium",
		},
	}

	createReq := &customerv1.CreateCustomerRequest{Customer: newCustomer}
	createResp, err := customerSvc.CreateCustomer(ctx, createReq)
	if err != nil {
		log.Fatalf("Failed to create customer: %v", err)
	}

	fmt.Printf("Created customer with ID: %d\n", createResp.Customer.Id)

	// Test UpdateCustomer
	fmt.Println("\nüîÑ Testing UpdateCustomer...")
	createResp.Customer.Email = "charlie.brown@chinook.com"
	updateReq := &customerv1.UpdateCustomerRequest{Customer: createResp.Customer}
	updateResp, err := customerSvc.UpdateCustomer(ctx, updateReq)
	if err != nil {
		log.Fatalf("Failed to update customer: %v", err)
	}

	fmt.Printf("Updated customer email to: %s\n", updateResp.Customer.Email)

	// Pretty print the final customer as JSON
	fmt.Println("\nüìÑ Final customer JSON:")
	jsonBytes, _ := protojson.MarshalOptions{Indent: "  "}.Marshal(updateResp.Customer)
	fmt.Println(string(jsonBytes))

	fmt.Println("\n‚úÖ Service architecture test completed!")
}
```

### Step 6: Test Your Service Architecture
```bash
# Run your application
go run cmd/producer/main.go

# You should see:
# - Customer retrieval working
# - List customers with sample data
# - Customer creation with event publishing
# - Customer updates with event publishing
# - JSON output of the final customer
```

## üí• Deliberate Failure: Error Handling Practice

### Break It:
1. Try getting a non-existent customer (ID 999)
2. Try creating a customer with invalid data (empty name)
3. See how Go's explicit error handling works

### Fix It:
The errors should be properly wrapped and informative. Notice how each layer adds context to the error.

## üîç Further Exploration

1. **Add middleware** for logging, metrics, and tracing
2. **Implement real pagination** with cursor-based tokens
3. **Add caching layer** using an interface
4. **Create unit tests** for the service layer

## ‚úÖ Victory Conditions

- [ ] Service interfaces are clean and focused
- [ ] Dependency injection works without frameworks
- [ ] Error handling provides helpful context
- [ ] Events are published correctly
- [ ] All CRUD operations work through the service layer

## üö® Common Issues & Solutions

**Issue**: Interface compilation errors
**Solution**: Make sure all interface methods are implemented

**Issue**: "nil pointer dereference" panics
**Solution**: Always check for nil before dereferencing pointers

**Issue**: Race conditions in mock repository
**Solution**: Use proper locking (RWMutex) for concurrent access

---

**Next**: Head to `lab05/` for your integration test! üß™