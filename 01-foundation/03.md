# Lab 3: üîß Buf Configuration & Workflows

Time to set up professional-grade protobuf workflows with Buf! You'll learn linting, breaking change detection, and dependency management.

## üéØ Objectives
- Configure Buf for your project
- Set up linting rules and breaking change detection
- Learn Buf's dependency management
- Create a professional protobuf workflow

## üõ†Ô∏è Tasks

### Step 1: Initialize Buf in Your Project
```bash
# From your workshop root directory
buf mod init

# This creates buf.yaml - the heart of your Buf configuration
```

### Step 2: Configure buf.yaml
Update your `buf.yaml`:

```yaml
version: v1
name: buf.build/chinook/customer-api
# Note: In real projects, use your actual BSR (Buf Schema Registry) name

# Dependency management (like package.json for protobuf!)
deps:
  - buf.build/googleapis/googleapis        # Google common types
  - buf.build/protocolbuffers/wellknowntypes  # Timestamp, etc.

# Breaking change detection
breaking:
  use:
    - FILE          # Detect file-level breaking changes
    - PACKAGE       # Detect package-level breaking changes
  except:
    - FIELD_SAME_DEFAULT  # Allow changing default values
  
  # Compare against previous version (we'll set this up later)
  # against: "git#tag=v1.0.0"

# Linting rules - enforce best practices
lint:
  use:
    - DEFAULT                    # Standard protobuf style
    - COMMENTS                   # Require comments on public types
    - FILE_LOWER_SNAKE_CASE     # file_names_like_this.proto
    - PACKAGE_VERSION_SUFFIX    # packages must end with version (v1, v2, etc.)
  
  except:
    - PACKAGE_DIRECTORY_MATCH   # Allow flexible directory structure
  
  # Custom rules for your organization
  enum_zero_value_suffix: _UNSPECIFIED
  rpc_allow_same_request_response: false
  rpc_allow_google_protobuf_empty_requests: true
  rpc_allow_google_protobuf_empty_responses: true

# File paths to include/exclude
build:
  excludes:
    - vendor/                   # Exclude vendor directory
    - .git/                     # Exclude git metadata
    - "**/*_test.proto"         # Exclude test protos
```

### Step 3: Set Up Advanced Code Generation
Update your `buf.gen.yaml` with more options:

```yaml
version: v1

# Managed mode - Buf handles imports automatically
managed:
  enabled: true
  go_package_prefix:
    default: github.com/chinook/data-pipeline/pkg/proto
    except:
      - buf.build/googleapis/googleapis
      - buf.build/protocolbuffers/wellknowntypes

plugins:
  # Go protobuf code generation
  - plugin: buf.build/protocolbuffers/go:v1.31.0
    out: pkg/proto
    opt:
      - paths=source_relative
      - Mgoogle/protobuf/timestamp.proto=google.golang.org/protobuf/types/known/timestamppb
      - Mgoogle/protobuf/duration.proto=google.golang.org/protobuf/types/known/durationpb
  
  # Go gRPC code generation  
  - plugin: buf.build/grpc/go:v1.2.0
    out: pkg/proto
    opt:
      - paths=source_relative
  
  # Validation code generation (optional but powerful!)
  - plugin: buf.build/bufbuild/validate-go:v1.0.0
    out: pkg/proto
    opt:
      - paths=source_relative
  
  # Documentation generation
  - plugin: buf.build/bufbuild/buf-plugin-doc:v1.0.0
    out: docs
    opt:
      - template=html
      - index.html
```

### Step 4: Enhance Your Proto with Validation
Update `api/customer/v1/customer.proto` to include validation:

```protobuf
syntax = "proto3";

package customer.v1;

option go_package = "github.com/chinook/data-pipeline/pkg/proto/customer/v1;customerv1";

import "google/protobuf/timestamp.proto";
import "validate/validate.proto";  // Buf validation rules

// Customer represents a Chinook customer with validation rules
message Customer {
  // ID must be positive
  int64 id = 1 [(validate.rules).int64.gt = 0];
  
  // Name is required and must be 2-100 characters
  string name = 2 [(validate.rules).string = {
    min_len: 2,
    max_len: 100,
    pattern: "^[a-zA-Z\\s]+$"  // Only letters and spaces
  }];
  
  // Email must be valid format
  string email = 3 [(validate.rules).string.email = true];
  
  // Status cannot be unspecified
  CustomerStatus status = 4 [(validate.rules).enum = {
    not_in: [0]  // Cannot be UNSPECIFIED
  }];
  
  google.protobuf.Timestamp created_at = 5 [(validate.rules).timestamp.required = true];
  google.protobuf.Timestamp updated_at = 6;
  
  // Contact info is required
  ContactInfo contact = 7 [(validate.rules).message.required = true];
  
  // At least one address required
  repeated Address addresses = 8 [(validate.rules).repeated.min_items = 1];
  
  // Metadata keys must follow pattern
  map<string, string> metadata = 15 [(validate.rules).map = {
    max_pairs: 10,
    keys: {string: {pattern: "^[a-z_]+$"}},  // snake_case keys only
    values: {string: {max_len: 255}}
  }];
}

// Rest of your proto remains the same...
enum CustomerStatus {
  CUSTOMER_STATUS_UNSPECIFIED = 0;
  CUSTOMER_STATUS_ACTIVE = 1;
  CUSTOMER_STATUS_INACTIVE = 2;
  CUSTOMER_STATUS_SUSPENDED = 3;
}

message ContactInfo {
  // Phone must be valid format
  string phone = 1 [(validate.rules).string = {
    pattern: "^\\+?[1-9]\\d{1,14}$"  // E.164 format
  }];
  string mobile = 2 [(validate.rules).string = {
    pattern: "^\\+?[1-9]\\d{1,14}$"
  }];
  string fax = 3;
}

message Address {
  string street = 1 [(validate.rules).string.min_len = 1];
  string city = 2 [(validate.rules).string.min_len = 1];
  string state = 3 [(validate.rules).string.min_len = 1];
  string zip_code = 4 [(validate.rules).string = {
    pattern: "^\\d{5}(-\\d{4})?$"  // US ZIP format
  }];
  string country = 5 [(validate.rules).string.min_len = 2];
  AddressType type = 6 [(validate.rules).enum = {not_in: [0]}];
}

enum AddressType {
  ADDRESS_TYPE_UNSPECIFIED = 0;
  ADDRESS_TYPE_HOME = 1;
  ADDRESS_TYPE_WORK = 2;
  ADDRESS_TYPE_BILLING = 3;
  ADDRESS_TYPE_SHIPPING = 4;
}

// Service definition remains the same...
service CustomerService {
  rpc GetCustomer(GetCustomerRequest) returns (GetCustomerResponse);
  rpc ListCustomers(ListCustomersRequest) returns (ListCustomersResponse);
  rpc CreateCustomer(CreateCustomerRequest) returns (CreateCustomerResponse);
  rpc UpdateCustomer(UpdateCustomerRequest) returns (UpdateCustomerResponse);
}

message GetCustomerRequest {
  int64 id = 1 [(validate.rules).int64.gt = 0];
}

message GetCustomerResponse {
  Customer customer = 1 [(validate.rules).message.required = true];
}

message ListCustomersRequest {
  int32 page_size = 1 [(validate.rules).int32 = {gte: 1, lte: 100}];
  string page_token = 2;
  string filter = 3 [(validate.rules).string.max_len = 255];
}

message ListCustomersResponse {
  repeated Customer customers = 1;
  string next_page_token = 2;
  int32 total_count = 3 [(validate.rules).int32.gte = 0];
}

message CreateCustomerRequest {
  Customer customer = 1 [(validate.rules).message.required = true];
}

message CreateCustomerResponse {
  Customer customer = 1 [(validate.rules).message.required = true];
}

message UpdateCustomerRequest {
  Customer customer = 1 [(validate.rules).message.required = true];
}

message UpdateCustomerResponse {
  Customer customer = 1 [(validate.rules).message.required = true];
}
```

### Step 5: Create a Buf Workflow Script
Create `scripts/buf-workflow.sh`:

```bash
#!/bin/bash
set -e

echo "üîç Running Buf workflow..."

# Step 1: Format proto files
echo "üìù Formatting proto files..."
buf format -w

# Step 2: Lint proto files
echo "üîç Linting proto files..."
buf lint

# Step 3: Check for breaking changes (if we have a baseline)
echo "üí• Checking for breaking changes..."
if git rev-parse --verify HEAD~1 >/dev/null 2>&1; then
    buf breaking --against '.git#ref=HEAD~1'
else
    echo "‚ÑπÔ∏è  No previous commit found, skipping breaking change detection"
fi

# Step 4: Generate code
echo "‚ö° Generating code..."
buf generate

# Step 5: Build project
echo "üèóÔ∏è  Building Go code..."
go build ./...

echo "‚úÖ Buf workflow completed successfully!"
```

```bash
# Make it executable
chmod +x scripts/buf-workflow.sh
```

### Step 6: Test Your Buf Configuration
```bash
# Run the full workflow
./scripts/buf-workflow.sh

# Test individual commands:

# Lint your proto files
buf lint

# Format your proto files  
buf format -w

# Generate code with new validation
buf generate

# Check that validation works
go mod tidy
go run cmd/producer/main.go
```

### Step 7: Test Validation in Your Code
Update `cmd/producer/main.go` to test validation:

```go
package main

import (
	"context"
	"fmt"
	"log"

	"github.com/chinook/data-pipeline/internal/customer"
	customerv1 "github.com/chinook/data-pipeline/pkg/proto/customer/v1"
)

func main() {
	fmt.Println("üè≠ Chinook Data Producer with Validation!")

	customerSvc := customer.NewService()
	ctx := context.Background()

	// Test with valid data
	fmt.Println("\n‚úÖ Testing valid customer...")
	validReq := &customerv1.GetCustomerRequest{Id: 1}
	
	// Validate the request
	if err := validReq.Validate(); err != nil {
		log.Printf("Validation failed: %v", err)
	} else {
		fmt.Println("‚úÖ Valid request!")
	}

	resp, err := customerSvc.GetCustomer(ctx, validReq)
	if err != nil {
		log.Fatalf("Failed to get customer: %v", err)
	}

	// Validate the response
	if err := resp.Validate(); err != nil {
		log.Printf("Response validation failed: %v", err)
	} else {
		fmt.Println("‚úÖ Valid response!")
	}

	// Test with invalid data
	fmt.Println("\n‚ùå Testing invalid customer...")
	invalidReq := &customerv1.GetCustomerRequest{Id: -1} // Invalid: must be > 0
	
	if err := invalidReq.Validate(); err != nil {
		fmt.Printf("‚ùå Validation correctly caught error: %v\n", err)
	}

	fmt.Println("\nüéØ Validation system working correctly!")
}
```

## üí• Deliberate Failure: Breaking Change Detection

### Break It:
1. Commit your current proto files to git
2. Change a field type (e.g., `int64 id` to `string id`)
3. Run `buf breaking --against '.git#ref=HEAD~1'`
4. See the breaking change detection in action!

### Fix It:
Revert the breaking change and see how Buf protects you from accidentally breaking your API.

## üîç Further Exploration

1. **Set up BSR (Buf Schema Registry)** for dependency management
2. **Add custom lint rules** specific to your organization
3. **Integrate Buf into CI/CD** pipeline
4. **Explore Buf's connect-go** for gRPC alternatives

## ‚úÖ Victory Conditions

- [ ] Buf configuration works without errors
- [ ] Linting passes on your proto files
- [ ] Code generation includes validation
- [ ] Breaking change detection works
- [ ] Validation catches invalid data

## üö® Common Issues & Solutions

**Issue**: Validation import not found
**Solution**: Run `buf mod update` to download dependencies

**Issue**: Breaking change false positives
**Solution**: Use `except` rules in buf.yaml breaking configuration

**Issue**: Generated code import errors
**Solution**: Ensure `go_package_prefix` matches your module structure

---

**Next**: Head to `lab04/` to build your Go service architecture! üè¢