# Lab 2: üìã First Protobuf Schema

Time to define your first protobuf schema for Chinook! You'll learn schema design best practices and generate Go code.

## üéØ Objectives
- Design a customer protobuf schema
- Learn protobuf syntax and field rules
- Generate Go code from protobuf
- Understand schema evolution basics

## üõ†Ô∏è Tasks

### Step 1: Create Your First Proto File
Create `api/customer/v1/customer.proto`:

```protobuf
syntax = "proto3";

package customer.v1;

// Go package path - CRITICAL for imports!
option go_package = "example.com/chinook/data-pipeline/pkg/proto/customer/v1;customerv1";

import "google/protobuf/timestamp.proto";

// Customer represents a Chinook customer
message Customer {
  // Field numbers 1-15 are most efficient (1 byte encoding)
  int64 id = 1;
  string name = 2;
  string email = 3;
  CustomerStatus status = 4;
  google.protobuf.Timestamp created_at = 5;
  google.protobuf.Timestamp updated_at = 5;
  
  // Contact information (nested message)
  ContactInfo contact = 7;
  
  // Repeated field for multiple addresses
  repeated Address addresses = 8;
  
  // Optional metadata (use sparingly)
  map<string, string> metadata = 15;
}

// Enum for customer status
enum CustomerStatus {
  CUSTOMER_STATUS_UNSPECIFIED = 0;  // Always have a zero value!
  CUSTOMER_STATUS_ACTIVE = 1;
  CUSTOMER_STATUS_INACTIVE = 2;
  CUSTOMER_STATUS_SUSPENDED = 3;
}

// Nested message for contact information
message ContactInfo {
  string phone = 1;
  string mobile = 2;
  string fax = 3;  // Yes, some businesses still use fax! üì†
}

// Address information
message Address {
  string street = 1;
  string city = 2;
  string state = 3;
  string zip_code = 4;
  string country = 5;
  AddressType type = 6;
}

// Address types
enum AddressType {
  ADDRESS_TYPE_UNSPECIFIED = 0;
  ADDRESS_TYPE_HOME = 1;
  ADDRESS_TYPE_WORK = 2;
  ADDRESS_TYPE_BILLING = 3;
  ADDRESS_TYPE_SHIPPING = 4;
}

// Service definition for customer operations
service CustomerService {
  // Get a single customer
  rpc GetCustomer(GetCustomerRequest) returns (GetCustomerResponse);
  
  // List customers with pagination
  rpc ListCustomers(ListCustomersRequest) returns (ListCustomersResponse);
  
  // Create a new customer
  rpc CreateCustomer(CreateCustomerRequest) returns (CreateCustomerResponse);
  
  // Update existing customer
  rpc UpdateCustomer(UpdateCustomerRequest) returns (UpdateCustomerResponse);
}

// Request/Response messages for service methods
message GetCustomerRequest {
  int64 id = 1;
}

message GetCustomerResponse {
  Customer customer = 1;
}

message ListCustomersRequest {
  int32 page_size = 1;   // Max 100
  string page_token = 2; // For pagination
  string filter = 3;     // SQL-like filter
}

message ListCustomersResponse {
  repeated Customer customers = 1;
  string next_page_token = 2;
  int32 total_count = 3;
}

message CreateCustomerRequest {
  Customer customer = 1;
}

message CreateCustomerResponse {
  Customer customer = 1;
}

message UpdateCustomerRequest {
  Customer customer = 1;
  // Field mask for partial updates (advanced topic)
}

message UpdateCustomerResponse {
  Customer customer = 1;
}
```

### Step 2: Configure Buf for Code Generation
Create `buf.gen.yaml` in your root directory:

```yaml
version: v1
plugins:
  # Generate Go structs and serialization code
  - plugin: buf.build/protocolbuffers/go
    out: pkg/proto
    opt: paths=source_relative
  
  # Generate Go gRPC service code
  - plugin: buf.build/grpc/go
    out: pkg/proto
    opt: paths=source_relative
```

### Step 3: Generate Go Code
```bash
# From your workshop root directory
buf generate api/customer/v1

# Check what was generated
ls -la pkg/proto/customer/v1/
# Should see: customer.pb.go and customer_grpc.pb.go
```

### Step 4: Update Your Service to Use Protobuf
Update `internal/customer/service.go`:

```go
package customer

import (
	"context"
	"fmt"
	"time"

	customerv1 "example.com/chinook/data-pipeline/pkg/proto/customer/v1"
	"google.golang.org/protobuf/types/known/timestamppb"
)

// Service handles customer operations using protobuf
type Service struct {
	// We'll add database connection later
}

// NewService creates a new customer service
func NewService() *Service {
	return &Service{}
}

// GetCustomer retrieves a customer by ID
func (s *Service) GetCustomer(ctx context.Context, req *customerv1.GetCustomerRequest) (*customerv1.GetCustomerResponse, error) {
	if req.Id <= 0 {
		return nil, fmt.Errorf("invalid customer ID: %d", req.Id)
	}
	
	// Create a dummy customer with full protobuf structure
	now := timestamppb.New(time.Now())
	customer := &customerv1.Customer{
		Id:     req.Id,
		Name:   "John Doe",
		Email:  "john@chinook.com",
		Status: customerv1.CustomerStatus_CUSTOMER_STATUS_ACTIVE,
		CreatedAt: now,
		UpdatedAt: now,
		Contact: &customerv1.ContactInfo{
			Phone:  "+1-555-123-4567",
			Mobile: "+1-555-987-6543",
		},
		Addresses: []*customerv1.Address{
			{
				Street:  "123 Main St",
				City:    "Anytown",
				State:   "CA",
				ZipCode: "12345",
				Country: "USA",
				Type:    customerv1.AddressType_ADDRESS_TYPE_HOME,
			},
		},
		Metadata: map[string]string{
			"signup_source": "website",
			"tier":         "premium",
		},
	}
	
	return &customerv1.GetCustomerResponse{
		Customer: customer,
	}, nil
}

// ListCustomers returns customers with pagination
func (s *Service) ListCustomers(ctx context.Context, req *customerv1.ListCustomersRequest) (*customerv1.ListCustomersResponse, error) {
	// Default page size
	pageSize := req.PageSize
	if pageSize <= 0 || pageSize > 100 {
		pageSize = 10
	}
	
	// Create dummy customers
	customers := make([]*customerv1.Customer, 0, pageSize)
	for i := int32(1); i <= pageSize; i++ {
		customers = append(customers, &customerv1.Customer{
			Id:    int64(i),
			Name:  fmt.Sprintf("Customer %d", i),
			Email: fmt.Sprintf("customer%d@chinook.com", i),
			Status: customerv1.CustomerStatus_CUSTOMER_STATUS_ACTIVE,
		})
	}
	
	return &customerv1.ListCustomersResponse{
		Customers:     customers,
		NextPageToken: "next_page_123", // Dummy pagination token
		TotalCount:    100,             // Dummy total
	}, nil
}
```

### Step 5: Update Your Main Application
Update `cmd/producer/main.go`:

```go
package main

import (
	"context"
	"fmt"
	"log"

	"example.com/chinook/data-pipeline/internal/customer"
	customerv1 "github.com/robconery/bigpipe/pkg/proto"
	"google.golang.org/protobuf/encoding/protojson"
)

func main() {
	fmt.Println("üè≠ Chinook Data Producer with Protobuf!")

	customerSvc := customer.NewService()
	ctx := context.Background()

	// Test GetCustomer
	getReq := &customerv1.GetCustomerRequest{Id: 1}
	getResp, err := customerSvc.GetCustomer(ctx, getReq)
	if err != nil {
		log.Fatalf("Failed to get customer: %v", err)
	}

	fmt.Printf("Retrieved customer: %s\n", getResp.Customer.Name)
	
	// Pretty print the protobuf as JSON
	jsonBytes, _ := protojson.Marshal(getResp.Customer)
	fmt.Printf("Customer JSON:\n%s\n", string(jsonBytes))

	// Test ListCustomers
	listReq := &customerv1.ListCustomersRequest{
		PageSize: 5,
		Filter:   "status=active",
	}
	listResp, err := customerSvc.ListCustomers(ctx, listReq)
	if err != nil {
		log.Fatalf("Failed to list customers: %v", err)
	}

	fmt.Printf("\nüìã Found %d customers (total: %d)\n", 
		len(listResp.Customers), listResp.TotalCount)
	
	for _, c := range listResp.Customers {
		fmt.Printf("  - %s (%s) - Status: %s\n", 
			c.Name, c.Email, c.Status.String())
	}

	fmt.Println("\n‚úÖ Protobuf integration successful!")
}
```

### Step 6: Test Your Protobuf Integration
```bash
# Install required dependencies
go mod tidy

# Run your updated application
go run cmd/producer/main.go

# You should see JSON output of your protobuf message!
```

## üí• Deliberate Failure: Schema Evolution

Let's learn about breaking changes!

### Break It:
1. Try changing `int64 id = 1` to `string id = 1` in your proto
2. Regenerate code with `buf generate`
3. Try to compile - what happens?

### Fix It:
Schema evolution rules:
- ‚úÖ Add new fields (always use new field numbers)
- ‚úÖ Mark fields as deprecated
- ‚ùå Change field types
- ‚ùå Reuse field numbers

## üîç Further Exploration

1. **Add field validation** using buf validate plugin
2. **Create a new message version** (customer/v2) with additional fields
3. **Experiment with oneof fields** for polymorphic data
4. **Add custom options** to your messages

## ‚úÖ Victory Conditions

- [ ] Proto file compiles without errors
- [ ] Go code generates successfully
- [ ] Application runs and displays protobuf data
- [ ] You understand field numbering rules
- [ ] You can serialize/deserialize protobuf messages

## üö® Common Issues & Solutions

**Issue**: "option go_package" errors
**Solution**: Make sure the path matches your actual module structure

**Issue**: Import errors after generation
**Solution**: Run `go mod tidy` to download protobuf dependencies

**Issue**: Field number conflicts
**Solution**: Always use unique field numbers, never reuse them

---

**Next**: Set up Buf configuration and workflows! üîß