# Lab 3: â˜¸ï¸ Kubernetes Deployment

Deploy your containerized pipeline to Kubernetes! Master Helm charts, auto-scaling, service discovery, and production-grade deployments.

## ðŸŽ¯ Objectives
- Deploy pipeline to Kubernetes with Helm
- Configure auto-scaling and resource management
- Implement service discovery and networking
- Set up monitoring and observability

## â˜¸ï¸ Kubernetes Implementation

### 1. Helm Chart Structure
```bash
# Create Helm chart
mkdir -p helm/big-machine-pipeline
cd helm/big-machine-pipeline

# Chart structure
helm/
â””â”€â”€ big-machine-pipeline/
    â”œâ”€â”€ Chart.yaml
    â”œâ”€â”€ values.yaml
    â”œâ”€â”€ templates/
    â”‚   â”œâ”€â”€ deployment.yaml
    â”‚   â”œâ”€â”€ service.yaml
    â”‚   â”œâ”€â”€ configmap.yaml
    â”‚   â”œâ”€â”€ secret.yaml
    â”‚   â”œâ”€â”€ hpa.yaml
    â”‚   â”œâ”€â”€ ingress.yaml
    â”‚   â””â”€â”€ serviceaccount.yaml
    â””â”€â”€ charts/
```

### 2. Chart Configuration (`helm/big-machine-pipeline/Chart.yaml`)
```yaml
apiVersion: v2
name: big-machine-pipeline
description: A Helm chart for Chinook data pipeline
type: application
version: 0.1.0
appVersion: "1.0.0"
keywords:
  - data-pipeline
  - protobuf
  - s3
  - streaming
home: https://github.com/your-org/big-machine-pipeline
sources:
  - https://github.com/your-org/big-machine-pipeline
maintainers:
  - name: Your Name
    email: you@example.com
dependencies:
  - name: postgresql
    version: "12.1.5"
    repository: "https://charts.bitnami.com/bitnami"
    condition: postgresql.enabled
```

### 3. Values Configuration (`helm/big-machine-pipeline/values.yaml`)
```yaml
# Default values for big-machine-pipeline
replicaCount: 2

image:
  repository: your-registry.com/big-machine-pipeline
  pullPolicy: Always
  tag: "latest"

imagePullSecrets: []
nameOverride: ""
fullnameOverride: ""

serviceAccount:
  create: true
  annotations: {}
  name: ""

podAnnotations: {}

podSecurityContext:
  runAsNonRoot: true
  runAsUser: 65534
  fsGroup: 65534

securityContext:
  allowPrivilegeEscalation: false
  capabilities:
    drop:
    - ALL
  readOnlyRootFilesystem: true
  runAsNonRoot: true
  runAsUser: 65534

service:
  type: ClusterIP
  port: 8080
  targetPort: 8080
  metricsPort: 8081

ingress:
  enabled: false
  className: ""
  annotations: {}
  hosts:
    - host: pipeline.local
      paths:
        - path: /
          pathType: Prefix
  tls: []

resources:
  limits:
    cpu: 1000m
    memory: 512Mi
  requests:
    cpu: 500m
    memory: 256Mi

autoscaling:
  enabled: true
  minReplicas: 2
  maxReplicas: 10
  targetCPUUtilizationPercentage: 70
  targetMemoryUtilizationPercentage: 80

nodeSelector: {}

tolerations: []

affinity:
  podAntiAffinity:
    preferredDuringSchedulingIgnoredDuringExecution:
    - weight: 100
      podAffinityTerm:
        labelSelector:
          matchExpressions:
          - key: app.kubernetes.io/name
            operator: In
            values:
            - big-machine-pipeline
        topologyKey: kubernetes.io/hostname

# Pipeline configuration
config:
  batchSize: 100
  pollInterval: "30s"
  healthPort: 8080
  logLevel: "info"

# Database configuration
database:
  host: ""
  port: 5432
  name: chinook
  user: pipeline
  password: ""
  sslMode: require

# S3 configuration
s3:
  bucket: ""
  region: us-west-2
  prefix: customer-data

# AWS credentials (use external secrets in production)
aws:
  accessKeyId: ""
  secretAccessKey: ""

# PostgreSQL subchart configuration
postgresql:
  enabled: true
  auth:
    username: pipeline
    password: pipeline123
    database: chinook
  primary:
    persistence:
      enabled: true
      size: 10Gi
```

### 4. Deployment Template (`helm/big-machine-pipeline/templates/deployment.yaml`)
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: {{ include "big-machine-pipeline.fullname" . }}
  labels:
    {{- include "big-machine-pipeline.labels" . | nindent 4 }}
spec:
  {{- if not .Values.autoscaling.enabled }}
  replicas: {{ .Values.replicaCount }}
  {{- end }}
  selector:
    matchLabels:
      {{- include "big-machine-pipeline.selectorLabels" . | nindent 6 }}
  template:
    metadata:
      annotations:
        checksum/config: {{ include (print $.Template.BasePath "/configmap.yaml") . | sha256sum }}
        checksum/secret: {{ include (print $.Template.BasePath "/secret.yaml") . | sha256sum }}
        {{- with .Values.podAnnotations }}
        {{- toYaml . | nindent 8 }}
        {{- end }}
      labels:
        {{- include "big-machine-pipeline.selectorLabels" . | nindent 8 }}
    spec:
      {{- with .Values.imagePullSecrets }}
      imagePullSecrets:
        {{- toYaml . | nindent 8 }}
      {{- end }}
      serviceAccountName: {{ include "big-machine-pipeline.serviceAccountName" . }}
      securityContext:
        {{- toYaml .Values.podSecurityContext | nindent 8 }}
      containers:
        - name: {{ .Chart.Name }}
          securityContext:
            {{- toYaml .Values.securityContext | nindent 12 }}
          image: "{{ .Values.image.repository }}:{{ .Values.image.tag | default .Chart.AppVersion }}"
          imagePullPolicy: {{ .Values.image.pullPolicy }}
          args:
            - "-config=/etc/config/config.json"
          ports:
            - name: http
              containerPort: {{ .Values.service.targetPort }}
              protocol: TCP
            - name: metrics
              containerPort: {{ .Values.service.metricsPort }}
              protocol: TCP
          livenessProbe:
            httpGet:
              path: /health
              port: http
            initialDelaySeconds: 30
            periodSeconds: 10
            timeoutSeconds: 5
            failureThreshold: 3
          readinessProbe:
            httpGet:
              path: /ready
              port: http
            initialDelaySeconds: 10
            periodSeconds: 5
            timeoutSeconds: 3
            failureThreshold: 2
          resources:
            {{- toYaml .Values.resources | nindent 12 }}
          env:
            - name: DATABASE_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: {{ include "big-machine-pipeline.fullname" . }}
                  key: database-password
            - name: AWS_ACCESS_KEY_ID
              valueFrom:
                secretKeyRef:
                  name: {{ include "big-machine-pipeline.fullname" . }}
                  key: aws-access-key-id
            - name: AWS_SECRET_ACCESS_KEY
              valueFrom:
                secretKeyRef:
                  name: {{ include "big-machine-pipeline.fullname" . }}
                  key: aws-secret-access-key
          volumeMounts:
            - name: config
              mountPath: /etc/config
              readOnly: true
            - name: tmp
              mountPath: /tmp
      volumes:
        - name: config
          configMap:
            name: {{ include "big-machine-pipeline.fullname" . }}
        - name: tmp
          emptyDir: {}
      {{- with .Values.nodeSelector }}
      nodeSelector:
        {{- toYaml . | nindent 8 }}
      {{- end }}
      {{- with .Values.affinity }}
      affinity:
        {{- toYaml . | nindent 8 }}
      {{- end }}
      {{- with .Values.tolerations }}
      tolerations:
        {{- toYaml . | nindent 8 }}
      {{- end }}
```

### 5. Service Template (`helm/big-machine-pipeline/templates/service.yaml`)
```yaml
apiVersion: v1
kind: Service
metadata:
  name: {{ include "big-machine-pipeline.fullname" . }}
  labels:
    {{- include "big-machine-pipeline.labels" . | nindent 4 }}
spec:
  type: {{ .Values.service.type }}
  ports:
    - port: {{ .Values.service.port }}
      targetPort: http
      protocol: TCP
      name: http
    - port: {{ .Values.service.metricsPort }}
      targetPort: metrics
      protocol: TCP
      name: metrics
  selector:
    {{- include "big-machine-pipeline.selectorLabels" . | nindent 4 }}
```

### 6. ConfigMap Template (`helm/big-machine-pipeline/templates/configmap.yaml`)
```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ include "big-machine-pipeline.fullname" . }}
  labels:
    {{- include "big-machine-pipeline.labels" . | nindent 4 }}
data:
  config.json: |
    {
      "DatabaseURL": "postgres://{{ .Values.database.user }}:${DATABASE_PASSWORD}@{{ .Values.database.host | default (printf "%s-postgresql" (include "big-machine-pipeline.fullname" .)) }}:{{ .Values.database.port }}/{{ .Values.database.name }}?sslmode={{ .Values.database.sslMode }}",
      "S3Bucket": "{{ .Values.s3.bucket }}",
      "S3Region": "{{ .Values.s3.region }}",
      "S3Prefix": "{{ .Values.s3.prefix }}",
      "BatchSize": {{ .Values.config.batchSize }},
      "PollInterval": "{{ .Values.config.pollInterval }}",
      "HealthPort": {{ .Values.config.healthPort }},
      "LogLevel": "{{ .Values.config.logLevel }}"
    }
```

### 7. Secret Template (`helm/big-machine-pipeline/templates/secret.yaml`)
```yaml
apiVersion: v1
kind: Secret
metadata:
  name: {{ include "big-machine-pipeline.fullname" . }}
  labels:
    {{- include "big-machine-pipeline.labels" . | nindent 4 }}
type: Opaque
data:
  database-password: {{ .Values.database.password | default (include "postgresql.auth.password" .Subcharts.postgresql) | b64enc | quote }}
  aws-access-key-id: {{ .Values.aws.accessKeyId | b64enc | quote }}
  aws-secret-access-key: {{ .Values.aws.secretAccessKey | b64enc | quote }}
```

### 8. Horizontal Pod Autoscaler (`helm/big-machine-pipeline/templates/hpa.yaml`)
```yaml
{{- if .Values.autoscaling.enabled }}
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: {{ include "big-machine-pipeline.fullname" . }}
  labels:
    {{- include "big-machine-pipeline.labels" . | nindent 4 }}
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: {{ include "big-machine-pipeline.fullname" . }}
  minReplicas: {{ .Values.autoscaling.minReplicas }}
  maxReplicas: {{ .Values.autoscaling.maxReplicas }}
  metrics:
    {{- if .Values.autoscaling.targetCPUUtilizationPercentage }}
    - type: Resource
      resource:
        name: cpu
        target:
          type: Utilization
          averageUtilization: {{ .Values.autoscaling.targetCPUUtilizationPercentage }}
    {{- end }}
    {{- if .Values.autoscaling.targetMemoryUtilizationPercentage }}
    - type: Resource
      resource:
        name: memory
        target:
          type: Utilization
          averageUtilization: {{ .Values.autoscaling.targetMemoryUtilizationPercentage }}
    {{- end }}
{{- end }}
```

### 9. Helper Template (`helm/big-machine-pipeline/templates/_helpers.tpl`)
```yaml
{{/*
Expand the name of the chart.
*/}}
{{- define "big-machine-pipeline.name" -}}
{{- default .Chart.Name .Values.nameOverride | trunc 63 | trimSuffix "-" }}
{{- end }}

{{/*
Create a default fully qualified app name.
*/}}
{{- define "big-machine-pipeline.fullname" -}}
{{- if .Values.fullnameOverride }}
{{- .Values.fullnameOverride | trunc 63 | trimSuffix "-" }}
{{- else }}
{{- $name := default .Chart.Name .Values.nameOverride }}
{{- if contains $name .Release.Name }}
{{- .Release.Name | trunc 63 | trimSuffix "-" }}
{{- else }}
{{- printf "%s-%s" .Release.Name $name | trunc 63 | trimSuffix "-" }}
{{- end }}
{{- end }}
{{- end }}

{{/*
Create chart name and version as used by the chart label.
*/}}
{{- define "big-machine-pipeline.chart" -}}
{{- printf "%s-%s" .Chart.Name .Chart.Version | replace "+" "_" | trunc 63 | trimSuffix "-" }}
{{- end }}

{{/*
Common labels
*/}}
{{- define "big-machine-pipeline.labels" -}}
helm.sh/chart: {{ include "big-machine-pipeline.chart" . }}
{{ include "big-machine-pipeline.selectorLabels" . }}
{{- if .Chart.AppVersion }}
app.kubernetes.io/version: {{ .Chart.AppVersion | quote }}
{{- end }}
app.kubernetes.io/managed-by: {{ .Release.Service }}
{{- end }}

{{/*
Selector labels
*/}}
{{- define "big-machine-pipeline.selectorLabels" -}}
app.kubernetes.io/name: {{ include "big-machine-pipeline.name" . }}
app.kubernetes.io/instance: {{ .Release.Name }}
{{- end }}

{{/*
Create the name of the service account to use
*/}}
{{- define "big-machine-pipeline.serviceAccountName" -}}
{{- if .Values.serviceAccount.create }}
{{- default (include "big-machine-pipeline.fullname" .) .Values.serviceAccount.name }}
{{- else }}
{{- default "default" .Values.serviceAccount.name }}
{{- end }}
{{- end }}
```

## ðŸš€ Deployment Scripts

### 1. Deployment Script (`scripts/k8s-deploy.sh`)
```bash
#!/bin/bash

set -e

NAMESPACE=${1:-default}
RELEASE_NAME=${2:-big-machine-pipeline}
VALUES_FILE=${3:-values.yaml}

echo "ðŸš€ Deploying Chinook Pipeline to Kubernetes"
echo "Namespace: $NAMESPACE"
echo "Release: $RELEASE_NAME"
echo "Values: $VALUES_FILE"

# Create namespace if it doesn't exist
kubectl create namespace "$NAMESPACE" --dry-run=client -o yaml | kubectl apply -f -

# Add Bitnami repository for PostgreSQL
helm repo add bitnami https://charts.bitnami.com/bitnami
helm repo update

# Install or upgrade the release
helm upgrade --install "$RELEASE_NAME" ./helm/big-machine-pipeline \
    --namespace "$NAMESPACE" \
    --values "$VALUES_FILE" \
    --wait \
    --timeout=300s

echo "âœ… Deployment complete!"

# Show deployment status
echo "ðŸ“Š Deployment Status:"
kubectl get pods,svc,hpa -n "$NAMESPACE" -l app.kubernetes.io/name=big-machine-pipeline

# Show external access information
echo "ðŸŒ Access Information:"
kubectl get ingress -n "$NAMESPACE" 2>/dev/null || echo "No ingress configured"

echo "ðŸ”— Port Forward Commands:"
echo "Health: kubectl port-forward -n $NAMESPACE svc/$RELEASE_NAME 8080:8080"
echo "Metrics: kubectl port-forward -n $NAMESPACE svc/$RELEASE_NAME 8081:8081"
```

### 2. Production Values (`values.prod.yaml`)
```yaml
replicaCount: 5

image:
  repository: your-registry.com/big-machine-pipeline
  tag: "v1.0.0"
  pullPolicy: IfNotPresent

resources:
  limits:
    cpu: 2000m
    memory: 1Gi
  requests:
    cpu: 1000m
    memory: 512Mi

autoscaling:
  enabled: true
  minReplicas: 5
  maxReplicas: 20
  targetCPUUtilizationPercentage: 60
  targetMemoryUtilizationPercentage: 70

ingress:
  enabled: true
  className: "nginx"
  annotations:
    cert-manager.io/cluster-issuer: "letsencrypt-prod"
    nginx.ingress.kubernetes.io/rate-limit: "100"
    nginx.ingress.kubernetes.io/ssl-redirect: "true"
  hosts:
    - host: pipeline.chinook.com
      paths:
        - path: /
          pathType: Prefix
  tls:
    - secretName: pipeline-tls
      hosts:
        - pipeline.chinook.com

config:
  batchSize: 500
  pollInterval: "10s"
  logLevel: "warn"

database:
  host: "postgres.database.com"
  sslMode: "require"

s3:
  bucket: "big-machine-production-data"
  region: "us-east-1"

postgresql:
  enabled: false  # Use external database in production

nodeSelector:
  nodeType: "worker"

tolerations:
  - key: "dedicated"
    operator: "Equal"
    value: "pipeline"
    effect: "NoSchedule"

affinity:
  nodeAffinity:
    requiredDuringSchedulingIgnoredDuringExecution:
      nodeSelectorTerms:
      - matchExpressions:
        - key: kubernetes.io/arch
          operator: In
          values:
          - amd64
```

### 3. Monitoring Setup (`monitoring/servicemonitor.yaml`)
```yaml
apiVersion: monitoring.coreos.com/v1
kind: ServiceMonitor
metadata:
  name: big-machine-pipeline
  labels:
    app.kubernetes.io/name: big-machine-pipeline
spec:
  selector:
    matchLabels:
      app.kubernetes.io/name: big-machine-pipeline
  endpoints:
  - port: metrics
    path: /metrics
    interval: 30s
    scrapeTimeout: 10s
```

### 4. Grafana Dashboard (`monitoring/dashboard.json`)
```json
{
  "dashboard": {
    "id": null,
    "title": "Chinook Pipeline",
    "description": "Monitoring dashboard for Chinook data pipeline",
    "tags": ["pipeline", "protobuf", "s3"],
    "timezone": "browser",
    "panels": [
      {
        "id": 1,
        "title": "Customers Processed",
        "type": "stat",
        "targets": [
          {
            "expr": "rate(pipeline_customers_processed_total[5m])",
            "legendFormat": "Customers/sec"
          }
        ],
        "fieldConfig": {
          "defaults": {
            "unit": "reqps"
          }
        }
      },
      {
        "id": 2,
        "title": "Data Transfer Rate",
        "type": "stat",
        "targets": [
          {
            "expr": "rate(pipeline_bytes_uploaded_total[5m])",
            "legendFormat": "Bytes/sec"
          }
        ],
        "fieldConfig": {
          "defaults": {
            "unit": "binBps"
          }
        }
      },
      {
        "id": 3,
        "title": "Error Rate",
        "type": "stat",
        "targets": [
          {
            "expr": "rate(pipeline_errors_total[5m])",
            "legendFormat": "Errors/sec"
          }
        ],
        "fieldConfig": {
          "defaults": {
            "unit": "reqps",
            "color": {
              "mode": "thresholds"
            },
            "thresholds": {
              "steps": [
                {"color": "green", "value": null},
                {"color": "yellow", "value": 0.1},
                {"color": "red", "value": 1}
              ]
            }
          }
        }
      }
    ],
    "time": {
      "from": "now-1h",
      "to": "now"
    },
    "refresh": "5s"
  }
}
```

## ðŸ§ª Testing & Verification

### 1. Deploy to Local Kubernetes
```bash
# Start local cluster (minikube/kind)
minikube start

# Build and load image
docker build -t big-machine-pipeline:latest .
minikube image load big-machine-pipeline:latest

# Deploy with Helm
./scripts/k8s-deploy.sh default pipeline-dev values.yaml

# Test access
kubectl port-forward svc/pipeline-dev 8080:8080 &
curl http://localhost:8080/health
```

### 2. Load Testing
```bash
# Install hey for load testing
go install github.com/rakyll/hey@latest

# Test health endpoint
hey -n 1000 -c 10 http://localhost:8080/health

# Test metrics endpoint  
hey -n 500 -c 5 http://localhost:8081/metrics
```

### 3. Auto-scaling Test
```bash
# Generate load to trigger HPA
kubectl run -i --tty load-generator --rm --image=busybox --restart=Never -- /bin/sh
# Inside the pod:
while true; do wget -q -O- http://pipeline-dev:8080/health; done

# Watch HPA scaling
kubectl get hpa -w
```

### 4. Rolling Update Test
```bash
# Update image version
helm upgrade pipeline-dev ./helm/big-machine-pipeline \
    --set image.tag=v1.1.0 \
    --namespace default

# Watch rollout
kubectl rollout status deployment/pipeline-dev
kubectl rollout history deployment/pipeline-dev
```

## âœ… Victory Conditions

- [ ] Helm chart deploys successfully to Kubernetes
- [ ] Auto-scaling responds to CPU/memory load
- [ ] Health checks and readiness probes work correctly
- [ ] Rolling updates deploy without downtime
- [ ] Service discovery enables pod-to-pod communication
- [ ] Monitoring metrics are collected by Prometheus
- [ ] Ingress provides external access (if configured)

## ðŸ”„ Advanced Topics

### 1. Blue-Green Deployment
```bash
# Deploy blue version
helm install pipeline-blue ./helm/big-machine-pipeline \
    --set image.tag=v1.0.0

# Deploy green version
helm install pipeline-green ./helm/big-machine-pipeline \
    --set image.tag=v1.1.0

# Switch traffic (update ingress)
kubectl patch ingress pipeline-ingress -p '{"spec":{"rules":[{"host":"pipeline.com","http":{"paths":[{"path":"/","backend":{"service":{"name":"pipeline-green","port":{"number":8080}}}}]}}]}}'
```

### 2. Network Policies
```yaml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: pipeline-network-policy
spec:
  podSelector:
    matchLabels:
      app.kubernetes.io/name: big-machine-pipeline
  policyTypes:
  - Ingress
  - Egress
  ingress:
  - from:
    - podSelector:
        matchLabels:
          app: ingress-nginx
  egress:
  - to:
    - podSelector:
        matchLabels:
          app.kubernetes.io/name: postgresql
  - to: []
    ports:
    - protocol: TCP
      port: 443  # HTTPS to S3
```

---

**Next**: Head to `lab04/` for production observability! ðŸ“Š
