# Lab 1: ðŸ”„ Schema Evolution Simulator

Welcome to Schema Evolution Bootcamp! You'll start with a simple schema and evolve it through multiple versions, experiencing both success and spectacular failures along the way! ðŸ’¥

## ðŸŽ¯ Objectives
- Experience safe schema evolution patterns
- Learn to handle breaking changes gracefully
- Understand field number management
- Master deprecation strategies

## ðŸ› ï¸ Tasks

### Step 1: Create the Original Schema (v1)
Create `api/customer/v1/customer_v1.proto`:

```protobuf
syntax = "proto3";

package customer.v1;

option go_package = "example.com/chinook/data-pipeline/pkg/proto/customer/v1;customerv1";

import "google/protobuf/timestamp.proto";

// Customer v1 - Our humble beginning
message Customer {
  int64 id = 1;
  string name = 2;
  string email = 3;
  CustomerStatus status = 4;
  google.protobuf.Timestamp created_at = 5;
}

enum CustomerStatus {
  CUSTOMER_STATUS_UNSPECIFIED = 0;
  CUSTOMER_STATUS_ACTIVE = 1;
  CUSTOMER_STATUS_INACTIVE = 2;
}

service CustomerService {
  rpc GetCustomer(GetCustomerRequest) returns (GetCustomerResponse);
  rpc CreateCustomer(CreateCustomerRequest) returns (CreateCustomerResponse);
}

message GetCustomerRequest {
  int64 id = 1;
}

message GetCustomerResponse {
  Customer customer = 1;
}

message CreateCustomerRequest {
  Customer customer = 1;
}

message CreateCustomerResponse {
  Customer customer = 1;
}
```

### Step 2: Generate v1 Code and Test
```bash
# Generate v1 code
buf generate api/customer/v1

# Create a simple v1 test
mkdir -p cmd/schema-evolution
```

Create `cmd/schema-evolution/main.go`:

```go
package main

import (
	"fmt"
	"time"

	customerv1 "example.com/chinook/data-pipeline/pkg/proto/customer/v1"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/types/known/timestamppb"
)

func main() {
	fmt.Println("ðŸ”„ Schema Evolution Laboratory")
	fmt.Println("=============================")

	// Create a v1 customer
	v1Customer := &customerv1.Customer{
		Id:     1,
		Name:   "Alice Smith",
		Email:  "alice@chinook.com",
		Status: customerv1.CustomerStatus_CUSTOMER_STATUS_ACTIVE,
		CreatedAt: timestamppb.New(time.Now()),
	}

	// Serialize v1 customer
	v1Data, err := proto.Marshal(v1Customer)
	if err != nil {
		panic(err)
	}

	fmt.Printf("âœ… v1 Customer created and serialized (%d bytes)\n", len(v1Data))
	fmt.Printf("   Name: %s, Email: %s\n", v1Customer.Name, v1Customer.Email)

	// Test v1 -> v1 deserialization
	var deserializedV1 customerv1.Customer
	if err := proto.Unmarshal(v1Data, &deserializedV1); err != nil {
		panic(err)
	}

	fmt.Printf("âœ… v1 -> v1 deserialization successful\n")
	fmt.Printf("   Roundtrip preserved: Name=%s, Email=%s\n", 
		deserializedV1.Name, deserializedV1.Email)
}
```

Run the v1 test:
```bash
go run cmd/schema-evolution/main.go
```

### Step 3: Evolve to v2 (Safe Changes)
Create `api/customer/v2/customer_v2.proto`:

```protobuf
syntax = "proto3";

package customer.v2;

option go_package = "example.com/chinook/data-pipeline/pkg/proto/customer/v2;customerv2";

import "google/protobuf/timestamp.proto";

// Customer v2 - Adding new fields (SAFE evolution)
message Customer {
  int64 id = 1;
  string name = 2;
  string email = 3;
  CustomerStatus status = 4;
  google.protobuf.Timestamp created_at = 5;
  
  // NEW FIELDS - Safe to add!
  string phone = 6;                              // New simple field
  repeated Address addresses = 7;                // New repeated field
  ContactPreferences preferences = 8;            // New nested message
  google.protobuf.Timestamp updated_at = 9;     // New timestamp
  map<string, string> metadata = 10;            // New map field
}

// New enum with additional values
enum CustomerStatus {
  CUSTOMER_STATUS_UNSPECIFIED = 0;
  CUSTOMER_STATUS_ACTIVE = 1;
  CUSTOMER_STATUS_INACTIVE = 2;
  CUSTOMER_STATUS_SUSPENDED = 3;                 // NEW VALUE - Safe!
  CUSTOMER_STATUS_PENDING = 4;                   // NEW VALUE - Safe!
}

// New nested message
message Address {
  string street = 1;
  string city = 2;
  string state = 3;
  string zip_code = 4;
  string country = 5;
  AddressType type = 6;
}

enum AddressType {
  ADDRESS_TYPE_UNSPECIFIED = 0;
  ADDRESS_TYPE_HOME = 1;
  ADDRESS_TYPE_WORK = 2;
  ADDRESS_TYPE_BILLING = 3;
}

// New preferences message
message ContactPreferences {
  bool email_notifications = 1;
  bool sms_notifications = 2;
  bool phone_calls = 3;
  string preferred_language = 4;
}

// Service remains compatible (only additions)
service CustomerService {
  rpc GetCustomer(GetCustomerRequest) returns (GetCustomerResponse);
  rpc CreateCustomer(CreateCustomerRequest) returns (CreateCustomerResponse);
  
  // NEW METHODS - Safe to add!
  rpc UpdateCustomer(UpdateCustomerRequest) returns (UpdateCustomerResponse);
  rpc ListCustomers(ListCustomersRequest) returns (ListCustomersResponse);
}

// Existing messages remain the same (backwards compatible)
message GetCustomerRequest {
  int64 id = 1;
}

message GetCustomerResponse {
  Customer customer = 1;
}

message CreateCustomerRequest {
  Customer customer = 1;
}

message CreateCustomerResponse {
  Customer customer = 1;
}

// New request/response messages
message UpdateCustomerRequest {
  Customer customer = 1;
}

message UpdateCustomerResponse {
  Customer customer = 1;
}

message ListCustomersRequest {
  int32 page_size = 1;
  string page_token = 2;
}

message ListCustomersResponse {
  repeated Customer customers = 1;
  string next_page_token = 2;
}
```

### Step 4: Generate v2 Code and Test Compatibility
```bash
# Generate v2 code
buf generate api/customer/v2
```

Update `cmd/schema-evolution/main.go` to test compatibility:

```go
package main

import (
	"fmt"
	"time"

	customerv1 "example.com/chinook/data-pipeline/pkg/proto/customer/v1"
	customerv2 "example.com/chinook/data-pipeline/pkg/proto/customer/v2"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/types/known/timestamppb"
)

func main() {
	fmt.Println("ðŸ”„ Schema Evolution Laboratory")
	fmt.Println("=============================")

	testV1ToV1()
	testV2ToV2()
	testV1ToV2Compatibility()
	testV2ToV1Compatibility()
}

func testV1ToV1() {
	fmt.Println("\nðŸ“‹ Test 1: v1 -> v1 (Baseline)")
	
	v1Customer := &customerv1.Customer{
		Id:     1,
		Name:   "Alice Smith",
		Email:  "alice@chinook.com",
		Status: customerv1.CustomerStatus_CUSTOMER_STATUS_ACTIVE,
		CreatedAt: timestamppb.New(time.Now()),
	}

	data, _ := proto.Marshal(v1Customer)
	
	var deserialized customerv1.Customer
	if err := proto.Unmarshal(data, &deserialized); err != nil {
		fmt.Printf("âŒ FAILED: %v\n", err)
		return
	}

	fmt.Printf("âœ… SUCCESS: v1 customer roundtrip works\n")
	fmt.Printf("   Data: %s (%s)\n", deserialized.Name, deserialized.Email)
}

func testV2ToV2() {
	fmt.Println("\nðŸ“‹ Test 2: v2 -> v2 (New Features)")
	
	v2Customer := &customerv2.Customer{
		Id:     2,
		Name:   "Bob Johnson",
		Email:  "bob@chinook.com",
		Status: customerv2.CustomerStatus_CUSTOMER_STATUS_ACTIVE,
		CreatedAt: timestamppb.New(time.Now()),
		UpdatedAt: timestamppb.New(time.Now()),
		Phone:  "+1-555-123-4567",
		Addresses: []*customerv2.Address{
			{
				Street:  "123 Main St",
				City:    "San Francisco",
				State:   "CA",
				ZipCode: "94105",
				Country: "USA",
				Type:    customerv2.AddressType_ADDRESS_TYPE_HOME,
			},
		},
		Preferences: &customerv2.ContactPreferences{
			EmailNotifications: true,
			SmsNotifications:   false,
			PreferredLanguage: "en-US",
		},
		Metadata: map[string]string{
			"signup_source": "website",
			"tier":         "premium",
		},
	}

	data, _ := proto.Marshal(v2Customer)
	
	var deserialized customerv2.Customer
	if err := proto.Unmarshal(data, &deserialized); err != nil {
		fmt.Printf("âŒ FAILED: %v\n", err)
		return
	}

	fmt.Printf("âœ… SUCCESS: v2 customer roundtrip works\n")
	fmt.Printf("   Data: %s (%s) Phone: %s\n", 
		deserialized.Name, deserialized.Email, deserialized.Phone)
	fmt.Printf("   Addresses: %d, Metadata: %d items\n", 
		len(deserialized.Addresses), len(deserialized.Metadata))
}

func testV1ToV2Compatibility() {
	fmt.Println("\nðŸ“‹ Test 3: v1 -> v2 (Forward Compatibility)")
	
	// Create v1 customer
	v1Customer := &customerv1.Customer{
		Id:     3,
		Name:   "Charlie Brown",
		Email:  "charlie@chinook.com",
		Status: customerv1.CustomerStatus_CUSTOMER_STATUS_INACTIVE,
		CreatedAt: timestamppb.New(time.Now()),
	}

	// Serialize with v1
	v1Data, _ := proto.Marshal(v1Customer)
	
	// Deserialize with v2 - should work!
	var v2Customer customerv2.Customer
	if err := proto.Unmarshal(v1Data, &v2Customer); err != nil {
		fmt.Printf("âŒ FAILED: %v\n", err)
		return
	}

	fmt.Printf("âœ… SUCCESS: v1 data readable by v2 client\n")
	fmt.Printf("   Core data preserved: %s (%s)\n", v2Customer.Name, v2Customer.Email)
	fmt.Printf("   New fields have defaults: Phone='%s', Addresses=%d\n", 
		v2Customer.Phone, len(v2Customer.Addresses))
}

func testV2ToV1Compatibility() {
	fmt.Println("\nðŸ“‹ Test 4: v2 -> v1 (Backward Compatibility)")
	
	// Create v2 customer with new fields
	v2Customer := &customerv2.Customer{
		Id:     4,
		Name:   "Diana Prince",
		Email:  "diana@chinook.com",
		Status: customerv2.CustomerStatus_CUSTOMER_STATUS_ACTIVE,
		CreatedAt: timestamppb.New(time.Now()),
		UpdatedAt: timestamppb.New(time.Now()),
		Phone:  "+1-555-987-6543",
		Addresses: []*customerv2.Address{
			{
				Street: "456 Hero Ave",
				City:   "Metropolis",
				State:  "NY",
				Type:   customerv2.AddressType_ADDRESS_TYPE_WORK,
			},
		},
		Metadata: map[string]string{
			"superhero": "true",
		},
	}

	// Serialize with v2
	v2Data, _ := proto.Marshal(v2Customer)
	
	// Deserialize with v1 - should work (ignoring new fields)!
	var v1Customer customerv1.Customer
	if err := proto.Unmarshal(v2Data, &v1Customer); err != nil {
		fmt.Printf("âŒ FAILED: %v\n", err)
		return
	}

	fmt.Printf("âœ… SUCCESS: v2 data readable by v1 client\n")
	fmt.Printf("   Core data preserved: %s (%s)\n", v1Customer.Name, v1Customer.Email)
	fmt.Printf("   New fields gracefully ignored by v1 client\n")
}
```

Test the compatibility:
```bash
go run cmd/schema-evolution/main.go
```

### Step 5: Create Breaking Changes (Deliberately!)
Create `api/customer/v3-broken/customer_v3_broken.proto`:

```protobuf
syntax = "proto3";

package customer.v3broken;

option go_package = "example.com/chinook/data-pipeline/pkg/proto/customer/v3broken;customerv3broken";

import "google/protobuf/timestamp.proto";

// Customer v3 BROKEN - Demonstrating what NOT to do!
message Customer {
  string id = 1;                    // âŒ BREAKING: Changed int64 to string!
  string full_name = 2;             // âŒ BREAKING: Renamed 'name' to 'full_name'!
  string email = 3;                 // âœ… OK: Same as before
  CustomerStatus status = 4;        // âŒ BREAKING: Enum values changed!
  google.protobuf.Timestamp created_at = 5;  // âœ… OK: Same as before
  
  // âŒ BREAKING: Reused field number 6!
  string emergency_contact = 6;     // Was 'phone' in v2, now different meaning!
}

// âŒ BREAKING: Changed enum zero value meaning!
enum CustomerStatus {
  CUSTOMER_STATUS_ACTIVE = 0;       // âŒ BREAKING: Zero value changed meaning!
  CUSTOMER_STATUS_INACTIVE = 1;
  CUSTOMER_STATUS_SUSPENDED = 2;
  // âŒ BREAKING: Removed CUSTOMER_STATUS_UNSPECIFIED!
}
```

### Step 6: Test Breaking Changes
```bash
# Generate broken v3 code
buf generate api/customer/v3-broken
```

Add breaking change test to `cmd/schema-evolution/main.go`:

```go
func main() {
    // ... existing tests ...
    
    testBreakingChanges()
}

func testBreakingChanges() {
	fmt.Println("\nðŸ’¥ Test 5: Breaking Changes (What NOT to do!)")
	
	// Create v2 customer
	v2Customer := &customerv2.Customer{
		Id:     123,
		Name:   "Breaking Bad Example",
		Email:  "breaking@example.com",
		Status: customerv2.CustomerStatus_CUSTOMER_STATUS_ACTIVE,
		Phone:  "+1-555-EMERGENCY",
	}

	// Serialize with v2
	v2Data, _ := proto.Marshal(v2Customer)
	
	// Try to deserialize with broken v3
	var v3Customer customerv3broken.Customer
	if err := proto.Unmarshal(v2Data, &v3Customer); err != nil {
		fmt.Printf("âŒ FAILED (as expected): %v\n", err)
		fmt.Println("   This demonstrates why breaking changes are dangerous!")
		return
	}

	// Even if deserialization "succeeds", data is corrupted
	fmt.Printf("âš ï¸  'SUCCESS' but data corrupted:\n")
	fmt.Printf("   ID changed from int64(123) to string('%s')\n", v3Customer.Id)
	fmt.Printf("   Name field lost: '%s' -> '%s'\n", v2Customer.Name, v3Customer.FullName)
	fmt.Printf("   Phone became emergency_contact: '%s' -> '%s'\n", 
		v2Customer.Phone, v3Customer.EmergencyContact)
	fmt.Println("   ðŸ’€ Silent data corruption - the worst kind of bug!")
}
```

### Step 7: Fix Breaking Changes with Proper Evolution
Create `api/customer/v3-fixed/customer_v3_fixed.proto`:

```protobuf
syntax = "proto3";

package customer.v3fixed;

option go_package = "example.com/chinook/data-pipeline/pkg/proto/customer/v3fixed;customerv3fixed";

import "google/protobuf/timestamp.proto";

// Customer v3 FIXED - Proper evolution techniques
message Customer {
  int64 id = 1;                     // âœ… SAFE: Keep original type
  string name = 2;                  // âœ… SAFE: Keep original field
  string email = 3;
  CustomerStatus status = 4;
  google.protobuf.Timestamp created_at = 5;
  
  // Deprecated fields (proper way to phase out)
  string phone = 6 [deprecated = true];  // âœ… SAFE: Mark deprecated, don't remove
  
  // New fields with new field numbers
  string full_name = 11;            // âœ… SAFE: New field number for new concept
  ContactInfo contact_info = 12;    // âœ… SAFE: New structured contact info
  string emergency_contact = 13;    // âœ… SAFE: New field number for new concept
  
  // Reserved numbers to prevent future mistakes
  reserved 7 to 10;                 // âœ… SAFE: Reserve space for future use
  reserved "old_field_name";        // âœ… SAFE: Prevent name reuse
}

// Proper enum evolution
enum CustomerStatus {
  CUSTOMER_STATUS_UNSPECIFIED = 0;  // âœ… SAFE: Keep zero value meaning
  CUSTOMER_STATUS_ACTIVE = 1;
  CUSTOMER_STATUS_INACTIVE = 2;
  CUSTOMER_STATUS_SUSPENDED = 3;
  CUSTOMER_STATUS_ARCHIVED = 4;     // âœ… SAFE: Add new values only
}

// New structured contact info
message ContactInfo {
  string primary_phone = 1;
  string mobile_phone = 2;
  string work_phone = 3;
  string preferred_contact_method = 4;
}
```

## ðŸ’¥ Deliberate Failure: Schema Evolution Disasters

### Break It:
1. Try the v3-broken changes and see data corruption
2. Reuse field numbers and watch silent failures
3. Change enum zero values and see default behavior break

### Fix It:
1. Use the v3-fixed approach with proper deprecation
2. Always use new field numbers for new concepts
3. Never change the meaning of enum zero values

## ðŸ” Further Exploration

1. **Implement field migration utilities** for data transformation
2. **Create schema validation rules** using buf breaking change detection
3. **Build a schema registry** to track all versions
4. **Add compatibility testing** to your CI/CD pipeline

## âœ… Victory Conditions

- [ ] v1 and v2 schemas work correctly
- [ ] Forward compatibility (v1 -> v2) works
- [ ] Backward compatibility (v2 -> v1) works  
- [ ] Breaking changes are identified and avoided
- [ ] Proper deprecation patterns are understood

## ðŸš¨ Common Issues & Solutions

**Issue**: Deserialization fails with "unknown field"
**Solution**: This indicates a breaking change - check field types and numbers

**Issue**: Default values appear unexpectedly
**Solution**: New fields have default values when read by old clients

**Issue**: Data seems corrupted after version change
**Solution**: Field number reuse or type changes - use reserved fields

---

**Next**: Head to `lab02/` to build multi-version API support! ðŸ“±