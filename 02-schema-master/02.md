# Lab 2: 📱 Multi-Version API Support

Time to build a real-world multi-version API! You'll support both v1 and v2 customers simultaneously while maintaining backwards compatibility. This is where schema evolution gets real! 🚀

## 🎯 Objectives
- Support multiple API versions simultaneously
- Build version adapters and converters
- Handle mixed-version deployments
- Implement graceful version migration

## 🛠️ Tasks

### Step 1: Create Version Adapter Interface
Create `internal/customer/adapter.go`:

```go
package customer

import (
	"context"
	"fmt"

	customerv1 "github.com/chinook/data-pipeline/pkg/proto/customer/v1"
	customerv2 "github.com/chinook/data-pipeline/pkg/proto/customer/v2"
)

// VersionAdapter handles conversion between different customer versions
type VersionAdapter interface {
	// Convert v1 to v2
	V1ToV2(v1Customer *customerv1.Customer) (*customerv2.Customer, error)
	
	// Convert v2 to v1 (with potential data loss)
	V2ToV1(v2Customer *customerv2.Customer) (*customerv1.Customer, error)
	
	// Check if v2 customer can be safely downgraded to v1
	CanDowngradeToV1(v2Customer *customerv2.Customer) (bool, []string)
}

// versionAdapter implements VersionAdapter
type versionAdapter struct{}

// NewVersionAdapter creates a new version adapter
func NewVersionAdapter() VersionAdapter {
	return &versionAdapter{}
}

// V1ToV2 converts a v1 customer to v2 (safe - only adds defaults)
func (a *versionAdapter) V1ToV2(v1Customer *customerv1.Customer) (*customerv2.Customer, error) {
	if v1Customer == nil {
		return nil, fmt.Errorf("v1 customer cannot be nil")
	}

	// Map v1 status to v2 status
	var v2Status customerv2.CustomerStatus
	switch v1Customer.Status {
	case customerv1.CustomerStatus_CUSTOMER_STATUS_UNSPECIFIED:
		v2Status = customerv2.CustomerStatus_CUSTOMER_STATUS_UNSPECIFIED
	case customerv1.CustomerStatus_CUSTOMER_STATUS_ACTIVE:
		v2Status = customerv2.CustomerStatus_CUSTOMER_STATUS_ACTIVE
	case customerv1.CustomerStatus_CUSTOMER_STATUS_INACTIVE:
		v2Status = customerv2.CustomerStatus_CUSTOMER_STATUS_INACTIVE
	default:
		return nil, fmt.Errorf("unknown v1 status: %v", v1Customer.Status)
	}

	// Create v2 customer with v1 data plus defaults for new fields
	v2Customer := &customerv2.Customer{
		Id:        v1Customer.Id,
		Name:      v1Customer.Name,
		Email:     v1Customer.Email,
		Status:    v2Status,
		CreatedAt: v1Customer.CreatedAt,
		UpdatedAt: v1Customer.CreatedAt, // Use created_at as updated_at default
		
		// New fields get sensible defaults
		Phone:     "",                    // Empty phone
		Addresses: []*customerv2.Address{}, // Empty address list
		Preferences: &customerv2.ContactPreferences{
			EmailNotifications: true,     // Default to email notifications
			SmsNotifications:   false,    // Default to no SMS
			PhoneCalls:        false,     // Default to no phone calls
			PreferredLanguage: "en-US",   // Default language
		},
		Metadata: make(map[string]string), // Empty metadata
	}

	return v2Customer, nil
}

// V2ToV1 converts a v2 customer to v1 (lossy - drops new fields)
func (a *versionAdapter) V2ToV1(v2Customer *customerv2.Customer) (*customerv1.Customer, error) {
	if v2Customer == nil {
		return nil, fmt.Errorf("v2 customer cannot be nil")
	}

	// Map v2 status to v1 status (with data loss for new statuses)
	var v1Status customerv1.CustomerStatus
	switch v2Customer.Status {
	case customerv2.CustomerStatus_CUSTOMER_STATUS_UNSPECIFIED:
		v1Status = customerv1.CustomerStatus_CUSTOMER_STATUS_UNSPECIFIED
	case customerv2.CustomerStatus_CUSTOMER_STATUS_ACTIVE:
		v1Status = customerv1.CustomerStatus_CUSTOMER_STATUS_ACTIVE
	case customerv2.CustomerStatus_CUSTOMER_STATUS_INACTIVE:
		v1Status = customerv1.CustomerStatus_CUSTOMER_STATUS_INACTIVE
	case customerv2.CustomerStatus_CUSTOMER_STATUS_SUSPENDED:
		// Map new v2 status to closest v1 equivalent
		v1Status = customerv1.CustomerStatus_CUSTOMER_STATUS_INACTIVE
	case customerv2.CustomerStatus_CUSTOMER_STATUS_PENDING:
		// Map new v2 status to closest v1 equivalent
		v1Status = customerv1.CustomerStatus_CUSTOMER_STATUS_INACTIVE
	default:
		return nil, fmt.Errorf("unknown v2 status: %v", v2Customer.Status)
	}

	// Create v1 customer with only v1-compatible fields
	v1Customer := &customerv1.Customer{
		Id:        v2Customer.Id,
		Name:      v2Customer.Name,
		Email:     v2Customer.Email,
		Status:    v1Status,
		CreatedAt: v2Customer.CreatedAt,
		// Note: We lose phone, addresses, preferences, metadata, updated_at
	}

	return v1Customer, nil
}

// CanDowngradeToV1 checks if a v2 customer can be safely downgraded
func (a *versionAdapter) CanDowngradeToV1(v2Customer *customerv2.Customer) (bool, []string) {
	if v2Customer == nil {
		return false, []string{"customer is nil"}
	}

	var warnings []string
	canDowngrade := true

	// Check for data loss scenarios
	if v2Customer.Phone != "" {
		warnings = append(warnings, "phone number will be lost")
	}

	if len(v2Customer.Addresses) > 0 {
		warnings = append(warnings, fmt.Sprintf("%d addresses will be lost", len(v2Customer.Addresses)))
	}

	if len(v2Customer.Metadata) > 0 {
		warnings = append(warnings, fmt.Sprintf("%d metadata entries will be lost", len(v2Customer.Metadata)))
	}

	// Check for status mapping issues
	switch v2Customer.Status {
	case customerv2.CustomerStatus_CUSTOMER_STATUS_SUSPENDED:
		warnings = append(warnings, "SUSPENDED status will become INACTIVE")
	case customerv2.CustomerStatus_CUSTOMER_STATUS_PENDING:
		warnings = append(warnings, "PENDING status will become INACTIVE")
	}

	// Check for non-default preferences
	if v2Customer.Preferences != nil {
		if !v2Customer.Preferences.EmailNotifications {
			warnings = append(warnings, "email notification preference will be lost")
		}
		if v2Customer.Preferences.SmsNotifications {
			warnings = append(warnings, "SMS notification preference will be lost")
		}
		if v2Customer.Preferences.PhoneCalls {
			warnings = append(warnings, "phone call preference will be lost")
		}
		if v2Customer.Preferences.PreferredLanguage != "en-US" {
			warnings = append(warnings, "preferred language will be lost")
		}
	}

	// Determine if downgrade is recommended
	if len(warnings) > 5 {
		canDowngrade = false
		warnings = append(warnings, "too much data would be lost - downgrade not recommended")
	}

	return canDowngrade, warnings
}
```

### Step 2: Create Multi-Version Service
Create `internal/customer/multiversion_service.go`:

```go
package customer

import (
	"context"
	"fmt"

	customerv1 "github.com/chinook/data-pipeline/pkg/proto/customer/v1"
	customerv2 "github.com/chinook/data-pipeline/pkg/proto/customer/v2"
)

// MultiVersionService supports both v1 and v2 APIs
type MultiVersionService struct {
	repo         Repository
	publisher    EventPublisher
	adapter      VersionAdapter
	
	// Internal storage version (we'll use v2 as the "source of truth")
	internalRepo RepositoryV2
}

// RepositoryV2 defines repository interface using v2 models internally
type RepositoryV2 interface {
	GetCustomerV2(ctx context.Context, id int64) (*customerv2.Customer, error)
	ListCustomersV2(ctx context.Context, filter ListFilter) ([]*customerv2.Customer, error)
	CreateCustomerV2(ctx context.Context, customer *customerv2.Customer) (*customerv2.Customer, error)
	UpdateCustomerV2(ctx context.Context, customer *customerv2.Customer) (*customerv2.Customer, error)
	DeleteCustomerV2(ctx context.Context, id int64) error
}

// NewMultiVersionService creates a service that supports both API versions
func NewMultiVersionService(repo RepositoryV2, publisher EventPublisher, adapter VersionAdapter) *MultiVersionService {
	return &MultiVersionService{
		internalRepo: repo,
		publisher:    publisher,
		adapter:      adapter,
	}
}

// === V1 API Methods ===

// GetCustomerV1 implements the v1 GetCustomer API
func (s *MultiVersionService) GetCustomerV1(ctx context.Context, req *customerv1.GetCustomerRequest) (*customerv1.GetCustomerResponse, error) {
	if err := req.Validate(); err != nil {
		return nil, fmt.Errorf("invalid v1 request: %w", err)
	}

	// Get customer in v2 format (internal storage)
	v2Customer, err := s.internalRepo.GetCustomerV2(ctx, req.Id)
	if err != nil {
		return nil, fmt.Errorf("failed to get customer %d: %w", req.Id, err)
	}

	// Convert v2 to v1 for response
	v1Customer, err := s.adapter.V2ToV1(v2Customer)
	if err != nil {
		return nil, fmt.Errorf("failed to convert customer to v1: %w", err)
	}

	return &customerv1.GetCustomerResponse{
		Customer: v1Customer,
	}, nil
}

// CreateCustomerV1 implements the v1 CreateCustomer API
func (s *MultiVersionService) CreateCustomerV1(ctx context.Context, req *customerv1.CreateCustomerRequest) (*customerv1.CreateCustomerResponse, error) {
	if err := req.Validate(); err != nil {
		return nil, fmt.Errorf("invalid v1 create request: %w", err)
	}

	// Convert v1 customer to v2 for internal storage
	v2Customer, err := s.adapter.V1ToV2(req.Customer)
	if err != nil {
		return nil, fmt.Errorf("failed to convert v1 customer to v2: %w", err)
	}

	// Create customer in v2 format
	createdV2, err := s.internalRepo.CreateCustomerV2(ctx, v2Customer)
	if err != nil {
		return nil, fmt.Errorf("failed to create customer: %w", err)
	}

	// Publish event using v2 customer
	if err := s.publisher.PublishCustomerCreated(ctx, createdV2); err != nil {
		fmt.Printf("Warning: failed to publish customer created event: %v\n", err)
	}

	// Convert back to v1 for response
	v1Customer, err := s.adapter.V2ToV1(createdV2)
	if err != nil {
		return nil, fmt.Errorf("failed to convert created customer to v1: %w", err)
	}

	return &customerv1.CreateCustomerResponse{
		Customer: v1Customer,
	}, nil
}

// === V2 API Methods ===

// GetCustomerV2 implements the v2 GetCustomer API
func (s *MultiVersionService) GetCustomerV2(ctx context.Context, req *customerv2.GetCustomerRequest) (*customerv2.GetCustomerResponse, error) {
	if err := req.Validate(); err != nil {
		return nil, fmt.Errorf("invalid v2 request: %w", err)
	}

	// Get customer directly in v2 format
	v2Customer, err := s.internalRepo.GetCustomerV2(ctx, req.Id)
	if err != nil {
		return nil, fmt.Errorf("failed to get customer %d: %w", req.Id, err)
	}

	return &customerv2.GetCustomerResponse{
		Customer: v2Customer,
	}, nil
}

// CreateCustomerV2 implements the v2 CreateCustomer API
func (s *MultiVersionService) CreateCustomerV2(ctx context.Context, req *customerv2.CreateCustomerRequest) (*customerv2.CreateCustomerResponse, error) {
	if err := req.Validate(); err != nil {
		return nil, fmt.Errorf("invalid v2 create request: %w", err)
	}

	// Create customer directly in v2 format
	createdV2, err := s.internalRepo.CreateCustomerV2(ctx, req.Customer)
	if err != nil {
		return nil, fmt.Errorf("failed to create customer: %w", err)
	}

	// Publish event
	if err := s.publisher.PublishCustomerCreated(ctx, createdV2); err != nil {
		fmt.Printf("Warning: failed to publish customer created event: %v\n", err)
	}

	return &customerv2.CreateCustomerResponse{
		Customer: createdV2,
	}, nil
}

// ListCustomersV2 implements the v2 ListCustomers API
func (s *MultiVersionService) ListCustomersV2(ctx context.Context, req *customerv2.ListCustomersRequest) (*customerv2.ListCustomersResponse, error) {
	if err := req.Validate(); err != nil {
		return nil, fmt.Errorf("invalid v2 list request: %w", err)
	}

	filter := ListFilter{
		PageSize:  req.PageSize,
		PageToken: req.PageToken,
	}

	customers, err := s.internalRepo.ListCustomersV2(ctx, filter)
	if err != nil {
		return nil, fmt.Errorf("failed to list customers: %w", err)
	}

	return &customerv2.ListCustomersResponse{
		Customers:     customers,
		NextPageToken: "next_page_token_123", // TODO: Real pagination
		TotalCount:    int32(len(customers)),
	}, nil
}

// UpdateCustomerV2 implements the v2 UpdateCustomer API
func (s *MultiVersionService) UpdateCustomerV2(ctx context.Context, req *customerv2.UpdateCustomerRequest) (*customerv2.UpdateCustomerResponse, error) {
	if err := req.Validate(); err != nil {
		return nil, fmt.Errorf("invalid v2 update request: %w", err)
	}

	// Update customer directly in v2 format
	updatedV2, err := s.internalRepo.UpdateCustomerV2(ctx, req.Customer)
	if err != nil {
		return nil, fmt.Errorf("failed to update customer: %w", err)
	}

	// Publish event
	if err := s.publisher.PublishCustomerUpdated(ctx, updatedV2); err != nil {
		fmt.Printf("Warning: failed to publish customer updated event: %v\n", err)
	}

	return &customerv2.UpdateCustomerResponse{
		Customer: updatedV2,
	}, nil
}

// === Version Migration Utilities ===

// MigrateCustomerToV2 provides a utility to migrate v1 customers to v2
func (s *MultiVersionService) MigrateCustomerToV2(ctx context.Context, v1Customer *customerv1.Customer) (*customerv2.Customer, error) {
	// Convert to v2
	v2Customer, err := s.adapter.V1ToV2(v1Customer)
	if err != nil {
		return nil, fmt.Errorf("failed to convert v1 to v2: %w", err)
	}

	// Update in storage
	updatedV2, err := s.internalRepo.UpdateCustomerV2(ctx, v2Customer)
	if err != nil {
		return nil, fmt.Errorf("failed to update customer during migration: %w", err)
	}

	return updatedV2, nil
}

// GetVersionCompatibilityReport provides information about version compatibility
func (s *MultiVersionService) GetVersionCompatibilityReport(ctx context.Context, id int64) (*VersionCompatibilityReport, error) {
	v2Customer, err := s.internalRepo.GetCustomerV2(ctx, id)
	if err != nil {
		return nil, fmt.Errorf("failed to get customer: %w", err)
	}

	canDowngrade, warnings := s.adapter.CanDowngradeToV1(v2Customer)

	return &VersionCompatibilityReport{
		CustomerId:           id,
		CurrentVersion:       "v2",
		CanDowngradeToV1:     canDowngrade,
		DowngradeWarnings:    warnings,
		HasV2OnlyFeatures:    len(warnings) > 0,
		V2FeatureUsage: V2FeatureUsage{
			HasPhone:         v2Customer.Phone != "",
			HasAddresses:     len(v2Customer.Addresses) > 0,
			HasPreferences:   v2Customer.Preferences != nil,
			HasMetadata:      len(v2Customer.Metadata) > 0,
			UsesNewStatuses:  isNewV2Status(v2Customer.Status),
		},
	}, nil
}

// VersionCompatibilityReport provides version compatibility information
type VersionCompatibilityReport struct {
	CustomerId        int64
	CurrentVersion    string
	CanDowngradeToV1  bool
	DowngradeWarnings []string
	HasV2OnlyFeatures bool
	V2FeatureUsage    V2FeatureUsage
}

// V2FeatureUsage tracks which v2-specific features are being used
type V2FeatureUsage struct {
	HasPhone        bool
	HasAddresses    bool
	HasPreferences  bool
	HasMetadata     bool
	UsesNewStatuses bool
}

func isNewV2Status(status customerv2.CustomerStatus) bool {
	return status == customerv2.CustomerStatus_CUSTOMER_STATUS_SUSPENDED ||
		   status == customerv2.CustomerStatus_CUSTOMER_STATUS_PENDING
}
```

### Step 3: Create Mock V2 Repository
Create `internal/customer/mock_repository_v2.go`:

```go
package customer

import (
	"context"
	"fmt"
	"sync"
	"time"

	customerv2 "github.com/chinook/data-pipeline/pkg/proto/customer/v2"
	"google.golang.org/protobuf/types/known/timestamppb"
)

// mockRepositoryV2 implements RepositoryV2 interface
type mockRepositoryV2 struct {
	mu        sync.RWMutex
	customers map[int64]*customerv2.Customer
	nextID    int64
}

// NewMockRepositoryV2 creates a new mock repository with v2 sample data
func NewMockRepositoryV2() RepositoryV2 {
	now := timestamppb.New(time.Now())
	
	repo := &mockRepositoryV2{
		customers: make(map[int64]*customerv2.Customer),
		nextID:    1,
	}

	// Add sample v2 customers with rich data
	sampleCustomers := []*customerv2.Customer{
		{
			Id:     1,
			Name:   "Alice Smith",
			Email:  "alice@chinook.com",
			Status: customerv2.CustomerStatus_CUSTOMER_STATUS_ACTIVE,
			CreatedAt: now,
			UpdatedAt: now,
			Phone:  "+1-555-100-0001",
			Addresses: []*customerv2.Address{
				{
					Street:  "123 Tech Ave",
					City:    "San Francisco",
					State:   "CA",
					ZipCode: "94105",
					Country: "USA",
					Type:    customerv2.AddressType_ADDRESS_TYPE_WORK,
				},
				{
					Street:  "456 Home St",
					City:    "Oakland",
					State:   "CA",
					ZipCode: "94607",
					Country: "USA",
					Type:    customerv2.AddressType_ADDRESS_TYPE_HOME,
				},
			},
			Preferences: &customerv2.ContactPreferences{
				EmailNotifications: true,
				SmsNotifications:   false,
				PhoneCalls:        true,
				PreferredLanguage: "en-US",
			},
			Metadata: map[string]string{
				"signup_source": "website",
				"tier":         "enterprise",
				"segment":      "tech_industry",
			},
		},
		{
			Id:     2,
			Name:   "Bob Johnson",
			Email:  "bob@example.com",
			Status: customerv2.CustomerStatus_CUSTOMER_STATUS_SUSPENDED,
			CreatedAt: now,
			UpdatedAt: now,
			Phone:  "+1-555-100-0002",
			Addresses: []*customerv2.Address{
				{
					Street:  "789 Main St",
					City:    "Austin",
					State:   "TX",
					ZipCode: "78701",
					Country: "USA",
					Type:    customerv2.AddressType_ADDRESS_TYPE_HOME,
				},
			},
			Preferences: &customerv2.ContactPreferences{
				EmailNotifications: false,
				SmsNotifications:   true,
				PhoneCalls:        false,
				PreferredLanguage: "es-US",
			},
			Metadata: map[string]string{
				"signup_source": "mobile_app",
				"tier":         "standard",
				"region":       "southwest",
			},
		},
		{
			Id:     3,
			Name:   "Charlie Brown",
			Email:  "charlie@example.com",
			Status: customerv2.CustomerStatus_CUSTOMER_STATUS_PENDING,
			CreatedAt: now,
			UpdatedAt: now,
			Phone:  "+1-555-100-0003",
			Addresses: []*customerv2.Address{},  // No addresses
			Preferences: &customerv2.ContactPreferences{
				EmailNotifications: true,
				SmsNotifications:   true,
				PhoneCalls:        false,
				PreferredLanguage: "en-GB",
			},
			Metadata: map[string]string{
				"signup_source": "referral",
				"tier":         "basic",
			},
		},
	}

	for _, customer := range sampleCustomers {
		repo.customers[customer.Id] = customer
		if customer.Id >= repo.nextID {
			repo.nextID = customer.Id + 1
		}
	}

	return repo
}

// GetCustomerV2 retrieves a customer by ID
func (r *mockRepositoryV2) GetCustomerV2(ctx context.Context, id int64) (*customerv2.Customer, error) {
	r.mu.RLock()
	defer r.mu.RUnlock()

	customer, exists := r.customers[id]
	if !exists {
		return nil, fmt.Errorf("customer with ID %d not found", id)
	}

	return cloneCustomerV2(customer), nil
}

// ListCustomersV2 returns customers based on filter
func (r *mockRepositoryV2) ListCustomersV2(ctx context.Context, filter ListFilter) ([]*customerv2.Customer, error) {
	r.mu.RLock()
	defer r.mu.RUnlock()

	var result []*customerv2.Customer
	
	for _, customer := range r.customers {
		// Apply status filter
		if filter.Status != customerv2.CustomerStatus_CUSTOMER_STATUS_UNSPECIFIED && 
		   customer.Status != filter.Status {
			continue
		}

		// Apply search term filter
		if filter.SearchTerm != "" {
			if !contains(customer.Name, filter.SearchTerm) && 
			   !contains(customer.Email, filter.SearchTerm) {
				continue
			}
		}

		result = append(result, cloneCustomerV2(customer))
	}

	// Simple pagination
	pageSize := filter.PageSize
	if pageSize <= 0 {
		pageSize = 10
	}

	if int32(len(result)) > pageSize {
		result = result[:pageSize]
	}

	return result, nil
}

// CreateCustomerV2 creates a new customer
func (r *mockRepositoryV2) CreateCustomerV2(ctx context.Context, customer *customerv2.Customer) (*customerv2.Customer, error) {
	r.mu.Lock()
	defer r.mu.Unlock()

	// Assign new ID
	customer.Id = r.nextID
	r.nextID++

	// Set timestamps
	now := timestamppb.New(time.Now())
	customer.CreatedAt = now
	customer.UpdatedAt = now

	// Store the customer
	r.customers[customer.Id] = cloneCustomerV2(customer)

	return cloneCustomerV2(customer), nil
}

// UpdateCustomerV2 updates an existing customer
func (r *mockRepositoryV2) UpdateCustomerV2(ctx context.Context, customer *customerv2.Customer) (*customerv2.Customer, error) {
	r.mu.Lock()
	defer r.mu.Unlock()

	if _, exists := r.customers[customer.Id]; !exists {
		return nil, fmt.Errorf("customer with ID %d not found", customer.Id)
	}

	// Update timestamp
	customer.UpdatedAt = timestamppb.New(time.Now())

	// Update the customer
	r.customers[customer.Id] = cloneCustomerV2(customer)

	return cloneCustomerV2(customer), nil
}

// DeleteCustomerV2 deletes a customer
func (r *mockRepositoryV2) DeleteCustomerV2(ctx context.Context, id int64) error {
	r.mu.Lock()
	defer r.mu.Unlock()

	if _, exists := r.customers[id]; !exists {
		return nil, fmt.Errorf("customer with ID %d not found", id)
	}

	delete(r.customers, id)
	return nil
}

// Helper function to clone a v2 customer
func cloneCustomerV2(customer *customerv2.Customer) *customerv2.Customer {
	// In a real implementation, you'd use proper deep cloning
	return customer.ProtoReflect().New().Interface().(*customerv2.Customer)
}
```

### Step 4: Create Multi-Version Test Application
Create `cmd/multiversion-test/main.go`:

```go
package main

import (
	"context"
	"fmt"
	"log"

	"github.com/chinook/data-pipeline/internal/customer"
	customerv1 "github.com/chinook/data-pipeline/pkg/proto/customer/v1"
	customerv2 "github.com/chinook/data-pipeline/pkg/proto/customer/v2"
	"google.golang.org/protobuf/encoding/protojson"
)

func main() {
	fmt.Println("📱 Multi-Version API Test Suite")
	fmt.Println("===============================")

	// Setup multi-version service
	repo := customer.NewMockRepositoryV2()
	publisher := customer.NewMockPublisher()
	adapter := customer.NewVersionAdapter()
	service := customer.NewMultiVersionService(repo, publisher, adapter)

	ctx := context.Background()

	// Run comprehensive tests
	testV1APICompatibility(ctx, service)
	testV2APIFeatures(ctx, service)
	testVersionConversion(ctx, service)
	testMixedVersionWorkflow(ctx, service)
	testCompatibilityReporting(ctx, service)
}

func testV1APICompatibility(ctx context.Context, service *customer.MultiVersionService) {
	fmt.Println("\n🔄 Test 1: v1 API Compatibility")
	
	// Test v1 GetCustomer
	getReq := &customerv1.GetCustomerRequest{Id: 1}
	getResp, err := service.GetCustomerV1(ctx, getReq)
	if err != nil {
		log.Printf("❌ v1 GetCustomer failed: %v", err)
		return
	}

	fmt.Printf("✅ v1 GetCustomer works: %s (%s)\n", 
		getResp.Customer.Name, getResp.Customer.Email)

	// Test v1 CreateCustomer
	newV1Customer := &customerv1.Customer{
		Name:   "V1 Test Customer",
		Email:  "v1test@example.com",
		Status: customerv1.CustomerStatus_CUSTOMER_STATUS_ACTIVE,
	}

	createReq := &customerv1.CreateCustomerRequest{Customer: newV1Customer}
	createResp, err := service.CreateCustomerV1(ctx, createReq)
	if err != nil {
		log.Printf("❌ v1 CreateCustomer failed: %v", err)
		return
	}

	fmt.Printf("✅ v1 CreateCustomer works: Created ID %d\n", createResp.Customer.Id)
}

func testV2APIFeatures(ctx context.Context, service *customer.MultiVersionService) {
	fmt.Println("\n🆕 Test 2: v2 API Features")
	
	// Test v2 GetCustomer with rich data
	getReq := &customerv2.GetCustomerRequest{Id: 1}
	getResp, err := service.GetCustomerV2(ctx, getReq)
	if err != nil {
		log.Printf("❌ v2 GetCustomer failed: %v", err)
		return
	}

	customer := getResp.Customer
	fmt.Printf("✅ v2 GetCustomer works: %s (%s)\n", customer.Name, customer.Email)
	fmt.Printf("   Phone: %s, Addresses: %d, Metadata: %d items\n", 
		customer.Phone, len(customer.Addresses), len(customer.Metadata))

	// Test v2 CreateCustomer with full v2 features
	newV2Customer := &customerv2.Customer{
		Name:   "V2 Feature Test Customer",
		Email:  "v2features@example.com",
		Status: customerv2.CustomerStatus_CUSTOMER_STATUS_PENDING,
		Phone:  "+1-555-V2-TEST",
		Addresses: []*customerv2.Address{
			{
				Street:  "123 V2 Feature St",
				City:    "Innovation City",
				State:   "CA",
				ZipCode: "90210",
				Country: "USA",
				Type:    customerv2.AddressType_ADDRESS_TYPE_WORK,
			},
		},
		Preferences: &customerv2.ContactPreferences{
			EmailNotifications: true,
			SmsNotifications:   true,
			PhoneCalls:        false,
			PreferredLanguage: "en-US",
		},
		Metadata: map[string]string{
			"test_version": "v2",
			"feature_set": "full",
		},
	}

	createReq := &customerv2.CreateCustomerRequest{Customer: newV2Customer}
	createResp, err := service.CreateCustomerV2(ctx, createReq)
	if err != nil {
		log.Printf("❌ v2 CreateCustomer failed: %v", err)
		return
	}

	fmt.Printf("✅ v2 CreateCustomer works: Created ID %d with full v2 features\n", 
		createResp.Customer.Id)
}

func testVersionConversion(ctx context.Context, service *customer.MultiVersionService) {
	fmt.Println("\n🔄 Test 3: Version Conversion")
	
	adapter := customer.NewVersionAdapter()

	// Test v1 -> v2 conversion
	v1Customer := &customerv1.Customer{
		Id:     999,
		Name:   "Conversion Test",
		Email:  "conversion@test.com",
		Status: customerv1.CustomerStatus_CUSTOMER_STATUS_ACTIVE,
	}

	v2Customer, err := adapter.V1ToV2(v1Customer)
	if err != nil {
		log.Printf("❌ v1->v2 conversion failed: %v", err)
		return
	}

	fmt.Printf("✅ v1->v2 conversion works:\n")
	fmt.Printf("   Core data preserved: %s (%s)\n", v2Customer.Name, v2Customer.Email)
	fmt.Printf("   New fields added: Phone='%s', Addresses=%d\n", 
		v2Customer.Phone, len(v2Customer.Addresses))

	// Test v2 -> v1 conversion (with data loss)
	richV2Customer := &customerv2.Customer{
		Id:     888,
		Name:   "Rich V2 Customer",
		Email:  "rich@v2.com",
		Status: customerv2.CustomerStatus_CUSTOMER_STATUS_SUSPENDED,
		Phone:  "+1-555-RICH-V2",
		Addresses: []*customerv2.Address{
			{Street: "Rich Street", City: "Rich City"},
		},
		Metadata: map[string]string{"rich": "data"},
	}

	// Check if downgrade is safe
	canDowngrade, warnings := adapter.CanDowngradeToV1(richV2Customer)
	fmt.Printf("✅ Downgrade analysis: Can downgrade=%t, Warnings=%d\n", 
		canDowngrade, len(warnings))
	for _, warning := range warnings {
		fmt.Printf("   ⚠️  %s\n", warning)
	}

	// Perform downgrade
	downgradedV1, err := adapter.V2ToV1(richV2Customer)
	if err != nil {
		log.Printf("❌ v2->v1 conversion failed: %v", err)
		return
	}

	fmt.Printf("✅ v2->v1 conversion works (with data loss):\n")
	fmt.Printf("   Core data preserved: %s (%s)\n", downgradedV1.Name, downgradedV1.Email)
	fmt.Printf("   Status mapped: SUSPENDED -> %s\n", downgradedV1.Status.String())
}

func testMixedVersionWorkflow(ctx context.Context, service *customer.MultiVersionService) {
	fmt.Println("\n🔀 Test 4: Mixed Version Workflow")
	
	// Create customer via v1 API
	v1Customer := &customerv1.Customer{
		Name:   "Mixed Version Customer",
		Email:  "mixed@version.com",
		Status: customerv1.CustomerStatus_CUSTOMER_STATUS_ACTIVE,
	}

	v1CreateReq := &customerv1.CreateCustomerRequest{Customer: v1Customer}
	v1CreateResp, err := service.CreateCustomerV1(ctx, v1CreateReq)
	if err != nil {
		log.Printf("❌ Mixed workflow v1 create failed: %v", err)
		return
	}

	customerID := v1CreateResp.Customer.Id
	fmt.Printf("✅ Created customer %d via v1 API\n", customerID)

	// Read customer via v2 API
	v2GetReq := &customerv2.GetCustomerRequest{Id: customerID}
	v2GetResp, err := service.GetCustomerV2(ctx, v2GetReq)
	if err != nil {
		log.Printf("❌ Mixed workflow v2 get failed: %v", err)
		return
	}

	fmt.Printf("✅ Read customer %d via v2 API:\n", customerID)
	fmt.Printf("   Has v2 defaults: Phone='%s', Preferences=%t\n", 
		v2GetResp.Customer.Phone, v2GetResp.Customer.Preferences != nil)

	// Update customer via v2 API with v2 features
	v2Customer := v2GetResp.Customer
	v2Customer.Phone = "+1-555-MIXED-WF"
	v2Customer.Addresses = []*customerv2.Address{
		{
			Street: "123 Mixed Workflow St",
			City:   "Integration City",
			Type:   customerv2.AddressType_ADDRESS_TYPE_HOME,
		},
	}

	v2UpdateReq := &customerv2.UpdateCustomerRequest{Customer: v2Customer}
	v2UpdateResp, err := service.UpdateCustomerV2(ctx, v2UpdateReq)
	if err != nil {
		log.Printf("❌ Mixed workflow v2 update failed: %v", err)
		return
	}

	fmt.Printf("✅ Updated customer %d via v2 API with new features\n", customerID)

	// Read updated customer via v1 API (should work but lose v2 data)
	v1GetReq := &customerv1.GetCustomerRequest{Id: customerID}
	v1GetResp, err := service.GetCustomerV1(ctx, v1GetReq)
	if err != nil {
		log.Printf("❌ Mixed workflow v1 get failed: %v", err)
		return
	}

	fmt.Printf("✅ Read updated customer %d via v1 API:\n", customerID)
	fmt.Printf("   Core data intact: %s (%s)\n", 
		v1GetResp.Customer.Name, v1GetResp.Customer.Email)
	fmt.Printf("   v2 features lost (as expected)\n")
}

func testCompatibilityReporting(ctx context.Context, service *customer.MultiVersionService) {
	fmt.Println("\n📊 Test 5: Compatibility Reporting")
	
	// Test compatibility report for customer with v2 features
	report, err := service.GetVersionCompatibilityReport(ctx, 1)
	if err != nil {
		log.Printf("❌ Compatibility report failed: %v", err)
		return
	}

	fmt.Printf("✅ Compatibility report for customer %d:\n", report.CustomerId)
	fmt.Printf("   Current version: %s\n", report.CurrentVersion)
	fmt.Printf("   Can downgrade to v1: %t\n", report.CanDowngradeToV1)
	fmt.Printf("   Has v2-only features: %t\n", report.HasV2OnlyFeatures)
	fmt.Printf("   Feature usage:\n")
	fmt.Printf("     - Phone: %t\n", report.V2FeatureUsage.HasPhone)
	fmt.Printf("     - Addresses: %t\n", report.V2FeatureUsage.HasAddresses)
	fmt.Printf("     - Preferences: %t\n", report.V2FeatureUsage.HasPreferences)
	fmt.Printf("     - Metadata: %t\n", report.V2FeatureUsage.HasMetadata)
	fmt.Printf("     - New statuses: %t\n", report.V2FeatureUsage.UsesNewStatuses)

	if len(report.DowngradeWarnings) > 0 {
		fmt.Printf("   Downgrade warnings:\n")
		for _, warning := range report.DowngradeWarnings {
			fmt.Printf("     ⚠️  %s\n", warning)
		}
	}

	// Pretty print a v2 customer with all features
	fmt.Println("\n📄 Sample v2 customer with all features:")
	v2GetReq := &customerv2.GetCustomerRequest{Id: 1}
	v2GetResp, err := service.GetCustomerV2(ctx, v2GetReq)
	if err == nil {
		jsonBytes, _ := protojson.MarshalOptions{Indent: "  "}.Marshal(v2GetResp.Customer)
		fmt.Println(string(jsonBytes))
	}

	fmt.Println("\n🎉 Multi-version API testing completed successfully!")
}
```

### Step 5: Test Multi-Version API
```bash
# Run multi-version test
go run cmd/multiversion-test/main.go
```

## 💥 Deliberate Failure: Version Mismatch Scenarios

### Break It:
1. Try to read a v2 customer with rich data using v1 API
2. Create a customer with v2-only status using v1 API
3. Attempt to downgrade a customer with lots of v2 data

### Fix It:
The adapter should handle these gracefully with warnings and data loss notifications.

## 🔍 Further Exploration

1. **Implement automatic migration utilities** for bulk v1->v2 conversion
2. **Add version-aware caching** that handles both versions
3. **Create client SDK adapters** for different language versions
4. **Build gradual rollout mechanisms** for version transitions

## ✅ Victory Conditions

- [ ] Both v1 and v2 APIs work correctly
- [ ] Version conversion preserves core data
- [ ] Data loss warnings are provided for unsafe downgrades
- [ ] Mixed-version workflows function properly
- [ ] Compatibility reporting provides useful insights

## 🚨 Common Issues & Solutions

**Issue**: Conversion errors between versions
**Solution**: Check enum mappings and field type compatibility

**Issue**: Unexpected data loss during version conversion
**Solution**: Use compatibility reports to warn about lossy operations

**Issue**: Performance issues with version conversion
**Solution**: Consider caching converted objects or using lazy conversion

---

**Next**: Head to `lab03/` to master field deprecation and migration! 🗂️