# Lab 4: üèóÔ∏è Advanced Schema Patterns

Master advanced protobuf patterns! You'll implement polymorphic data with oneof, create extensible designs, and build plugin-style architectures.

## üéØ Objectives
- Implement oneof for polymorphic data
- Use Any types for dynamic content  
- Create extensible message designs
- Build plugin-style architectures

## üõ†Ô∏è Tasks

### Step 1: Create Polymorphic Payment Schema
Create `api/payment/v1/payment.proto`:

```protobuf
syntax = "proto3";
package payment.v1;
option go_package = "example.com/chinook/data-pipeline/pkg/proto/payment/v1;paymentv1";

import "google/protobuf/any.proto";
import "google/protobuf/timestamp.proto";

// Polymorphic payment method using oneof
message PaymentMethod {
  string id = 1;
  oneof method {
    CreditCard credit_card = 2;
    BankAccount bank_account = 3;
    DigitalWallet digital_wallet = 4;
    Cryptocurrency crypto = 5;
  }
  bool is_default = 6;
  google.protobuf.Timestamp created_at = 7;
}

message CreditCard {
  string masked_number = 1;  // **** **** **** 1234
  string expiry_month = 2;
  string expiry_year = 3;
  string brand = 4;          // visa, mastercard, etc.
  string billing_zip = 5;
}

message BankAccount {
  string masked_account = 1;  // ****1234
  string routing_number = 2;
  string bank_name = 3;
  AccountType account_type = 4;
}

enum AccountType {
  ACCOUNT_TYPE_UNSPECIFIED = 0;
  ACCOUNT_TYPE_CHECKING = 1;
  ACCOUNT_TYPE_SAVINGS = 2;
}

message DigitalWallet {
  WalletProvider provider = 1;
  string wallet_id = 2;
}

enum WalletProvider {
  WALLET_PROVIDER_UNSPECIFIED = 0;
  WALLET_PROVIDER_PAYPAL = 1;
  WALLET_PROVIDER_APPLE_PAY = 2;
  WALLET_PROVIDER_GOOGLE_PAY = 3;
}

message Cryptocurrency {
  CryptoType crypto_type = 1;
  string wallet_address = 2;
}

enum CryptoType {
  CRYPTO_TYPE_UNSPECIFIED = 0;
  CRYPTO_TYPE_BITCOIN = 1;
  CRYPTO_TYPE_ETHEREUM = 2;
}

// Dynamic metadata using Any
message PaymentMetadata {
  map<string, google.protobuf.Any> properties = 1;
  repeated string tags = 2;
}
```

### Step 2: Create Plugin Architecture
Create `api/plugin/v1/plugin.proto`:

```protobuf
syntax = "proto3";
package plugin.v1;
option go_package = "example.com/chinook/data-pipeline/pkg/proto/plugin/v1;pluginv1";

import "google/protobuf/any.proto";

// Extensible plugin system
message Plugin {
  string name = 1;
  string version = 2;
  PluginType type = 3;
  google.protobuf.Any config = 4;
  repeated Capability capabilities = 5;
}

enum PluginType {
  PLUGIN_TYPE_UNSPECIFIED = 0;
  PLUGIN_TYPE_DATA_SOURCE = 1;
  PLUGIN_TYPE_TRANSFORMER = 2;
  PLUGIN_TYPE_DESTINATION = 3;
  PLUGIN_TYPE_VALIDATOR = 4;
}

message Capability {
  string name = 1;
  google.protobuf.Any parameters = 2;
}
```

### Step 3: Test Polymorphic Patterns
Create `cmd/advanced-patterns/main.go`:

```go
package main

import (
	"fmt"
	"log"

	paymentv1 "example.com/chinook/data-pipeline/pkg/proto/payment/v1"
	"google.golang.org/protobuf/encoding/protojson"
	"google.golang.org/protobuf/types/known/timestamppb"
)

func main() {
	fmt.Println("üèóÔ∏è Advanced Schema Patterns Laboratory")
	
	testOneofPatterns()
	testPolymorphism()
	testExtensibility()
}

func testOneofPatterns() {
	fmt.Println("\nüîÄ Testing Oneof Patterns")
	
	// Create different payment methods
	creditCard := &paymentv1.PaymentMethod{
		Id: "pm_credit_123",
		Method: &paymentv1.PaymentMethod_CreditCard{
			CreditCard: &paymentv1.CreditCard{
				MaskedNumber: "**** **** **** 1234",
				ExpiryMonth:  "12",
				ExpiryYear:   "2025",
				Brand:        "visa",
				BillingZip:   "90210",
			},
		},
		IsDefault: true,
		CreatedAt: timestamppb.Now(),
	}

	bankAccount := &paymentv1.PaymentMethod{
		Id: "pm_bank_456",
		Method: &paymentv1.PaymentMethod_BankAccount{
			BankAccount: &paymentv1.BankAccount{
				MaskedAccount: "****1234",
				RoutingNumber: "123456789",
				BankName:      "Chinook Bank",
				AccountType:   paymentv1.AccountType_ACCOUNT_TYPE_CHECKING,
			},
		},
		IsDefault: false,
		CreatedAt: timestamppb.Now(),
	}

	// Test oneof handling
	methods := []*paymentv1.PaymentMethod{creditCard, bankAccount}
	
	for _, method := range methods {
		fmt.Printf("\nPayment Method: %s\n", method.Id)
		
		switch m := method.Method.(type) {
		case *paymentv1.PaymentMethod_CreditCard:
			fmt.Printf("  Type: Credit Card (%s)\n", m.CreditCard.Brand)
			fmt.Printf("  Number: %s\n", m.CreditCard.MaskedNumber)
		case *paymentv1.PaymentMethod_BankAccount:
			fmt.Printf("  Type: Bank Account (%s)\n", m.BankAccount.AccountType.String())
			fmt.Printf("  Bank: %s\n", m.BankAccount.BankName)
		default:
			fmt.Printf("  Type: Unknown\n")
		}
		
		fmt.Printf("  Default: %t\n", method.IsDefault)
	}
}

func testPolymorphism() {
	fmt.Println("\nüé≠ Testing Polymorphism")
	
	// Function that works with any payment method
	processPayment := func(method *paymentv1.PaymentMethod, amount float64) {
		fmt.Printf("Processing $%.2f payment via %s\n", amount, method.Id)
		
		// Type-specific processing
		switch m := method.Method.(type) {
		case *paymentv1.PaymentMethod_CreditCard:
			fmt.Printf("  Credit card processing: %s ending in %s\n", 
				m.CreditCard.Brand, m.CreditCard.MaskedNumber[len(m.CreditCard.MaskedNumber)-4:])
		case *paymentv1.PaymentMethod_BankAccount:
			fmt.Printf("  ACH processing: %s account at %s\n", 
				m.BankAccount.AccountType.String(), m.BankAccount.BankName)
		case *paymentv1.PaymentMethod_DigitalWallet:
			fmt.Printf("  Digital wallet processing: %s\n", 
				m.DigitalWallet.Provider.String())
		case *paymentv1.PaymentMethod_Crypto:
			fmt.Printf("  Crypto processing: %s to %s\n", 
				m.Crypto.CryptoType.String(), m.Crypto.WalletAddress)
		}
	}

	// Test with different payment types
	crypto := &paymentv1.PaymentMethod{
		Id: "pm_crypto_789",
		Method: &paymentv1.PaymentMethod_Crypto{
			Crypto: &paymentv1.Cryptocurrency{
				CryptoType:    paymentv1.CryptoType_CRYPTO_TYPE_BITCOIN,
				WalletAddress: "1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa",
			},
		},
	}

	processPayment(crypto, 150.75)
}

func testExtensibility() {
	fmt.Println("\nüîß Testing Extensibility")
	
	wallet := &paymentv1.PaymentMethod{
		Id: "pm_wallet_101",
		Method: &paymentv1.PaymentMethod_DigitalWallet{
			DigitalWallet: &paymentv1.DigitalWallet{
				Provider:  paymentv1.WalletProvider_WALLET_PROVIDER_APPLE_PAY,
				WalletId: "apple_pay_token_xyz",
			},
		},
	}

	// Serialize to JSON to see structure
	jsonBytes, err := protojson.MarshalOptions{Indent: "  "}.Marshal(wallet)
	if err != nil {
		log.Fatal(err)
	}

	fmt.Printf("Payment method as JSON:\n%s\n", string(jsonBytes))
	
	fmt.Println("‚úÖ Advanced patterns test completed!")
}
```

## üí• Deliberate Failure: Oneof Limitations

### Break It:
1. Try to set multiple oneof fields simultaneously
2. Test what happens with unknown oneof variants
3. See how serialization handles empty oneof

### Fix It:
Protobuf enforces oneof constraints automatically - only one field can be set.

## ‚úÖ Victory Conditions

- [ ] Oneof patterns work for polymorphic data
- [ ] Type switching handles all variants
- [ ] Any types provide extensibility
- [ ] Plugin architecture is flexible

---

**Next**: Tomorrow we dive into database integration! üîå