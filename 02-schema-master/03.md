# Lab 3: üóÇÔ∏è Field Deprecation & Migration

Time to master the art of graceful field deprecation! You'll learn how to sunset old fields, migrate data, and handle mixed deployments without breaking production. This is where schema evolution gets surgical! üî¨

## üéØ Objectives
- Implement proper field deprecation strategies
- Build data migration utilities
- Handle mixed-version deployments safely
- Create automated migration tooling

## üõ†Ô∏è Tasks

### Step 1: Create Deprecation-Aware Schema (v2.1)
Create `api/customer/v2_1/customer_v2_1.proto`:

```protobuf
syntax = "proto3";

package customer.v2_1;

option go_package = "example.com/chinook/data-pipeline/pkg/proto/customer/v2_1;customerv21";

import "google/protobuf/timestamp.proto";

// Customer v2.1 - Demonstrating field deprecation patterns
message Customer {
  int64 id = 1;
  string name = 2;
  string email = 3;
  CustomerStatus status = 4;
  google.protobuf.Timestamp created_at = 5;
  
  // DEPRECATED FIELDS - Phase 1: Mark as deprecated
  string phone = 6 [deprecated = true];              // Will be replaced by contact_info
  repeated Address addresses = 7 [deprecated = true]; // Will be replaced by contact_info
  
  google.protobuf.Timestamp updated_at = 9;
  map<string, string> metadata = 10;
  
  // NEW STRUCTURED CONTACT INFO - Phase 1: Add alongside deprecated fields
  ContactInfo contact_info = 11;                     // Replaces phone + addresses
  
  // NEW PREFERENCE SYSTEM - Phase 1: Add new system
  CustomerPreferences preferences = 12;              // Enhanced preferences
  
  // DEPRECATED PREFERENCE FIELD - Phase 1: Mark old as deprecated
  ContactPreferences old_preferences = 8 [deprecated = true];
}

// Enhanced contact information structure
message ContactInfo {
  // Phone numbers with labels
  repeated PhoneNumber phones = 1;
  
  // Addresses with full validation
  repeated Address addresses = 2;
  
  // Emergency contact information
  EmergencyContact emergency_contact = 3;
  
  // Preferred contact method and timing
  ContactMethod preferred_contact_method = 4;
  ContactTiming preferred_contact_timing = 5;
}

message PhoneNumber {
  string number = 1;
  PhoneType type = 2;
  bool is_primary = 3;
  bool verified = 4;
}

enum PhoneType {
  PHONE_TYPE_UNSPECIFIED = 0;
  PHONE_TYPE_MOBILE = 1;
  PHONE_TYPE_HOME = 2;
  PHONE_TYPE_WORK = 3;
  PHONE_TYPE_FAX = 4;
}

// Enhanced address structure
message Address {
  string street = 1;
  string city = 2;
  string state = 3;
  string zip_code = 4;
  string country = 5;
  AddressType type = 6;
  
  // NEW FIELDS - Enhanced addressing
  string unit = 7;              // Apartment, suite, etc.
  bool verified = 8;            // Address verification status
  double latitude = 9;          // Geocoding
  double longitude = 10;        // Geocoding
}

enum AddressType {
  ADDRESS_TYPE_UNSPECIFIED = 0;
  ADDRESS_TYPE_HOME = 1;
  ADDRESS_TYPE_WORK = 2;
  ADDRESS_TYPE_BILLING = 3;
  ADDRESS_TYPE_SHIPPING = 4;
  ADDRESS_TYPE_TEMPORARY = 5;   // NEW
}

message EmergencyContact {
  string name = 1;
  string phone = 2;
  string relationship = 3;
}

enum ContactMethod {
  CONTACT_METHOD_UNSPECIFIED = 0;
  CONTACT_METHOD_EMAIL = 1;
  CONTACT_METHOD_SMS = 2;
  CONTACT_METHOD_PHONE = 3;
  CONTACT_METHOD_POSTAL = 4;
}

message ContactTiming {
  repeated DayOfWeek preferred_days = 1;
  TimeRange preferred_time_range = 2;
  string timezone = 3;
}

enum DayOfWeek {
  DAY_OF_WEEK_UNSPECIFIED = 0;
  DAY_OF_WEEK_MONDAY = 1;
  DAY_OF_WEEK_TUESDAY = 2;
  DAY_OF_WEEK_WEDNESDAY = 3;
  DAY_OF_WEEK_THURSDAY = 4;
  DAY_OF_WEEK_FRIDAY = 5;
  DAY_OF_WEEK_SATURDAY = 6;
  DAY_OF_WEEK_SUNDAY = 7;
}

message TimeRange {
  string start_time = 1;  // HH:MM format
  string end_time = 2;    // HH:MM format
}

// Enhanced preferences system
message CustomerPreferences {
  // Communication preferences
  CommunicationPreferences communication = 1;
  
  // Privacy preferences
  PrivacyPreferences privacy = 2;
  
  // Service preferences
  ServicePreferences service = 3;
  
  // Marketing preferences
  MarketingPreferences marketing = 4;
}

message CommunicationPreferences {
  bool email_enabled = 1;
  bool sms_enabled = 2;
  bool phone_enabled = 3;
  bool postal_enabled = 4;
  string preferred_language = 5;
  ContactMethod primary_method = 6;
}

message PrivacyPreferences {
  bool allow_data_sharing = 1;
  bool allow_analytics_tracking = 2;
  bool allow_third_party_contacts = 3;
  DataRetentionPreference data_retention = 4;
}

enum DataRetentionPreference {
  DATA_RETENTION_UNSPECIFIED = 0;
  DATA_RETENTION_MINIMAL = 1;      // Delete after legal minimum
  DATA_RETENTION_STANDARD = 2;     // Standard business retention
  DATA_RETENTION_EXTENDED = 3;     // Keep for enhanced service
}

message ServicePreferences {
  string preferred_currency = 1;
  string preferred_timezone = 2;
  repeated string preferred_service_categories = 3;
  NotificationFrequency notification_frequency = 4;
}

enum NotificationFrequency {
  NOTIFICATION_FREQUENCY_UNSPECIFIED = 0;
  NOTIFICATION_FREQUENCY_IMMEDIATE = 1;
  NOTIFICATION_FREQUENCY_DAILY = 2;
  NOTIFICATION_FREQUENCY_WEEKLY = 3;
  NOTIFICATION_FREQUENCY_MONTHLY = 4;
  NOTIFICATION_FREQUENCY_NEVER = 5;
}

message MarketingPreferences {
  bool allow_promotional_emails = 1;
  bool allow_promotional_sms = 2;
  bool allow_promotional_calls = 3;
  bool allow_promotional_postal = 4;
  repeated string interested_categories = 5;
  MarketingFrequency frequency = 6;
}

enum MarketingFrequency {
  MARKETING_FREQUENCY_UNSPECIFIED = 0;
  MARKETING_FREQUENCY_WEEKLY = 1;
  MARKETING_FREQUENCY_MONTHLY = 2;
  MARKETING_FREQUENCY_QUARTERLY = 3;
  MARKETING_FREQUENCY_NEVER = 4;
}

// Deprecated contact preferences (will be removed in v3)
message ContactPreferences {
  option deprecated = true;
  
  bool email_notifications = 1 [deprecated = true];
  bool sms_notifications = 2 [deprecated = true];
  bool phone_calls = 3 [deprecated = true];
  string preferred_language = 4 [deprecated = true];
}

// Customer status remains the same
enum CustomerStatus {
  CUSTOMER_STATUS_UNSPECIFIED = 0;
  CUSTOMER_STATUS_ACTIVE = 1;
  CUSTOMER_STATUS_INACTIVE = 2;
  CUSTOMER_STATUS_SUSPENDED = 3;
  CUSTOMER_STATUS_PENDING = 4;
}

// Service definition with deprecation-aware methods
service CustomerService {
  // Existing methods remain unchanged for compatibility
  rpc GetCustomer(GetCustomerRequest) returns (GetCustomerResponse);
  rpc CreateCustomer(CreateCustomerRequest) returns (CreateCustomerResponse);
  rpc UpdateCustomer(UpdateCustomerRequest) returns (UpdateCustomerResponse);
  rpc ListCustomers(ListCustomersRequest) returns (ListCustomersResponse);
  
  // NEW METHODS for enhanced functionality
  rpc GetCustomerContactInfo(GetCustomerContactInfoRequest) returns (GetCustomerContactInfoResponse);
  rpc UpdateCustomerContactInfo(UpdateCustomerContactInfoRequest) returns (UpdateCustomerContactInfoResponse);
  rpc GetCustomerPreferences(GetCustomerPreferencesRequest) returns (GetCustomerPreferencesResponse);
  rpc UpdateCustomerPreferences(UpdateCustomerPreferencesRequest) returns (UpdateCustomerPreferencesResponse);
  
  // MIGRATION UTILITIES
  rpc MigrateCustomerData(MigrateCustomerDataRequest) returns (MigrateCustomerDataResponse);
  rpc GetMigrationStatus(GetMigrationStatusRequest) returns (GetMigrationStatusResponse);
}

// Standard request/response messages
message GetCustomerRequest {
  int64 id = 1;
}

message GetCustomerResponse {
  Customer customer = 1;
}

message CreateCustomerRequest {
  Customer customer = 1;
}

message CreateCustomerResponse {
  Customer customer = 1;
}

message UpdateCustomerRequest {
  Customer customer = 1;
}

message UpdateCustomerResponse {
  Customer customer = 1;
}

message ListCustomersRequest {
  int32 page_size = 1;
  string page_token = 2;
}

message ListCustomersResponse {
  repeated Customer customers = 1;
  string next_page_token = 2;
}

// New method request/response messages
message GetCustomerContactInfoRequest {
  int64 customer_id = 1;
}

message GetCustomerContactInfoResponse {
  ContactInfo contact_info = 1;
}

message UpdateCustomerContactInfoRequest {
  int64 customer_id = 1;
  ContactInfo contact_info = 2;
}

message UpdateCustomerContactInfoResponse {
  ContactInfo contact_info = 1;
}

message GetCustomerPreferencesRequest {
  int64 customer_id = 1;
}

message GetCustomerPreferencesResponse {
  CustomerPreferences preferences = 1;
}

message UpdateCustomerPreferencesRequest {
  int64 customer_id = 1;
  CustomerPreferences preferences = 2;
}

message UpdateCustomerPreferencesResponse {
  CustomerPreferences preferences = 1;
}

// Migration utility messages
message MigrateCustomerDataRequest {
  int64 customer_id = 1;
  MigrationType migration_type = 2;
  bool force_migration = 3;  // Override safety checks
}

enum MigrationType {
  MIGRATION_TYPE_UNSPECIFIED = 0;
  MIGRATION_TYPE_CONTACT_INFO = 1;      // Migrate phone/addresses to contact_info
  MIGRATION_TYPE_PREFERENCES = 2;       // Migrate old_preferences to preferences
  MIGRATION_TYPE_FULL = 3;             // Migrate everything
}

message MigrateCustomerDataResponse {
  bool success = 1;
  string message = 2;
  MigrationResult result = 3;
}

message MigrationResult {
  bool contact_info_migrated = 1;
  bool preferences_migrated = 2;
  repeated string warnings = 3;
  repeated string errors = 4;
}

message GetMigrationStatusRequest {
  int64 customer_id = 1;
}

message GetMigrationStatusResponse {
  MigrationStatus status = 1;
}

message MigrationStatus {
  int64 customer_id = 1;
  bool needs_contact_info_migration = 2;
  bool needs_preferences_migration = 3;
  bool has_deprecated_fields = 4;
  repeated string deprecated_fields_in_use = 5;
  google.protobuf.Timestamp last_migration_check = 6;
}
```

### Step 2: Create Migration Utilities
Create `internal/customer/migration.go`:

```go
package customer

import (
	"context"
	"fmt"
	"strings"
	"time"

	customerv2 "example.com/chinook/data-pipeline/pkg/proto/customer/v2"
	customerv21 "example.com/chinook/data-pipeline/pkg/proto/customer/v2_1"
	"google.golang.org/protobuf/types/known/timestamppb"
)

// MigrationService handles field deprecation and data migration
type MigrationService struct {
	repo      RepositoryV21
	publisher EventPublisher
}

// RepositoryV21 defines repository interface for v2.1
type RepositoryV21 interface {
	GetCustomerV21(ctx context.Context, id int64) (*customerv21.Customer, error)
	UpdateCustomerV21(ctx context.Context, customer *customerv21.Customer) (*customerv21.Customer, error)
	ListCustomersV21(ctx context.Context, filter ListFilter) ([]*customerv21.Customer, error)
}

// NewMigrationService creates a new migration service
func NewMigrationService(repo RepositoryV21, publisher EventPublisher) *MigrationService {
	return &MigrationService{
		repo:      repo,
		publisher: publisher,
	}
}

// MigrateCustomerData migrates deprecated fields to new structures
func (s *MigrationService) MigrateCustomerData(ctx context.Context, req *customerv21.MigrateCustomerDataRequest) (*customerv21.MigrateCustomerDataResponse, error) {
	customer, err := s.repo.GetCustomerV21(ctx, req.CustomerId)
	if err != nil {
		return nil, fmt.Errorf("failed to get customer %d: %w", req.CustomerId, err)
	}

	result := &customerv21.MigrationResult{}
	var warnings []string
	var errors []string

	// Perform migration based on type
	switch req.MigrationType {
	case customerv21.MigrationType_MIGRATION_TYPE_CONTACT_INFO:
		success, warns, errs := s.migrateContactInfo(customer)
		result.ContactInfoMigrated = success
		warnings = append(warnings, warns...)
		errors = append(errors, errs...)

	case customerv21.MigrationType_MIGRATION_TYPE_PREFERENCES:
		success, warns, errs := s.migratePreferences(customer)
		result.PreferencesMigrated = success
		warnings = append(warnings, warns...)
		errors = append(errors, errs...)

	case customerv21.MigrationType_MIGRATION_TYPE_FULL:
		// Migrate contact info
		contactSuccess, contactWarns, contactErrs := s.migrateContactInfo(customer)
		result.ContactInfoMigrated = contactSuccess
		warnings = append(warnings, contactWarns...)
		errors = append(errors, contactErrs...)

		// Migrate preferences
		prefSuccess, prefWarns, prefErrs := s.migratePreferences(customer)
		result.PreferencesMigrated = prefSuccess
		warnings = append(warnings, prefWarns...)
		errors = append(errors, prefErrs...)

	default:
		return nil, fmt.Errorf("unknown migration type: %v", req.MigrationType)
	}

	// Save migrated customer
	if len(errors) == 0 || req.ForceMigration {
		_, err := s.repo.UpdateCustomerV21(ctx, customer)
		if err != nil {
			errors = append(errors, fmt.Sprintf("failed to save migrated customer: %v", err))
		}
	}

	result.Warnings = warnings
	result.Errors = errors

	success := len(errors) == 0
	message := "Migration completed successfully"
	if len(errors) > 0 {
		message = fmt.Sprintf("Migration completed with %d errors", len(errors))
		if req.ForceMigration {
			message += " (forced)"
		}
	}

	return &customerv21.MigrateCustomerDataResponse{
		Success: success,
		Message: message,
		Result:  result,
	}, nil
}

// migrateContactInfo migrates deprecated phone/addresses to contact_info
func (s *MigrationService) migrateContactInfo(customer *customerv21.Customer) (bool, []string, []string) {
	var warnings []string
	var errors []string

	// Skip if already migrated
	if customer.ContactInfo != nil && 
	   (len(customer.ContactInfo.Phones) > 0 || len(customer.ContactInfo.Addresses) > 0) {
		warnings = append(warnings, "contact info already migrated")
		return true, warnings, errors
	}

	// Initialize contact info if not present
	if customer.ContactInfo == nil {
		customer.ContactInfo = &customerv21.ContactInfo{}
	}

	// Migrate deprecated phone field
	if customer.Phone != "" {
		phoneNumber := &customerv21.PhoneNumber{
			Number:    customer.Phone,
			Type:      customerv21.PhoneType_PHONE_TYPE_MOBILE, // Assume mobile
			IsPrimary: true,
			Verified:  false,
		}
		customer.ContactInfo.Phones = append(customer.ContactInfo.Phones, phoneNumber)
		warnings = append(warnings, "migrated deprecated phone field to contact_info.phones")
		
		// Clear deprecated field (commented out for gradual migration)
		// customer.Phone = ""
	}

	// Migrate deprecated addresses field
	if len(customer.Addresses) > 0 {
		for i, oldAddr := range customer.Addresses {
			newAddr := &customerv21.Address{
				Street:  oldAddr.Street,
				City:    oldAddr.City,
				State:   oldAddr.State,
				ZipCode: oldAddr.ZipCode,
				Country: oldAddr.Country,
				Type:    customerv21.AddressType(oldAddr.Type), // Cast to new type
				// New fields get defaults
				Unit:      "",
				Verified:  false,
				Latitude:  0.0,
				Longitude: 0.0,
			}
			customer.ContactInfo.Addresses = append(customer.ContactInfo.Addresses, newAddr)
			warnings = append(warnings, fmt.Sprintf("migrated deprecated address %d to contact_info.addresses", i))
		}
		
		// Clear deprecated field (commented out for gradual migration)
		// customer.Addresses = nil
	}

	return true, warnings, errors
}

// migratePreferences migrates old_preferences to new preferences structure
func (s *MigrationService) migratePreferences(customer *customerv21.Customer) (bool, []string, []string) {
	var warnings []string
	var errors []string

	// Skip if already migrated
	if customer.Preferences != nil &&
	   customer.Preferences.Communication != nil {
		warnings = append(warnings, "preferences already migrated")
		return true, warnings, errors
	}

	// Skip if no old preferences to migrate
	if customer.OldPreferences == nil {
		warnings = append(warnings, "no old preferences to migrate")
		return true, warnings, errors
	}

	// Initialize new preferences structure
	if customer.Preferences == nil {
		customer.Preferences = &customerv21.CustomerPreferences{}
	}

	// Migrate communication preferences
	customer.Preferences.Communication = &customerv21.CommunicationPreferences{
		EmailEnabled:      customer.OldPreferences.EmailNotifications,
		SmsEnabled:        customer.OldPreferences.SmsNotifications,
		PhoneEnabled:      customer.OldPreferences.PhoneCalls,
		PostalEnabled:     false, // Default
		PreferredLanguage: customer.OldPreferences.PreferredLanguage,
		PrimaryMethod:     determinePreferredContactMethod(customer.OldPreferences),
	}

	// Set default privacy preferences
	customer.Preferences.Privacy = &customerv21.PrivacyPreferences{
		AllowDataSharing:        false, // Conservative default
		AllowAnalyticsTracking:  true,  // Standard default
		AllowThirdPartyContacts: false, // Conservative default
		DataRetention:          customerv21.DataRetentionPreference_DATA_RETENTION_STANDARD,
	}

	// Set default service preferences
	customer.Preferences.Service = &customerv21.ServicePreferences{
		PreferredCurrency:         "USD", // Default
		PreferredTimezone:         "UTC", // Default
		PreferredServiceCategories: []string{}, // Empty
		NotificationFrequency:     customerv21.NotificationFrequency_NOTIFICATION_FREQUENCY_WEEKLY,
	}

	// Set default marketing preferences (opt-out by default)
	customer.Preferences.Marketing = &customerv21.MarketingPreferences{
		AllowPromotionalEmails: false, // Conservative default
		AllowPromotionalSms:    false, // Conservative default
		AllowPromotionalCalls:  false, // Conservative default
		AllowPromotionalPostal: false, // Conservative default
		InterestedCategories:   []string{}, // Empty
		Frequency:             customerv21.MarketingFrequency_MARKETING_FREQUENCY_NEVER,
	}

	warnings = append(warnings, "migrated old_preferences to new preferences structure")
	warnings = append(warnings, "applied conservative defaults for new preference fields")

	// Clear deprecated field (commented out for gradual migration)
	// customer.OldPreferences = nil

	return true, warnings, errors
}

// determinePreferredContactMethod infers preferred method from old preferences
func determinePreferredContactMethod(oldPrefs *customerv21.ContactPreferences) customerv21.ContactMethod {
	if oldPrefs.EmailNotifications {
		return customerv21.ContactMethod_CONTACT_METHOD_EMAIL
	}
	if oldPrefs.SmsNotifications {
		return customerv21.ContactMethod_CONTACT_METHOD_SMS
	}
	if oldPrefs.PhoneCalls {
		return customerv21.ContactMethod_CONTACT_METHOD_PHONE
	}
	return customerv21.ContactMethod_CONTACT_METHOD_EMAIL // Default
}

// GetMigrationStatus analyzes a customer's migration needs
func (s *MigrationService) GetMigrationStatus(ctx context.Context, req *customerv21.GetMigrationStatusRequest) (*customerv21.GetMigrationStatusResponse, error) {
	customer, err := s.repo.GetCustomerV21(ctx, req.CustomerId)
	if err != nil {
		return nil, fmt.Errorf("failed to get customer %d: %w", req.CustomerId, err)
	}

	status := &customerv21.MigrationStatus{
		CustomerId:               req.CustomerId,
		LastMigrationCheck:       timestamppb.New(time.Now()),
		DeprecatedFieldsInUse:    []string{},
	}

	// Check contact info migration needs
	needsContactMigration := false
	if customer.Phone != "" || len(customer.Addresses) > 0 {
		needsContactMigration = true
		if customer.Phone != "" {
			status.DeprecatedFieldsInUse = append(status.DeprecatedFieldsInUse, "phone")
		}
		if len(customer.Addresses) > 0 {
			status.DeprecatedFieldsInUse = append(status.DeprecatedFieldsInUse, "addresses")
		}
	}
	status.NeedsContactInfoMigration = needsContactMigration

	// Check preferences migration needs
	needsPreferencesMigration := false
	if customer.OldPreferences != nil {
		needsPreferencesMigration = true
		status.DeprecatedFieldsInUse = append(status.DeprecatedFieldsInUse, "old_preferences")
	}
	status.NeedsPreferencesMigration = needsPreferencesMigration

	// Overall deprecated fields status
	status.HasDeprecatedFields = len(status.DeprecatedFieldsInUse) > 0

	return &customerv21.GetMigrationStatusResponse{
		Status: status,
	}, nil
}

// BulkMigrateCustomers migrates multiple customers in batch
func (s *MigrationService) BulkMigrateCustomers(ctx context.Context, filter ListFilter, migrationType customerv21.MigrationType) (*BulkMigrationResult, error) {
	customers, err := s.repo.ListCustomersV21(ctx, filter)
	if err != nil {
		return nil, fmt.Errorf("failed to list customers: %w", err)
	}

	result := &BulkMigrationResult{
		TotalCustomers:   len(customers),
		SuccessfulMigrations: 0,
		FailedMigrations:     0,
		Warnings:           []string{},
		Errors:            []string{},
	}

	for _, customer := range customers {
		req := &customerv21.MigrateCustomerDataRequest{
			CustomerId:     customer.Id,
			MigrationType:  migrationType,
			ForceMigration: false,
		}

		resp, err := s.MigrateCustomerData(ctx, req)
		if err != nil {
			result.FailedMigrations++
			result.Errors = append(result.Errors, 
				fmt.Sprintf("Customer %d: %v", customer.Id, err))
			continue
		}

		if resp.Success {
			result.SuccessfulMigrations++
		} else {
			result.FailedMigrations++
		}

		// Collect warnings and errors
		for _, warning := range resp.Result.Warnings {
			result.Warnings = append(result.Warnings, 
				fmt.Sprintf("Customer %d: %s", customer.Id, warning))
		}
		for _, error := range resp.Result.Errors {
			result.Errors = append(result.Errors, 
				fmt.Sprintf("Customer %d: %s", customer.Id, error))
		}
	}

	return result, nil
}

// BulkMigrationResult contains results of bulk migration operation
type BulkMigrationResult struct {
	TotalCustomers       int
	SuccessfulMigrations int
	FailedMigrations     int
	Warnings            []string
	Errors              []string
}

// String returns a human-readable summary of the bulk migration
func (r *BulkMigrationResult) String() string {
	var sb strings.Builder
	sb.WriteString(fmt.Sprintf("Bulk Migration Results:\n"))
	sb.WriteString(fmt.Sprintf("  Total customers: %d\n", r.TotalCustomers))
	sb.WriteString(fmt.Sprintf("  Successful: %d\n", r.SuccessfulMigrations))
	sb.WriteString(fmt.Sprintf("  Failed: %d\n", r.FailedMigrations))
	sb.WriteString(fmt.Sprintf("  Success rate: %.1f%%\n", 
		float64(r.SuccessfulMigrations)/float64(r.TotalCustomers)*100))
	
	if len(r.Warnings) > 0 {
		sb.WriteString(fmt.Sprintf("  Warnings: %d\n", len(r.Warnings)))
	}
	if len(r.Errors) > 0 {
		sb.WriteString(fmt.Sprintf("  Errors: %d\n", len(r.Errors)))
	}
	
	return sb.String()
}
```

### Step 3: Create Migration Test Application
Create `cmd/migration-test/main.go`:

```go
package main

import (
	"context"
	"fmt"
	"log"

	"example.com/chinook/data-pipeline/internal/customer"
	customerv21 "example.com/chinook/data-pipeline/pkg/proto/customer/v2_1"
)

func main() {
	fmt.Println("üóÇÔ∏è Field Deprecation & Migration Laboratory")
	fmt.Println("===========================================")

	// Setup migration service (mock repo with v2.1 support)
	repo := customer.NewMockRepositoryV21()
	publisher := customer.NewMockPublisher()
	migrationService := customer.NewMigrationService(repo, publisher)

	ctx := context.Background()

	// Run migration tests
	testMigrationStatusAnalysis(ctx, migrationService)
	testContactInfoMigration(ctx, migrationService)
	testPreferencesMigration(ctx, migrationService)
	testFullMigration(ctx, migrationService)
	testBulkMigration(ctx, migrationService)
}

func testMigrationStatusAnalysis(ctx context.Context, service *customer.MigrationService) {
	fmt.Println("\nüìä Test 1: Migration Status Analysis")
	
	// Analyze migration status for different customers
	customerIDs := []int64{1, 2, 3}
	
	for _, id := range customerIDs {
		req := &customerv21.GetMigrationStatusRequest{CustomerId: id}
		resp, err := service.GetMigrationStatus(ctx, req)
		if err != nil {
			log.Printf("‚ùå Failed to get migration status for customer %d: %v", id, err)
			continue
		}

		status := resp.Status
		fmt.Printf("\nüîç Customer %d Migration Status:\n", id)
		fmt.Printf("   Needs contact info migration: %t\n", status.NeedsContactInfoMigration)
		fmt.Printf("   Needs preferences migration: %t\n", status.NeedsPreferencesMigration)
		fmt.Printf("   Has deprecated fields: %t\n", status.HasDeprecatedFields)
		
		if len(status.DeprecatedFieldsInUse) > 0 {
			fmt.Printf("   Deprecated fields in use: %v\n", status.DeprecatedFieldsInUse)
		}
		
		if status.NeedsContactInfoMigration || status.NeedsPreferencesMigration {
			fmt.Printf("   ‚ö†Ô∏è  Migration recommended\n")
		} else {
			fmt.Printf("   ‚úÖ No migration needed\n")
		}
	}
}

func testContactInfoMigration(ctx context.Context, service *customer.MigrationService) {
	fmt.Println("\nüìû Test 2: Contact Info Migration")
	
	// Test migrating contact info for a customer with deprecated fields
	req := &customerv21.MigrateCustomerDataRequest{
		CustomerId:     1,
		MigrationType:  customerv21.MigrationType_MIGRATION_TYPE_CONTACT_INFO,
		ForceMigration: false,
	}

	resp, err := service.MigrateCustomerData(ctx, req)
	if err != nil {
		log.Printf("‚ùå Contact info migration failed: %v", err)
		return
	}

	fmt.Printf("‚úÖ Contact info migration result:\n")
	fmt.Printf("   Success: %t\n", resp.Success)
	fmt.Printf("   Message: %s\n", resp.Message)
	fmt.Printf("   Contact info migrated: %t\n", resp.Result.ContactInfoMigrated)
	
	if len(resp.Result.Warnings) > 0 {
		fmt.Printf("   Warnings:\n")
		for _, warning := range resp.Result.Warnings {
			fmt.Printf("     ‚ö†Ô∏è  %s\n", warning)
		}
	}
	
	if len(resp.Result.Errors) > 0 {
		fmt.Printf("   Errors:\n")
		for _, error := range resp.Result.Errors {
			fmt.Printf("     ‚ùå %s\n", error)
		}
	}
}

func testPreferencesMigration(ctx context.Context, service *customer.MigrationService) {
	fmt.Println("\n‚öôÔ∏è Test 3: Preferences Migration")
	
	// Test migrating preferences for a customer with old preferences
	req := &customerv21.MigrateCustomerDataRequest{
		CustomerId:     2,
		MigrationType:  customerv21.MigrationType_MIGRATION_TYPE_PREFERENCES,
		ForceMigration: false,
	}

	resp, err := service.MigrateCustomerData(ctx, req)
	if err != nil {
		log.Printf("‚ùå Preferences migration failed: %v", err)
		return
	}

	fmt.Printf("‚úÖ Preferences migration result:\n")
	fmt.Printf("   Success: %t\n", resp.Success)
	fmt.Printf("   Message: %s\n", resp.Message)
	fmt.Printf("   Preferences migrated: %t\n", resp.Result.PreferencesMigrated)
	
	if len(resp.Result.Warnings) > 0 {
		fmt.Printf("   Warnings:\n")
		for _, warning := range resp.Result.Warnings {
			fmt.Printf("     ‚ö†Ô∏è  %s\n", warning)
		}
	}
}

func testFullMigration(ctx context.Context, service *customer.MigrationService) {
	fmt.Println("\nüîÑ Test 4: Full Migration")
	
	// Test full migration for a customer
	req := &customerv21.MigrateCustomerDataRequest{
		CustomerId:     3,
		MigrationType:  customerv21.MigrationType_MIGRATION_TYPE_FULL,
		ForceMigration: false,
	}

	resp, err := service.MigrateCustomerData(ctx, req)
	if err != nil {
		log.Printf("‚ùå Full migration failed: %v", err)
		return
	}

	fmt.Printf("‚úÖ Full migration result:\n")
	fmt.Printf("   Success: %t\n", resp.Success)
	fmt.Printf("   Message: %s\n", resp.Message)
	fmt.Printf("   Contact info migrated: %t\n", resp.Result.ContactInfoMigrated)
	fmt.Printf("   Preferences migrated: %t\n", resp.Result.PreferencesMigrated)
	
	fmt.Printf("   Total warnings: %d\n", len(resp.Result.Warnings))
	fmt.Printf("   Total errors: %d\n", len(resp.Result.Errors))
	
	// Show first few warnings/errors
	if len(resp.Result.Warnings) > 0 {
		fmt.Printf("   Sample warnings:\n")
		for i, warning := range resp.Result.Warnings {
			if i >= 3 { break } // Show first 3
			fmt.Printf("     ‚ö†Ô∏è  %s\n", warning)
		}
	}
}

func testBulkMigration(ctx context.Context, service *customer.MigrationService) {
	fmt.Println("\nüì¶ Test 5: Bulk Migration")
	
	// Test bulk migration of all customers
	filter := customer.ListFilter{
		PageSize: 100, // Migrate up to 100 customers
	}

	result, err := service.BulkMigrateCustomers(ctx, filter, customerv21.MigrationType_MIGRATION_TYPE_FULL)
	if err != nil {
		log.Printf("‚ùå Bulk migration failed: %v", err)
		return
	}

	fmt.Printf("‚úÖ Bulk migration completed:\n")
	fmt.Print(result.String())
	
	// Show sample warnings and errors
	if len(result.Warnings) > 0 {
		fmt.Printf("\nSample warnings:\n")
		for i, warning := range result.Warnings {
			if i >= 3 { break }
			fmt.Printf("  ‚ö†Ô∏è  %s\n", warning)
		}
		if len(result.Warnings) > 3 {
			fmt.Printf("  ... and %d more warnings\n", len(result.Warnings)-3)
		}
	}
	
	if len(result.Errors) > 0 {
		fmt.Printf("\nSample errors:\n")
		for i, error := range result.Errors {
			if i >= 3 { break }
			fmt.Printf("  ‚ùå %s\n", error)
		}
		if len(result.Errors) > 3 {
			fmt.Printf("  ... and %d more errors\n", len(result.Errors)-3)
		}
	}

	fmt.Println("\nüéâ Migration testing completed!")
	fmt.Println("\nüí° Next Steps:")
	fmt.Println("   1. Review migration warnings and errors")
	fmt.Println("   2. Test new functionality with migrated data")
	fmt.Println("   3. Plan deprecation timeline for old fields")
	fmt.Println("   4. Monitor usage of deprecated fields")
	fmt.Println("   5. Eventually remove deprecated fields in v3")
}
```

## üí• Deliberate Failure: Migration Edge Cases

### Break It:
1. Try to migrate data with invalid field values
2. Force migration despite errors
3. Migrate the same customer multiple times
4. Test migration rollback scenarios

### Fix It:
The migration service should handle these gracefully with proper error reporting and idempotency.

## üîç Further Exploration

1. **Implement migration rollback** functionality
2. **Add migration progress tracking** for long-running bulk operations
3. **Create migration validation rules** to prevent data corruption
4. **Build migration monitoring dashboards** to track adoption

## ‚úÖ Victory Conditions

- [ ] Deprecated fields are properly marked in the schema
- [ ] Migration utilities preserve data integrity
- [ ] Bulk migration handles errors gracefully
- [ ] Migration status reporting works correctly
- [ ] New structured data is properly populated

## üö® Common Issues & Solutions

**Issue**: Data loss during migration
**Solution**: Always validate migration results and provide rollback capability

**Issue**: Migration performance problems
**Solution**: Implement batch processing and progress tracking

**Issue**: Inconsistent migration state
**Solution**: Use transactions and implement idempotent migration operations

---

**Next**: Head to `lab04/` to explore advanced schema patterns! üèóÔ∏è