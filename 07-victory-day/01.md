# Lab 1: 🧪 Comprehensive Testing Suite

**Duration**: 45 minutes  
**Difficulty**: Advanced  

## 🎯 Objectives
- Achieve >90% test coverage across your pipeline
- Implement load testing with realistic data volumes
- Create chaos engineering experiments
- Build automated test reporting and CI integration

## 📋 Prerequisites
- Completed Day 6 labs (your pipeline is deployed)
- Docker and docker-compose available
- Go test tools installed

## 🛠️ Tasks

### Task 1: Test Coverage Analysis (15 minutes)

First, let's analyze your current test coverage and identify gaps.

Create a test coverage analysis script:

```bash
# Create the test coverage tool
mkdir -p cmd/test-coverage
```

**File: `cmd/test-coverage/main.go`**
```go
package main

import (
	"bufio"
	"fmt"
	"os"
	"os/exec"
	"regexp"
	"sort"
	"strconv"
	"strings"
)

type CoverageReport struct {
	Package    string
	Coverage   float64
	Statements int
	Covered    int
}

func main() {
	fmt.Println("🧪 Chinook Test Coverage Analysis")
	fmt.Println("=====================================")

	// Run go test with coverage
	cmd := exec.Command("go", "test", "-coverprofile=coverage.out", "./...")
	output, err := cmd.CombinedOutput()
	if err != nil {
		fmt.Printf("❌ Test execution failed: %v\n", err)
		fmt.Printf("Output: %s\n", output)
		os.Exit(1)
	}

	// Parse coverage results
	reports, err := parseCoverageOutput(string(output))
	if err != nil {
		fmt.Printf("❌ Failed to parse coverage: %v\n", err)
		os.Exit(1)
	}

	// Display results
	displayCoverageReport(reports)

	// Generate HTML report
	generateHTMLReport()

	// Check coverage thresholds
	checkCoverageThresholds(reports)
}

func parseCoverageOutput(output string) ([]CoverageReport, error) {
	var reports []CoverageReport
	lines := strings.Split(output, "\n")
	
	// Regex to match coverage lines: package coverage: X.X% of statements
	coverageRegex := regexp.MustCompile(`([^\s]+)\s+coverage:\s+([\d.]+)%\s+of\s+statements`)

	for _, line := range lines {
		matches := coverageRegex.FindStringSubmatch(line)
		if len(matches) == 2 {
			coverage, _ := strconv.ParseFloat(matches[2], 64)
			reports = append(reports, CoverageReport{
				Package:  matches[1],
				Coverage: coverage,
			})
		}
	}

	return reports, nil
}

func displayCoverageReport(reports []CoverageReport) {
	if len(reports) == 0 {
		fmt.Println("❌ No coverage data found")
		return
	}

	// Sort by coverage ascending (worst first)
	sort.Slice(reports, func(i, j int) bool {
		return reports[i].Coverage < reports[j].Coverage
	})

	fmt.Printf("\n📊 Coverage Report (%d packages)\n", len(reports))
	fmt.Println("Package                                    Coverage")
	fmt.Println("──────────────────────────────────────────────────")

	totalCoverage := 0.0
	for _, report := range reports {
		status := getCoverageStatus(report.Coverage)
		fmt.Printf("%-40s %s %.1f%%\n", 
			truncatePackage(report.Package), 
			status, 
			report.Coverage)
		totalCoverage += report.Coverage
	}

	avgCoverage := totalCoverage / float64(len(reports))
	fmt.Println("──────────────────────────────────────────────────")
	fmt.Printf("Average Coverage:                       %s %.1f%%\n", 
		getCoverageStatus(avgCoverage), avgCoverage)
}

func getCoverageStatus(coverage float64) string {
	if coverage >= 90 {
		return "🟢"
	} else if coverage >= 70 {
		return "🟡"
	}
	return "🔴"
}

func truncatePackage(pkg string) string {
	if len(pkg) > 40 {
		return "..." + pkg[len(pkg)-37:]
	}
	return pkg
}

func generateHTMLReport() {
	fmt.Println("\n📊 Generating HTML coverage report...")
	cmd := exec.Command("go", "tool", "cover", "-html=coverage.out", "-o", "coverage.html")
	if err := cmd.Run(); err != nil {
		fmt.Printf("❌ Failed to generate HTML report: %v\n", err)
		return
	}
	fmt.Println("✅ HTML report generated: coverage.html")
}

func checkCoverageThresholds(reports []CoverageReport) {
	fmt.Println("\n🎯 Coverage Threshold Analysis")
	fmt.Println("─────────────────────────────")

	issues := []string{}

	for _, report := range reports {
		if report.Coverage < 70 {
			issues = append(issues, fmt.Sprintf("📦 %s: %.1f%% (below 70%%)", 
				report.Package, report.Coverage))
		}
	}

	if len(issues) == 0 {
		fmt.Println("✅ All packages meet minimum coverage threshold (70%)")
	} else {
		fmt.Println("❌ Packages below threshold:")
		for _, issue := range issues {
			fmt.Printf("   %s\n", issue)
		}
	}

	// Calculate overall metrics
	totalCoverage := 0.0
	for _, report := range reports {
		totalCoverage += report.Coverage
	}
	avgCoverage := totalCoverage / float64(len(reports))

	fmt.Printf("\n🏆 Overall Status: ")
	if avgCoverage >= 90 {
		fmt.Printf("🎯 EXCELLENT (%.1f%%)\n", avgCoverage)
	} else if avgCoverage >= 80 {
		fmt.Printf("🟢 GOOD (%.1f%%)\n", avgCoverage)
	} else if avgCoverage >= 70 {
		fmt.Printf("🟡 ACCEPTABLE (%.1f%%)\n", avgCoverage)
	} else {
		fmt.Printf("🔴 NEEDS IMPROVEMENT (%.1f%%)\n", avgCoverage)
	}
}
```

**Run the coverage analysis:**
```bash
cd /Users/rob/@Sync/bufstuff/protobuf
go run cmd/test-coverage/main.go
```

### Task 2: Load Testing Infrastructure (15 minutes)

Create a comprehensive load testing suite that simulates realistic Chinook workloads.

**File: `cmd/load-test/main.go`**
```go
package main

import (
	"context"
	"database/sql"
	"fmt"
	"log"
	"math/rand"
	"sync"
	"sync/atomic"
	"time"

	_ "github.com/mattn/go-sqlite3"
	"google.golang.org/protobuf/proto"

	"chinook/internal/customer"
	pb "chinook/proto/customer/v1"
)

type LoadTestConfig struct {
	DatabaseURL      string
	ConcurrentUsers  int
	TestDuration     time.Duration
	OperationsPerSec int
}

type LoadTestMetrics struct {
	TotalOperations    int64
	SuccessfulOps      int64
	FailedOps          int64
	AverageLatency     time.Duration
	MaxLatency         time.Duration
	MinLatency         time.Duration
	OperationsPerSec   float64
	ErrorRate          float64
}

type LoadTester struct {
	config      LoadTestConfig
	metrics     *LoadTestMetrics
	db          *sql.DB
	customerSvc *customer.Service
	wg          sync.WaitGroup
	ctx         context.Context
	cancel      context.CancelFunc
}

func main() {
	fmt.Println("🚀 Chinook Load Testing Suite")
	fmt.Println("==================================")

	config := LoadTestConfig{
		DatabaseURL:      "../resources/chinook.db",
		ConcurrentUsers:  50,
		TestDuration:     5 * time.Minute,
		OperationsPerSec: 100,
	}

	tester, err := NewLoadTester(config)
	if err != nil {
		log.Fatalf("❌ Failed to create load tester: %v", err)
	}
	defer tester.Close()

	// Run the load test
	fmt.Printf("🎯 Starting load test:\n")
	fmt.Printf("   • Concurrent Users: %d\n", config.ConcurrentUsers)
	fmt.Printf("   • Duration: %v\n", config.TestDuration)
	fmt.Printf("   • Target Ops/Sec: %d\n", config.OperationsPerSec)
	fmt.Println()

	results := tester.RunLoadTest()
	tester.DisplayResults(results)
}

func NewLoadTester(config LoadTestConfig) (*LoadTester, error) {
	db, err := sql.Open("sqlite3", config.DatabaseURL)
	if err != nil {
		return nil, fmt.Errorf("failed to connect to database: %w", err)
	}

	// Configure connection pool for load testing
	db.SetMaxOpenConns(config.ConcurrentUsers * 2)
	db.SetMaxIdleConns(config.ConcurrentUsers)
	db.SetConnMaxLifetime(30 * time.Minute)

	if err := db.Ping(); err != nil {
		return nil, fmt.Errorf("failed to ping database: %w", err)
	}

	customerSvc := customer.NewService(db)
	ctx, cancel := context.WithCancel(context.Background())

	return &LoadTester{
		config:      config,
		metrics:     &LoadTestMetrics{},
		db:          db,
		customerSvc: customerSvc,
		ctx:         ctx,
		cancel:      cancel,
	}, nil
}

func (lt *LoadTester) RunLoadTest() *LoadTestMetrics {
	startTime := time.Now()
	
	// Start workers
	for i := 0; i < lt.config.ConcurrentUsers; i++ {
		lt.wg.Add(1)
		go lt.worker(i)
	}

	// Run for specified duration
	time.Sleep(lt.config.TestDuration)
	lt.cancel()

	// Wait for all workers to finish
	lt.wg.Wait()

	// Calculate final metrics
	duration := time.Since(startTime)
	lt.metrics.OperationsPerSec = float64(lt.metrics.TotalOperations) / duration.Seconds()
	if lt.metrics.TotalOperations > 0 {
		lt.metrics.ErrorRate = float64(lt.metrics.FailedOps) / float64(lt.metrics.TotalOperations) * 100
	}

	return lt.metrics
}

func (lt *LoadTester) worker(workerID int) {
	defer lt.wg.Done()

	operationTypes := []string{"create", "read", "update", "list"}
	latencies := []time.Duration{}

	for {
		select {
		case <-lt.ctx.Done():
			// Calculate average latency for this worker
			if len(latencies) > 0 {
				var total time.Duration
				for _, lat := range latencies {
					total += lat
				}
				avg := total / time.Duration(len(latencies))
				
				// Update global metrics (thread-safe)
				if avg > lt.metrics.MaxLatency {
					lt.metrics.MaxLatency = avg
				}
				if lt.metrics.MinLatency == 0 || avg < lt.metrics.MinLatency {
					lt.metrics.MinLatency = avg
				}
			}
			return
		default:
			// Perform random operation
			operation := operationTypes[rand.Intn(len(operationTypes))]
			start := time.Now()
			
			err := lt.performOperation(operation)
			latency := time.Since(start)
			latencies = append(latencies, latency)

			atomic.AddInt64(&lt.metrics.TotalOperations, 1)
			if err != nil {
				atomic.AddInt64(&lt.metrics.FailedOps, 1)
			} else {
				atomic.AddInt64(&lt.metrics.SuccessfulOps, 1)
			}

			// Rate limiting
			sleepDuration := time.Second / time.Duration(lt.config.OperationsPerSec/lt.config.ConcurrentUsers)
			time.Sleep(sleepDuration)
		}
	}
}

func (lt *LoadTester) performOperation(operation string) error {
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	switch operation {
	case "create":
		return lt.performCreate(ctx)
	case "read":
		return lt.performRead(ctx)
	case "update":
		return lt.performUpdate(ctx)
	case "list":
		return lt.performList(ctx)
	default:
		return fmt.Errorf("unknown operation: %s", operation)
	}
}

func (lt *LoadTester) performCreate(ctx context.Context) error {
	customerData := &pb.Customer{
		Id:    fmt.Sprintf("load-test-%d", rand.Int63()),
		Email: fmt.Sprintf("loadtest%d@chinook.com", rand.Int63()),
		Name:  fmt.Sprintf("Load Test User %d", rand.Int63()),
		Phone: fmt.Sprintf("+1555%07d", rand.Intn(9999999)),
		Metadata: map[string]string{
			"test_type":    "load_test",
			"worker_id":    fmt.Sprintf("%d", rand.Intn(lt.config.ConcurrentUsers)),
			"timestamp":    time.Now().Format(time.RFC3339),
		},
	}

	return lt.customerSvc.Create(ctx, customerData)
}

func (lt *LoadTester) performRead(ctx context.Context) error {
	// Get a random customer ID from database
	var customerID string
	err := lt.db.QueryRowContext(ctx, 
		"SELECT id FROM customers ORDER BY RANDOM() LIMIT 1").Scan(&customerID)
	if err != nil {
		if err == sql.ErrNoRows {
			// No customers in DB, create one first
			return lt.performCreate(ctx)
		}
		return err
	}

	_, err = lt.customerSvc.GetByID(ctx, customerID)
	return err
}

func (lt *LoadTester) performUpdate(ctx context.Context) error {
	// Get a random customer
	var customerID string
	err := lt.db.QueryRowContext(ctx,
		"SELECT id FROM customers ORDER BY RANDOM() LIMIT 1").Scan(&customerID)
	if err != nil {
		if err == sql.ErrNoRows {
			return lt.performCreate(ctx)
		}
		return err
	}

	// Update with new data
	updates := &pb.Customer{
		Id:    customerID,
		Phone: fmt.Sprintf("+1555%07d", rand.Intn(9999999)),
		Metadata: map[string]string{
			"last_updated": time.Now().Format(time.RFC3339),
			"update_type":  "load_test",
		},
	}

	return lt.customerSvc.Update(ctx, updates)
}

func (lt *LoadTester) performList(ctx context.Context) error {
	_, err := lt.customerSvc.List(ctx, 10, 0)
	return err
}

func (lt *LoadTester) DisplayResults(metrics *LoadTestMetrics) {
	fmt.Println("\n📊 Load Test Results")
	fmt.Println("═══════════════════")

	fmt.Printf("📈 Operations:\n")
	fmt.Printf("   • Total:      %d\n", metrics.TotalOperations)
	fmt.Printf("   • Successful: %d\n", metrics.SuccessfulOps)
	fmt.Printf("   • Failed:     %d\n", metrics.FailedOps)
	fmt.Printf("   • Success Rate: %.2f%%\n", 
		float64(metrics.SuccessfulOps)/float64(metrics.TotalOperations)*100)

	fmt.Printf("\n⚡ Performance:\n")
	fmt.Printf("   • Ops/Second: %.2f\n", metrics.OperationsPerSec)
	fmt.Printf("   • Min Latency: %v\n", metrics.MinLatency)
	fmt.Printf("   • Max Latency: %v\n", metrics.MaxLatency)

	fmt.Printf("\n🎯 Assessment:\n")
	if metrics.OperationsPerSec >= float64(lt.config.OperationsPerSec) {
		fmt.Printf("   ✅ Performance target MET (%.0f >= %d ops/sec)\n", 
			metrics.OperationsPerSec, lt.config.OperationsPerSec)
	} else {
		fmt.Printf("   ❌ Performance target MISSED (%.0f < %d ops/sec)\n", 
			metrics.OperationsPerSec, lt.config.OperationsPerSec)
	}

	if metrics.ErrorRate < 1.0 {
		fmt.Printf("   ✅ Error rate acceptable (%.2f%% < 1.0%%)\n", metrics.ErrorRate)
	} else {
		fmt.Printf("   ❌ Error rate too high (%.2f%% >= 1.0%%)\n", metrics.ErrorRate)
	}
}

func (lt *LoadTester) Close() {
	if lt.db != nil {
		lt.db.Close()
	}
}
```

### Task 3: Chaos Engineering (10 minutes)

Create chaos experiments to test your system's resilience.

**File: `cmd/chaos-test/main.go`**
```go
package main

import (
	"context"
	"fmt"
	"log"
	"math/rand"
	"os"
	"os/exec"
	"sync"
	"time"
)

type ChaosExperiment struct {
	Name        string
	Description string
	Duration    time.Duration
	Execute     func(ctx context.Context) error
	Verify      func(ctx context.Context) error
}

type ChaosRunner struct {
	experiments []ChaosExperiment
	results     map[string]ChaosResult
	mu          sync.RWMutex
}

type ChaosResult struct {
	Success   bool
	Error     error
	Duration  time.Duration
	Recovery  time.Duration
}

func main() {
	fmt.Println("💥 Chinook Chaos Engineering")
	fmt.Println("================================")

	runner := NewChaosRunner()
	runner.RunExperiments()
	runner.GenerateReport()
}

func NewChaosRunner() *ChaosRunner {
	runner := &ChaosRunner{
		results: make(map[string]ChaosResult),
	}

	// Define chaos experiments
	runner.experiments = []ChaosExperiment{
		{
			Name:        "Database Connection Loss",
			Description: "Simulate temporary database unavailability",
			Duration:    30 * time.Second,
			Execute:     runner.simulateDBFailure,
			Verify:      runner.verifyDBRecovery,
		},
		{
			Name:        "High Memory Pressure",
			Description: "Simulate memory pressure on the application",
			Duration:    20 * time.Second,
			Execute:     runner.simulateMemoryPressure,
			Verify:      runner.verifyMemoryRecovery,
		},
		{
			Name:        "Network Partitions",
			Description: "Simulate network connectivity issues",
			Duration:    15 * time.Second,
			Execute:     runner.simulateNetworkPartition,
			Verify:      runner.verifyNetworkRecovery,
		},
		{
			Name:        "Disk Space Exhaustion",
			Description: "Simulate running out of disk space",
			Duration:    10 * time.Second,
			Execute:     runner.simulateDiskFull,
			Verify:      runner.verifyDiskRecovery,
		},
	}

	return runner
}

func (cr *ChaosRunner) RunExperiments() {
	fmt.Printf("🎯 Running %d chaos experiments...\n\n", len(cr.experiments))

	for i, experiment := range cr.experiments {
		fmt.Printf("Experiment %d/%d: %s\n", i+1, len(cr.experiments), experiment.Name)
		fmt.Printf("Description: %s\n", experiment.Description)
		fmt.Printf("Duration: %v\n", experiment.Duration)

		result := cr.runSingleExperiment(experiment)
		
		cr.mu.Lock()
		cr.results[experiment.Name] = result
		cr.mu.Unlock()

		if result.Success {
			fmt.Printf("✅ PASSED (recovery in %v)\n", result.Recovery)
		} else {
			fmt.Printf("❌ FAILED: %v\n", result.Error)
		}
		fmt.Println("─────────────────────────────────")

		// Wait between experiments
		time.Sleep(5 * time.Second)
	}
}

func (cr *ChaosRunner) runSingleExperiment(experiment ChaosExperiment) ChaosResult {
	ctx, cancel := context.WithTimeout(context.Background(), experiment.Duration*2)
	defer cancel()

	start := time.Now()

	// Execute the chaos
	fmt.Printf("💥 Injecting failure...\n")
	if err := experiment.Execute(ctx); err != nil {
		return ChaosResult{
			Success:  false,
			Error:    fmt.Errorf("failed to inject chaos: %w", err),
			Duration: time.Since(start),
		}
	}

	// Wait for the chaos duration
	time.Sleep(experiment.Duration)

	// Verify recovery
	fmt.Printf("🔄 Checking recovery...\n")
	recoveryStart := time.Now()
	
	// Give system time to recover
	maxRecoveryTime := 30 * time.Second
	recoveryCtx, recoveryCancel := context.WithTimeout(context.Background(), maxRecoveryTime)
	defer recoveryCancel()

	var lastErr error
	for {
		select {
		case <-recoveryCtx.Done():
			return ChaosResult{
				Success:  false,
				Error:    fmt.Errorf("recovery timeout: %v", lastErr),
				Duration: time.Since(start),
				Recovery: time.Since(recoveryStart),
			}
		default:
			if err := experiment.Verify(recoveryCtx); err != nil {
				lastErr = err
				time.Sleep(time.Second)
				continue
			}
			
			// Recovery successful
			return ChaosResult{
				Success:  true,
				Duration: time.Since(start),
				Recovery: time.Since(recoveryStart),
			}
		}
	}
}

func (cr *ChaosRunner) simulateDBFailure(ctx context.Context) error {
	// Simulate database unavailability by temporarily renaming the database file
	originalPath := "../resources/chinook.db"
	tempPath := "../resources/chinook.db.tmp"
	cmd := exec.Command("mv", originalPath, tempPath)
	if err := cmd.Run(); err != nil {
		return fmt.Errorf("failed to simulate database failure: %w", err)
	}

	// Schedule restoration
	go func() {
		time.Sleep(20 * time.Second)
		cmd := exec.Command("mv", tempPath, originalPath)
		cmd.Run()
	}()

	return nil
}

func (cr *ChaosRunner) verifyDBRecovery(ctx context.Context) error {
	// Try to access the database file
	_, err := os.Stat("../resources/chinook.db")
	return err
}

func (cr *ChaosRunner) simulateMemoryPressure(ctx context.Context) error {
	// Create memory pressure by allocating large chunks
	go func() {
		// Allocate 500MB chunks repeatedly
		var memoryHog [][]byte
		for i := 0; i < 10; i++ {
			chunk := make([]byte, 50*1024*1024) // 50MB
			memoryHog = append(memoryHog, chunk)
			time.Sleep(time.Second)
		}
		
		// Hold memory for experiment duration
		time.Sleep(15 * time.Second)
		
		// Release memory
		memoryHog = nil
	}()
	
	return nil
}

func (cr *ChaosRunner) verifyMemoryRecovery(ctx context.Context) error {
	// Check if our service is still responding
	// This is a simplified check - in real scenarios you'd call your health endpoint
	cmd := exec.Command("pgrep", "-f", "chinook")
	return cmd.Run()
}

func (cr *ChaosRunner) simulateNetworkPartition(ctx context.Context) error {
	// Add network delay and packet loss
	cmds := []string{
		"sudo tc qdisc add dev lo root netem delay 100ms 20ms",
		"sudo tc qdisc change dev lo root netem delay 100ms 20ms loss 10%",
	}

	for _, cmdStr := range cmds {
		cmd := exec.Command("sh", "-c", cmdStr)
		if err := cmd.Run(); err != nil {
			// If tc commands fail, just log and continue
			fmt.Printf("Warning: %s failed: %v\n", cmdStr, err)
		}
	}

	// Schedule cleanup
	go func() {
		time.Sleep(10 * time.Second)
		cmd := exec.Command("sudo", "tc", "qdisc", "del", "dev", "lo", "root")
		cmd.Run()
	}()

	return nil
}

func (cr *ChaosRunner) verifyNetworkRecovery(ctx context.Context) error {
	// Simple connectivity test
	cmd := exec.Command("ping", "-c", "1", "-W", "2", "localhost")
	return cmd.Run()
}

func (cr *ChaosRunner) simulateDiskFull(ctx context.Context) error {
	// Create a large temporary file to fill disk
	cmd := exec.Command("dd", "if=/dev/zero", "of=/tmp/chaos-fill", 
		"bs=1M", "count=100")
	
	go func() {
		cmd.Run()
		// Schedule cleanup
		time.Sleep(5 * time.Second)
		exec.Command("rm", "-f", "/tmp/chaos-fill").Run()
	}()

	return nil
}

func (cr *ChaosRunner) verifyDiskRecovery(ctx context.Context) error {
	// Check if we can write to disk
	cmd := exec.Command("touch", "/tmp/chaos-recovery-test")
	if err := cmd.Run(); err != nil {
		return err
	}
	
	// Cleanup
	exec.Command("rm", "-f", "/tmp/chaos-recovery-test").Run()
	return nil
}

func (cr *ChaosRunner) GenerateReport() {
	fmt.Printf("\n🎯 Chaos Engineering Report\n")
	fmt.Printf("═══════════════════════════\n\n")

	totalExperiments := len(cr.results)
	successfulExperiments := 0

	for name, result := range cr.results {
		if result.Success {
			successfulExperiments++
			fmt.Printf("✅ %s: PASSED (recovery: %v)\n", name, result.Recovery)
		} else {
			fmt.Printf("❌ %s: FAILED - %v\n", name, result.Error)
		}
	}

	resilienceScore := float64(successfulExperiments) / float64(totalExperiments) * 100

	fmt.Printf("\n📊 Summary:\n")
	fmt.Printf("   • Total Experiments: %d\n", totalExperiments)
	fmt.Printf("   • Successful: %d\n", successfulExperiments)
	fmt.Printf("   • Failed: %d\n", totalExperiments-successfulExperiments)
	fmt.Printf("   • Resilience Score: %.1f%%\n", resilienceScore)

	fmt.Printf("\n🏆 Assessment: ")
	if resilienceScore >= 90 {
		fmt.Printf("🎯 EXCELLENT - System shows exceptional resilience\n")
	} else if resilienceScore >= 75 {
		fmt.Printf("🟢 GOOD - System handles most failure scenarios well\n")
	} else if resilienceScore >= 50 {
		fmt.Printf("🟡 ACCEPTABLE - Some resilience gaps need attention\n")
	} else {
		fmt.Printf("🔴 NEEDS IMPROVEMENT - Critical resilience issues detected\n")
	}
}
```

### Task 4: Automated Test Reporting (5 minutes)

Create a test reporting system that integrates with CI/CD.

**File: `scripts/test-report.sh`**
```bash
#!/bin/bash

set -e

echo "🧪 Chinook Automated Test Report"
echo "===================================="

# Colors for output
GREEN='\033[0;32m'
RED='\033[0;31m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Test configuration
export TEST_DATABASE_URL="../resources/chinook_test.db"

# Create test report directory
mkdir -p reports

# Function to run tests with reporting
run_test_suite() {
    local suite_name=$1
    local test_path=$2
    
    echo -e "\n📋 Running $suite_name tests..."
    
    # Run tests with JSON output
    go test -v -json -coverprofile=reports/${suite_name}_coverage.out $test_path > reports/${suite_name}_results.json 2>&1
    
    # Parse results
    local pass_count=$(cat reports/${suite_name}_results.json | jq -r 'select(.Action=="pass" and .Test!=null) | .Test' | wc -l)
    local fail_count=$(cat reports/${suite_name}_results.json | jq -r 'select(.Action=="fail" and .Test!=null) | .Test' | wc -l)
    local total_count=$((pass_count + fail_count))
    
    if [ $fail_count -eq 0 ]; then
        echo -e "${GREEN}✅ $suite_name: $pass_count/$total_count tests passed${NC}"
    else
        echo -e "${RED}❌ $suite_name: $fail_count/$total_count tests failed${NC}"
        # Show failed tests
        cat reports/${suite_name}_results.json | jq -r 'select(.Action=="fail" and .Test!=null) | "   • " + .Test'
    fi
}

# Run test suites
echo "🚀 Starting test execution..."

run_test_suite "unit" "./internal/..."
run_test_suite "integration" "./tests/integration/..."
run_test_suite "api" "./tests/api/..."

# Generate combined coverage report
echo -e "\n📊 Generating coverage report..."
echo "mode: atomic" > reports/combined_coverage.out
tail -n +2 reports/*_coverage.out >> reports/combined_coverage.out

# Calculate overall coverage
go tool cover -func=reports/combined_coverage.out > reports/coverage_summary.txt
total_coverage=$(go tool cover -func=reports/combined_coverage.out | grep total | awk '{print $3}' | sed 's/%//')

echo -e "\n📈 Coverage Summary:"
echo "   • Total Coverage: $total_coverage%"

if (( $(echo "$total_coverage >= 90" | bc -l) )); then
    echo -e "   ${GREEN}🎯 Excellent coverage!${NC}"
elif (( $(echo "$total_coverage >= 80" | bc -l) )); then
    echo -e "   ${GREEN}✅ Good coverage${NC}"
elif (( $(echo "$total_coverage >= 70" | bc -l) )); then
    echo -e "   ${YELLOW}🟡 Acceptable coverage${NC}"
else
    echo -e "   ${RED}❌ Coverage needs improvement${NC}"
fi

# Generate HTML reports
go tool cover -html=reports/combined_coverage.out -o reports/coverage.html

# Create JUnit XML for CI integration
cat > reports/junit.xml << EOF
<?xml version="1.0" encoding="UTF-8"?>
<testsuites>
    <testsuite name="chinook Tests" tests="$(grep -c '"Action":"pass"' reports/*_results.json)" failures="$(grep -c '"Action":"fail"' reports/*_results.json)" time="0">
EOF

# Add test cases from JSON results
for json_file in reports/*_results.json; do
    suite_name=$(basename $json_file _results.json)
    cat $json_file | jq -r 'select(.Action=="pass" or .Action=="fail") | 
        "<testcase classname=\"'$suite_name'\" name=\"" + .Test + "\" time=\"0\">" +
        (if .Action=="fail" then "<failure message=\"Test failed\"></failure>" else "" end) +
        "</testcase>"' >> reports/junit.xml
done

cat >> reports/junit.xml << EOF
    </testsuite>
</testsuites>
EOF

echo -e "\n📁 Reports generated:"
echo "   • HTML Coverage: reports/coverage.html"
echo "   • JUnit XML: reports/junit.xml"
echo "   • JSON Results: reports/*_results.json"

echo -e "\n✅ Test reporting complete!"
```

Make the script executable:
```bash
chmod +x scripts/test-report.sh
```

## 💥 Deliberate Failure Points

Try these scenarios to test your testing infrastructure:

1. **Coverage Gaps**: Comment out tests and see how coverage analysis catches it
2. **Load Test Failures**: Reduce database connection limits and watch load tests fail
3. **Chaos Recovery**: Manually break something and verify chaos tests detect it
4. **CI Integration**: Push broken code and ensure automated tests catch it

## ✅ Victory Conditions

- [ ] Test coverage analysis shows >85% overall coverage
- [ ] Load tests successfully handle 100+ ops/second
- [ ] Chaos experiments show <30 second recovery times
- [ ] Automated test reports integrate with your CI system
- [ ] All failure scenarios are detected and handled properly

## 🔍 Further Exploration

- Implement contract testing with protobuf schemas
- Add performance regression testing
- Create visual test reporting dashboards
- Implement property-based testing for protobuf validation
- Add security penetration testing automation

## 🚨 Common Pitfalls

- **Coverage Theater**: High coverage numbers but poor test quality
- **Load Test Realism**: Testing with unrealistic data or patterns
- **Chaos Coordination**: Not coordinating chaos experiments with team
- **CI Dependencies**: Tests that depend on external services failing in CI

Ready for the performance optimization lab? This testing foundation will help you validate your optimizations! 🚀
