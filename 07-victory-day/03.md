# Lab 3: üîí Security & Compliance

**Duration**: 45 minutes  
**Difficulty**: Advanced  

## üéØ Objectives
- Implement authentication and authorization for your pipeline
- Add encryption for data at rest and in transit
- Create comprehensive audit logging and compliance reporting
- Perform security scanning and vulnerability assessment

## üìã Prerequisites
- Completed Lab 2 (optimized pipeline)
- OpenSSL for certificate generation
- Basic understanding of JWT and OAuth2

## üõ†Ô∏è Tasks

### Task 1: Authentication & Authorization (15 minutes)

Implement JWT-based authentication with role-based access control.

**File: `internal/auth/jwt_auth.go`**
```go
package auth

import (
	"context"
	"crypto/rsa"
	"crypto/x509"
	"encoding/pem"
	"fmt"
	"strings"
	"time"

	"github.com/golang-jwt/jwt/v5"
	"google.golang.org/grpc"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/metadata"
	"google.golang.org/grpc/status"
)

type Role string

const (
	RoleAdmin    Role = "admin"
	RoleOperator Role = "operator"
	RoleReadOnly Role = "readonly"
)

type Claims struct {
	UserID string   `json:"user_id"`
	Email  string   `json:"email"`
	Roles  []Role   `json:"roles"`
	jwt.RegisteredClaims
}

type JWTAuthenticator struct {
	privateKey *rsa.PrivateKey
	publicKey  *rsa.PublicKey
	issuer     string
}

func NewJWTAuthenticator(privateKeyPEM, publicKeyPEM []byte, issuer string) (*JWTAuthenticator, error) {
	// Parse private key
	privateBlock, _ := pem.Decode(privateKeyPEM)
	if privateBlock == nil {
		return nil, fmt.Errorf("failed to decode private key PEM")
	}

	privateKey, err := x509.ParsePKCS1PrivateKey(privateBlock.Bytes)
	if err != nil {
		return nil, fmt.Errorf("failed to parse private key: %w", err)
	}

	// Parse public key
	publicBlock, _ := pem.Decode(publicKeyPEM)
	if publicBlock == nil {
		return nil, fmt.Errorf("failed to decode public key PEM")
	}

	publicKeyInterface, err := x509.ParsePKIXPublicKey(publicBlock.Bytes)
	if err != nil {
		return nil, fmt.Errorf("failed to parse public key: %w", err)
	}

	publicKey, ok := publicKeyInterface.(*rsa.PublicKey)
	if !ok {
		return nil, fmt.Errorf("public key is not RSA")
	}

	return &JWTAuthenticator{
		privateKey: privateKey,
		publicKey:  publicKey,
		issuer:     issuer,
	}, nil
}

func (ja *JWTAuthenticator) GenerateToken(userID, email string, roles []Role) (string, error) {
	now := time.Now()
	claims := Claims{
		UserID: userID,
		Email:  email,
		Roles:  roles,
		RegisteredClaims: jwt.RegisteredClaims{
			Issuer:    ja.issuer,
			Subject:   userID,
			IssuedAt:  jwt.NewNumericDate(now),
			ExpiresAt: jwt.NewNumericDate(now.Add(24 * time.Hour)),
			NotBefore: jwt.NewNumericDate(now),
		},
	}

	token := jwt.NewWithClaims(jwt.SigningMethodRS256, claims)
	return token.SignedString(ja.privateKey)
}

func (ja *JWTAuthenticator) ValidateToken(tokenString string) (*Claims, error) {
	token, err := jwt.ParseWithClaims(tokenString, &Claims{}, func(token *jwt.Token) (interface{}, error) {
		if _, ok := token.Method.(*jwt.SigningMethodRSA); !ok {
			return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
		}
		return ja.publicKey, nil
	})

	if err != nil {
		return nil, fmt.Errorf("failed to parse token: %w", err)
	}

	if claims, ok := token.Claims.(*Claims); ok && token.Valid {
		return claims, nil
	}

	return nil, fmt.Errorf("invalid token claims")
}

func (ja *JWTAuthenticator) hasRole(userRoles []Role, requiredRole Role) bool {
	for _, role := range userRoles {
		if role == requiredRole || role == RoleAdmin {
			return true
		}
	}
	return false
}

// gRPC interceptor for authentication
func (ja *JWTAuthenticator) UnaryServerInterceptor() grpc.UnaryServerInterceptor {
	return func(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (interface{}, error) {
		// Skip auth for health checks
		if strings.HasSuffix(info.FullMethod, "Health") {
			return handler(ctx, req)
		}

		claims, err := ja.authenticateFromContext(ctx)
		if err != nil {
			return nil, status.Errorf(codes.Unauthenticated, "authentication failed: %v", err)
		}

		// Check authorization based on method
		if !ja.isAuthorized(claims, info.FullMethod) {
			return nil, status.Errorf(codes.PermissionDenied, "insufficient permissions")
		}

		// Add claims to context
		ctx = context.WithValue(ctx, "claims", claims)
		
		return handler(ctx, req)
	}
}

func (ja *JWTAuthenticator) authenticateFromContext(ctx context.Context) (*Claims, error) {
	md, ok := metadata.FromIncomingContext(ctx)
	if !ok {
		return nil, fmt.Errorf("no metadata found")
	}

	authHeaders := md.Get("authorization")
	if len(authHeaders) == 0 {
		return nil, fmt.Errorf("no authorization header")
	}

	authHeader := authHeaders[0]
	if !strings.HasPrefix(authHeader, "Bearer ") {
		return nil, fmt.Errorf("invalid authorization header format")
	}

	token := strings.TrimPrefix(authHeader, "Bearer ")
	return ja.ValidateToken(token)
}

func (ja *JWTAuthenticator) isAuthorized(claims *Claims, method string) bool {
	// Define method permissions
	permissions := map[string]Role{
		"/customer.v1.CustomerService/Create":      RoleOperator,
		"/customer.v1.CustomerService/Update":      RoleOperator,
		"/customer.v1.CustomerService/Delete":      RoleAdmin,
		"/customer.v1.CustomerService/Get":         RoleReadOnly,
		"/customer.v1.CustomerService/List":        RoleReadOnly,
		"/customer.v1.CustomerService/BatchCreate": RoleOperator,
	}

	requiredRole, exists := permissions[method]
	if !exists {
		// Default to admin for unknown methods
		requiredRole = RoleAdmin
	}

	return ja.hasRole(claims.Roles, requiredRole)
}
```

**File: `cmd/auth-demo/main.go`**
```go
package main

import (
	"crypto/rand"
	"crypto/rsa"
	"crypto/x509"
	"encoding/pem"
	"fmt"
	"log"

	"chinook/internal/auth"
)

func main() {
	fmt.Println("üîí Chinook Authentication Demo")
	fmt.Println("=================================")

	// Generate RSA key pair for demo
	privateKey, publicKey, err := generateKeyPair()
	if err != nil {
		log.Fatalf("Failed to generate key pair: %v", err)
	}

	// Create authenticator
	authenticator, err := auth.NewJWTAuthenticator(
		privateKey, publicKey, "chinook.com")
	if err != nil {
		log.Fatalf("Failed to create authenticator: %v", err)
	}

	// Demo different user scenarios
	demoUsers := []struct {
		userID string
		email  string
		roles  []auth.Role
	}{
		{"admin-001", "admin@chinook.com", []auth.Role{auth.RoleAdmin}},
		{"operator-001", "operator@chinook.com", []auth.Role{auth.RoleOperator}},
		{"readonly-001", "readonly@chinook.com", []auth.Role{auth.RoleReadOnly}},
		{"multi-role", "multi@chinook.com", []auth.Role{auth.RoleOperator, auth.RoleReadOnly}},
	}

	for _, user := range demoUsers {
		fmt.Printf("\nüë§ User: %s (%s)\n", user.email, user.roles)
		
		// Generate token
		token, err := authenticator.GenerateToken(user.userID, user.email, user.roles)
		if err != nil {
			fmt.Printf("‚ùå Failed to generate token: %v\n", err)
			continue
		}

		// Validate token
		claims, err := authenticator.ValidateToken(token)
		if err != nil {
			fmt.Printf("‚ùå Failed to validate token: %v\n", err)
			continue
		}

		fmt.Printf("‚úÖ Token valid for: %s\n", claims.Email)
		fmt.Printf("   Roles: %v\n", claims.Roles)
		fmt.Printf("   Expires: %s\n", claims.ExpiresAt.Time.Format("2006-01-02 15:04:05"))
	}
}

func generateKeyPair() ([]byte, []byte, error) {
	// Generate private key
	privateKey, err := rsa.GenerateKey(rand.Reader, 2048)
	if err != nil {
		return nil, nil, err
	}

	// Encode private key
	privateKeyDER := x509.MarshalPKCS1PrivateKey(privateKey)
	privateKeyPEM := pem.EncodeToMemory(&pem.Block{
		Type:  "RSA PRIVATE KEY",
		Bytes: privateKeyDER,
	})

	// Encode public key
	publicKeyDER, err := x509.MarshalPKIXPublicKey(&privateKey.PublicKey)
	if err != nil {
		return nil, nil, err
	}

	publicKeyPEM := pem.EncodeToMemory(&pem.Block{
		Type:  "PUBLIC KEY",
		Bytes: publicKeyDER,
	})

	return privateKeyPEM, publicKeyPEM, nil
}
```

### Task 2: Data Encryption (15 minutes)

Implement encryption for data at rest and in transit.

**File: `internal/crypto/encryption.go`**
```go
package crypto

import (
	"crypto/aes"
	"crypto/cipher"
	"crypto/rand"
	"crypto/sha256"
	"fmt"
	"io"

	"golang.org/x/crypto/pbkdf2"
	"google.golang.org/protobuf/proto"
	pb "chinook/proto/customer/v1"
)

type EncryptionService struct {
	key []byte
	gcm cipher.AEAD
}

func NewEncryptionService(password string, salt []byte) (*EncryptionService, error) {
	// Derive key from password using PBKDF2
	key := pbkdf2.Key([]byte(password), salt, 10000, 32, sha256.New)

	// Create AES cipher
	block, err := aes.NewCipher(key)
	if err != nil {
		return nil, fmt.Errorf("failed to create cipher: %w", err)
	}

	// Create GCM mode for authenticated encryption
	gcm, err := cipher.NewGCM(block)
	if err != nil {
		return nil, fmt.Errorf("failed to create GCM: %w", err)
	}

	return &EncryptionService{
		key: key,
		gcm: gcm,
	}, nil
}

// Encrypt protobuf message
func (es *EncryptionService) EncryptCustomer(customer *pb.Customer) ([]byte, error) {
	// Marshal protobuf to bytes
	data, err := proto.Marshal(customer)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal customer: %w", err)
	}

	return es.EncryptBytes(data)
}

// Decrypt to protobuf message
func (es *EncryptionService) DecryptCustomer(encryptedData []byte) (*pb.Customer, error) {
	data, err := es.DecryptBytes(encryptedData)
	if err != nil {
		return nil, err
	}

	var customer pb.Customer
	if err := proto.Unmarshal(data, &customer); err != nil {
		return nil, fmt.Errorf("failed to unmarshal customer: %w", err)
	}

	return &customer, nil
}

// Encrypt raw bytes
func (es *EncryptionService) EncryptBytes(data []byte) ([]byte, error) {
	// Generate random nonce
	nonce := make([]byte, es.gcm.NonceSize())
	if _, err := io.ReadFull(rand.Reader, nonce); err != nil {
		return nil, fmt.Errorf("failed to generate nonce: %w", err)
	}

	// Encrypt data
	ciphertext := es.gcm.Seal(nonce, nonce, data, nil)
	return ciphertext, nil
}

// Decrypt raw bytes
func (es *EncryptionService) DecryptBytes(encryptedData []byte) ([]byte, error) {
	nonceSize := es.gcm.NonceSize()
	if len(encryptedData) < nonceSize {
		return nil, fmt.Errorf("ciphertext too short")
	}

	// Extract nonce and ciphertext
	nonce, ciphertext := encryptedData[:nonceSize], encryptedData[nonceSize:]

	// Decrypt data
	plaintext, err := es.gcm.Open(nil, nonce, ciphertext, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to decrypt: %w", err)
	}

	return plaintext, nil
}

// Field-level encryption for sensitive data
func (es *EncryptionService) EncryptSensitiveFields(customer *pb.Customer) (*pb.Customer, error) {
	// Clone customer to avoid modifying original
	encrypted := proto.Clone(customer).(*pb.Customer)

	// Encrypt email
	if customer.Email != "" {
		encryptedEmail, err := es.EncryptBytes([]byte(customer.Email))
		if err != nil {
			return nil, fmt.Errorf("failed to encrypt email: %w", err)
		}
		encrypted.Email = string(encryptedEmail)
	}

	// Encrypt phone
	if customer.Phone != "" {
		encryptedPhone, err := es.EncryptBytes([]byte(customer.Phone))
		if err != nil {
			return nil, fmt.Errorf("failed to encrypt phone: %w", err)
		}
		encrypted.Phone = string(encryptedPhone)
	}

	return encrypted, nil
}

func (es *EncryptionService) DecryptSensitiveFields(customer *pb.Customer) (*pb.Customer, error) {
	// Clone customer to avoid modifying original
	decrypted := proto.Clone(customer).(*pb.Customer)

	// Decrypt email
	if customer.Email != "" {
		decryptedEmail, err := es.DecryptBytes([]byte(customer.Email))
		if err != nil {
			return nil, fmt.Errorf("failed to decrypt email: %w", err)
		}
		decrypted.Email = string(decryptedEmail)
	}

	// Decrypt phone
	if customer.Phone != "" {
		decryptedPhone, err := es.DecryptBytes([]byte(customer.Phone))
		if err != nil {
			return nil, fmt.Errorf("failed to decrypt phone: %w", err)
		}
		decrypted.Phone = string(decryptedPhone)
	}

	return decrypted, nil
}
```

**File: `internal/crypto/tls_config.go`**
```go
package crypto

import (
	"crypto/tls"
	"crypto/x509"
	"fmt"
	"io/ioutil"
)

type TLSConfig struct {
	CertFile   string
	KeyFile    string
	CAFile     string
	ServerName string
}

func (tc *TLSConfig) LoadServerConfig() (*tls.Config, error) {
	cert, err := tls.LoadX509KeyPair(tc.CertFile, tc.KeyFile)
	if err != nil {
		return nil, fmt.Errorf("failed to load key pair: %w", err)
	}

	config := &tls.Config{
		Certificates: []tls.Certificate{cert},
		ClientAuth:   tls.RequireAndVerifyClientCert,
		MinVersion:   tls.VersionTLS12,
		CipherSuites: []uint16{
			tls.TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,
			tls.TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305,
			tls.TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,
			tls.TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305,
		},
	}

	if tc.CAFile != "" {
		caCert, err := ioutil.ReadFile(tc.CAFile)
		if err != nil {
			return nil, fmt.Errorf("failed to read CA file: %w", err)
		}

		caCertPool := x509.NewCertPool()
		caCertPool.AppendCertsFromPEM(caCert)
		config.ClientCAs = caCertPool
	}

	return config, nil
}

func (tc *TLSConfig) LoadClientConfig() (*tls.Config, error) {
	config := &tls.Config{
		ServerName: tc.ServerName,
		MinVersion: tls.VersionTLS12,
	}

	if tc.CertFile != "" && tc.KeyFile != "" {
		cert, err := tls.LoadX509KeyPair(tc.CertFile, tc.KeyFile)
		if err != nil {
			return nil, fmt.Errorf("failed to load client key pair: %w", err)
		}
		config.Certificates = []tls.Certificate{cert}
	}

	if tc.CAFile != "" {
		caCert, err := ioutil.ReadFile(tc.CAFile)
		if err != nil {
			return nil, fmt.Errorf("failed to read CA file: %w", err)
		}

		caCertPool := x509.NewCertPool()
		caCertPool.AppendCertsFromPEM(caCert)
		config.RootCAs = caCertPool
	}

	return config, nil
}
```

### Task 3: Audit Logging & Compliance (10 minutes)

Create comprehensive audit logging for compliance requirements.

**File: `internal/audit/logger.go`**
```go
package audit

import (
	"context"
	"encoding/json"
	"fmt"
	"time"

	"go.uber.org/zap"
	"go.uber.org/zap/zapcore"
	"chinook/internal/auth"
)

type AuditEvent struct {
	Timestamp   time.Time              `json:"timestamp"`
	EventID     string                 `json:"event_id"`
	UserID      string                 `json:"user_id"`
	Action      string                 `json:"action"`
	Resource    string                 `json:"resource"`
	ResourceID  string                 `json:"resource_id,omitempty"`
	Result      string                 `json:"result"`
	Details     map[string]interface{} `json:"details,omitempty"`
	IP          string                 `json:"ip_address,omitempty"`
	UserAgent   string                 `json:"user_agent,omitempty"`
	Duration    time.Duration          `json:"duration_ms"`
	Compliance  ComplianceInfo         `json:"compliance"`
}

type ComplianceInfo struct {
	DataClassification string   `json:"data_classification"`
	RetentionPeriod    string   `json:"retention_period"`
	Regulations        []string `json:"regulations"`
}

type AuditLogger struct {
	logger *zap.Logger
}

func NewAuditLogger(logFile string) (*AuditLogger, error) {
	config := zap.NewProductionConfig()
	config.OutputPaths = []string{logFile}
	config.EncoderConfig.TimeKey = "timestamp"
	config.EncoderConfig.EncodeTime = zapcore.ISO8601TimeEncoder

	logger, err := config.Build()
	if err != nil {
		return nil, fmt.Errorf("failed to create audit logger: %w", err)
	}

	return &AuditLogger{
		logger: logger,
	}, nil
}

func (al *AuditLogger) LogEvent(ctx context.Context, event AuditEvent) {
	// Set timestamp if not provided
	if event.Timestamp.IsZero() {
		event.Timestamp = time.Now().UTC()
	}

	// Extract user info from context
	if claims, ok := ctx.Value("claims").(*auth.Claims); ok {
		event.UserID = claims.UserID
	}

	// Generate unique event ID
	if event.EventID == "" {
		event.EventID = fmt.Sprintf("%d-%s", 
			event.Timestamp.UnixNano(), event.Action)
	}

	// Log as structured JSON
	eventJSON, _ := json.Marshal(event)
	al.logger.Info("audit_event", zap.String("event", string(eventJSON)))
}

func (al *AuditLogger) LogCustomerAccess(ctx context.Context, action, customerID, result string, duration time.Duration) {
	event := AuditEvent{
		Action:     action,
		Resource:   "customer",
		ResourceID: customerID,
		Result:     result,
		Duration:   duration,
		Compliance: ComplianceInfo{
			DataClassification: "PII",
			RetentionPeriod:    "7_years",
			Regulations:        []string{"GDPR", "CCPA"},
		},
	}

	al.LogEvent(ctx, event)
}

func (al *AuditLogger) LogDataProcessing(ctx context.Context, operation, dataType string, recordCount int, result string) {
	event := AuditEvent{
		Action:   operation,
		Resource: "data_processing",
		Result:   result,
		Details: map[string]interface{}{
			"data_type":    dataType,
			"record_count": recordCount,
		},
		Compliance: ComplianceInfo{
			DataClassification: "PII",
			RetentionPeriod:    "7_years",
			Regulations:        []string{"GDPR", "CCPA", "SOX"},
		},
	}

	al.LogEvent(ctx, event)
}

func (al *AuditLogger) LogSecurityEvent(ctx context.Context, eventType, details, severity string) {
	event := AuditEvent{
		Action:   "security_event",
		Resource: "security",
		Result:   eventType,
		Details: map[string]interface{}{
			"event_type": eventType,
			"details":    details,
			"severity":   severity,
		},
		Compliance: ComplianceInfo{
			DataClassification: "security",
			RetentionPeriod:    "indefinite",
			Regulations:        []string{"SOX", "HIPAA"},
		},
	}

	al.LogEvent(ctx, event)
}

// Compliance report generator
func (al *AuditLogger) GenerateComplianceReport(startTime, endTime time.Time, regulation string) (*ComplianceReport, error) {
	// This would typically query a structured audit log store
	// For demo purposes, we'll create a sample report
	
	report := &ComplianceReport{
		Period:     fmt.Sprintf("%s to %s", startTime.Format("2006-01-02"), endTime.Format("2006-01-02")),
		Regulation: regulation,
		Summary: ComplianceSummary{
			TotalEvents:        1000,
			AccessEvents:       800,
			ModificationEvents: 150,
			DeletionEvents:     50,
			SecurityEvents:     5,
		},
		Violations: []ComplianceViolation{
			{
				Type:        "unauthorized_access_attempt",
				Count:       3,
				Severity:    "medium",
				Description: "Failed authentication attempts detected",
			},
		},
	}

	return report, nil
}

type ComplianceReport struct {
	Period     string                  `json:"period"`
	Regulation string                  `json:"regulation"`
	Summary    ComplianceSummary       `json:"summary"`
	Violations []ComplianceViolation   `json:"violations"`
}

type ComplianceSummary struct {
	TotalEvents        int `json:"total_events"`
	AccessEvents       int `json:"access_events"`
	ModificationEvents int `json:"modification_events"`
	DeletionEvents     int `json:"deletion_events"`
	SecurityEvents     int `json:"security_events"`
}

type ComplianceViolation struct {
	Type        string `json:"type"`
	Count       int    `json:"count"`
	Severity    string `json:"severity"`
	Description string `json:"description"`
}
```

### Task 4: Security Scanning (5 minutes)

Create automated security scanning for vulnerabilities.

**File: `scripts/security-scan.sh`**
```bash
#!/bin/bash

set -e

echo "üîí Chinook Security Scan"
echo "============================"

# Colors for output
GREEN='\033[0;32m'
RED='\033[0;31m'
YELLOW='\033[1;33m'
NC='\033[0m'

# Create security reports directory
mkdir -p security-reports

echo -e "\nüîç 1. Dependency Vulnerability Scan..."
if command -v govulncheck &> /dev/null; then
    govulncheck ./... > security-reports/vulnerabilities.txt 2>&1
    if [ $? -eq 0 ]; then
        echo -e "${GREEN}‚úÖ No known vulnerabilities found${NC}"
    else
        echo -e "${RED}‚ùå Vulnerabilities detected - check security-reports/vulnerabilities.txt${NC}"
    fi
else
    echo -e "${YELLOW}‚ö†Ô∏è  govulncheck not installed - run: go install golang.org/x/vuln/cmd/govulncheck@latest${NC}"
fi

echo -e "\nüîë 2. Static Security Analysis..."
if command -v gosec &> /dev/null; then
    gosec -fmt json -out security-reports/gosec.json ./...
    if [ $? -eq 0 ]; then
        echo -e "${GREEN}‚úÖ Static analysis passed${NC}"
    else
        echo -e "${YELLOW}‚ö†Ô∏è  Security issues found - check security-reports/gosec.json${NC}"
    fi
else
    echo -e "${YELLOW}‚ö†Ô∏è  gosec not installed - run: go install github.com/securecodewarrior/gosec/v2/cmd/gosec@latest${NC}"
fi

echo -e "\nüîê 3. TLS Configuration Check..."
# Check for secure TLS configuration
grep -r "tls.Config" . --include="*.go" | grep -E "(MinVersion|CipherSuites)" > security-reports/tls-config.txt
if [ -s security-reports/tls-config.txt ]; then
    echo -e "${GREEN}‚úÖ TLS configuration found${NC}"
else
    echo -e "${RED}‚ùå No secure TLS configuration detected${NC}"
fi

echo -e "\nüóùÔ∏è  4. Secrets Scan..."
# Basic secrets detection
grep -r -E "(password|secret|key|token).*(=|:)" . --include="*.go" --include="*.yaml" --include="*.json" \
    | grep -v "example\|test\|demo" > security-reports/potential-secrets.txt || true

if [ -s security-reports/potential-secrets.txt ]; then
    echo -e "${YELLOW}‚ö†Ô∏è  Potential secrets found - review security-reports/potential-secrets.txt${NC}"
else
    echo -e "${GREEN}‚úÖ No obvious secrets in code${NC}"
fi

echo -e "\nüìã 5. Security Checklist..."
cat > security-reports/security-checklist.md << EOF
# Security Checklist

## Authentication & Authorization
- [ ] JWT tokens properly signed and validated
- [ ] Role-based access control implemented
- [ ] Token expiration properly configured
- [ ] Secure token storage

## Encryption
- [ ] Data encrypted at rest
- [ ] Data encrypted in transit (TLS 1.2+)
- [ ] Strong cipher suites configured
- [ ] Proper key management

## Input Validation
- [ ] All inputs validated and sanitized
- [ ] SQL injection prevention
- [ ] XSS prevention measures
- [ ] CSRF protection

## Audit & Monitoring
- [ ] Comprehensive audit logging
- [ ] Security event monitoring
- [ ] Compliance reporting
- [ ] Log integrity protection

## Infrastructure Security
- [ ] Network segmentation
- [ ] Firewall configuration
- [ ] Regular security updates
- [ ] Vulnerability scanning

## Data Privacy
- [ ] GDPR compliance measures
- [ ] Data retention policies
- [ ] Right to be forgotten
- [ ] Privacy by design
EOF

echo -e "\nüìä Security Scan Summary:"
echo -e "   ‚Ä¢ Vulnerability Report: security-reports/vulnerabilities.txt"
echo -e "   ‚Ä¢ Static Analysis: security-reports/gosec.json"
echo -e "   ‚Ä¢ TLS Config: security-reports/tls-config.txt"
echo -e "   ‚Ä¢ Secrets Scan: security-reports/potential-secrets.txt"
echo -e "   ‚Ä¢ Security Checklist: security-reports/security-checklist.md"

echo -e "\nüéØ Next Steps:"
echo -e "   1. Review all security reports"
echo -e "   2. Fix any identified vulnerabilities"
echo -e "   3. Complete security checklist"
echo -e "   4. Schedule regular security scans"

echo -e "\n‚úÖ Security scan complete!"
```

Make the script executable:
```bash
chmod +x scripts/security-scan.sh
```

## üí• Deliberate Failure Points

Test these security scenarios:

1. **Token Expiration**: Set very short JWT expiration and test renewal
2. **Encryption Failures**: Use wrong keys and observe error handling
3. **Authorization Bypass**: Try accessing endpoints without proper roles
4. **Audit Log Tampering**: Attempt to modify audit logs

## ‚úÖ Victory Conditions

- [ ] JWT authentication working with proper token validation
- [ ] Role-based authorization enforcing access controls
- [ ] Data encryption protecting sensitive information
- [ ] Comprehensive audit logging capturing all events
- [ ] Security scans showing no critical vulnerabilities

## üîç Further Exploration

- Implement OAuth2/OIDC integration
- Add rate limiting and DDoS protection
- Create security incident response procedures
- Implement data loss prevention (DLP)
- Add penetration testing automation

Ready for the final lab? Let's deploy your secure, tested, and optimized pipeline! üöÄ
