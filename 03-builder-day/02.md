# Lab 2: üîÑ Error Handling Patterns

Master Go's error handling philosophy! Build robust error types, chains, and recovery patterns that make debugging a breeze.

## üéØ Objectives
- Create custom error types with context
- Master error wrapping and unwrapping
- Implement error recovery patterns
- Build structured error logging

## üõ†Ô∏è Tasks

### Step 1: Create Custom Error Types
Create `internal/errors/errors.go`:

```go
package errors

import (
	"errors"
	"fmt"
	"net/http"
)

// Domain error types - implement error interface
type CustomerError struct {
	Code    string
	Message string
	Field   string
	Value   interface{}
	Cause   error
}

func (e CustomerError) Error() string {
	if e.Field != "" {
		return fmt.Sprintf("%s: %s (field: %s, value: %v)", e.Code, e.Message, e.Field, e.Value)
	}
	return fmt.Sprintf("%s: %s", e.Code, e.Message)
}

func (e CustomerError) Unwrap() error {
	return e.Cause
}

// Sentinel errors - predefined error values
var (
	ErrCustomerNotFound     = errors.New("customer not found")
	ErrCustomerExists       = errors.New("customer already exists")
	ErrInvalidEmail         = errors.New("invalid email format")
	ErrInvalidPhone         = errors.New("invalid phone number")
	ErrDatabaseConnection   = errors.New("database connection failed")
	ErrCacheUnavailable     = errors.New("cache service unavailable")
	ErrRateLimitExceeded    = errors.New("rate limit exceeded")
	ErrUnauthorized         = errors.New("unauthorized access")
	ErrServiceUnavailable   = errors.New("service temporarily unavailable")
)

// Error codes for structured error handling
const (
	CodeValidation    = "VALIDATION_ERROR"
	CodeNotFound      = "NOT_FOUND"
	CodeConflict      = "CONFLICT"
	CodeInternal      = "INTERNAL_ERROR"
	CodeRateLimit     = "RATE_LIMIT"
	CodeUnauthorized  = "UNAUTHORIZED"
	CodeUnavailable   = "UNAVAILABLE"
)

// Error constructors
func NewValidationError(field string, value interface{}, message string) error {
	return CustomerError{
		Code:    CodeValidation,
		Message: message,
		Field:   field,
		Value:   value,
	}
}

func NewNotFoundError(resource string, id interface{}) error {
	return CustomerError{
		Code:    CodeNotFound,
		Message: fmt.Sprintf("%s not found", resource),
		Field:   "id",
		Value:   id,
	}
}

func NewConflictError(resource string, field string, value interface{}) error {
	return CustomerError{
		Code:    CodeConflict,
		Message: fmt.Sprintf("%s already exists", resource),
		Field:   field,
		Value:   value,
	}
}

func NewInternalError(operation string, cause error) error {
	return CustomerError{
		Code:    CodeInternal,
		Message: fmt.Sprintf("internal error during %s", operation),
		Cause:   cause,
	}
}

// Error classification helpers
func IsValidationError(err error) bool {
	var customerErr CustomerError
	return errors.As(err, &customerErr) && customerErr.Code == CodeValidation
}

func IsNotFoundError(err error) bool {
	if errors.Is(err, ErrCustomerNotFound) {
		return true
	}
	var customerErr CustomerError
	return errors.As(err, &customerErr) && customerErr.Code == CodeNotFound
}

func IsConflictError(err error) bool {
	var customerErr CustomerError
	return errors.As(err, &customerErr) && customerErr.Code == CodeConflict
}

func IsTemporaryError(err error) bool {
	if errors.Is(err, ErrCacheUnavailable) || errors.Is(err, ErrServiceUnavailable) {
		return true
	}
	var customerErr CustomerError
	return errors.As(err, &customerErr) && customerErr.Code == CodeUnavailable
}

// HTTP status mapping
func HTTPStatusFromError(err error) int {
	if IsValidationError(err) {
		return http.StatusBadRequest
	}
	if IsNotFoundError(err) {
		return http.StatusNotFound
	}
	if IsConflictError(err) {
		return http.StatusConflict
	}
	if errors.Is(err, ErrUnauthorized) {
		return http.StatusUnauthorized
	}
	if errors.Is(err, ErrRateLimitExceeded) {
		return http.StatusTooManyRequests
	}
	if IsTemporaryError(err) {
		return http.StatusServiceUnavailable
	}
	return http.StatusInternalServerError
}

// ErrorResponse for API responses
type ErrorResponse struct {
	Error   string            `json:"error"`
	Code    string            `json:"code"`
	Message string            `json:"message"`
	Field   string            `json:"field,omitempty"`
	Value   interface{}       `json:"value,omitempty"`
	Details map[string]string `json:"details,omitempty"`
}

// ToErrorResponse converts error to API response
func ToErrorResponse(err error) ErrorResponse {
	var customerErr CustomerError
	if errors.As(err, &customerErr) {
		return ErrorResponse{
			Error:   customerErr.Error(),
			Code:    customerErr.Code,
			Message: customerErr.Message,
			Field:   customerErr.Field,
			Value:   customerErr.Value,
		}
	}

	// Handle known sentinel errors
	if errors.Is(err, ErrCustomerNotFound) {
		return ErrorResponse{
			Error:   err.Error(),
			Code:    CodeNotFound,
			Message: "Customer not found",
		}
	}

	// Default case
	return ErrorResponse{
		Error:   err.Error(),
		Code:    CodeInternal,
		Message: "An unexpected error occurred",
	}
}
```

### Step 2: Implement Error Recovery Patterns
Create `internal/service/error_handling_service.go`:

```go
package service

import (
	"context"
	"fmt"
	"time"

	"example.com/chinook/data-pipeline/internal/domain"
	customerrors "example.com/chinook/data-pipeline/internal/errors"
)

// ErrorHandlingService demonstrates error recovery patterns
type ErrorHandlingService struct {
	repo      domain.CustomerRepository
	cache     domain.Cache
	logger    domain.Logger
	metrics   domain.Metrics
}

func NewErrorHandlingService(
	repo domain.CustomerRepository,
	cache domain.Cache,
	logger domain.Logger,
	metrics domain.Metrics,
) *ErrorHandlingService {
	return &ErrorHandlingService{
		repo:    repo,
		cache:   cache,
		logger:  logger,
		metrics: metrics,
	}
}

// GetCustomerWithRetry demonstrates retry pattern with exponential backoff
func (s *ErrorHandlingService) GetCustomerWithRetry(ctx context.Context, id int64) (*domain.Customer, error) {
	const maxRetries = 3
	baseDelay := 100 * time.Millisecond

	var lastErr error
	for attempt := 0; attempt < maxRetries; attempt++ {
		customer, err := s.getCustomerAttempt(ctx, id)
		if err == nil {
			if attempt > 0 {
				s.logger.Info("customer retrieval succeeded after retry",
					domain.Field{Key: "customer_id", Value: id},
					domain.Field{Key: "attempt", Value: attempt + 1})
			}
			return customer, nil
		}

		lastErr = err

		// Don't retry for non-recoverable errors
		if !customerrors.IsTemporaryError(err) {
			s.logger.Error("non-recoverable error, not retrying",
				domain.Field{Key: "customer_id", Value: id},
				domain.Field{Key: "error", Value: err})
			return nil, fmt.Errorf("failed to get customer %d: %w", id, err)
		}

		// Exponential backoff
		delay := baseDelay * time.Duration(1<<attempt)
		s.logger.Warn("retrying customer retrieval",
			domain.Field{Key: "customer_id", Value: id},
			domain.Field{Key: "attempt", Value: attempt + 1},
			domain.Field{Key: "delay", Value: delay},
			domain.Field{Key: "error", Value: err})

		s.metrics.Counter("customer_get_retries").Inc()

		select {
		case <-ctx.Done():
			return nil, fmt.Errorf("context cancelled while retrying: %w", ctx.Err())
		case <-time.After(delay):
			// Continue to next attempt
		}
	}

	s.metrics.Counter("customer_get_max_retries_exceeded").Inc()
	return nil, fmt.Errorf("max retries exceeded for customer %d: %w", id, lastErr)
}

// getCustomerAttempt performs a single attempt to get customer
func (s *ErrorHandlingService) getCustomerAttempt(ctx context.Context, id int64) (*domain.Customer, error) {
	// Try cache first (fallback pattern)
	if customer, err := s.getFromCache(ctx, id); err == nil {
		return customer, nil
	}

	// Fallback to repository
	customer, err := s.repo.GetCustomer(ctx, id)
	if err != nil {
		return nil, fmt.Errorf("repository get failed: %w", err)
	}

	// Try to populate cache (best effort)
	if err := s.setInCache(ctx, id, customer); err != nil {
		s.logger.Warn("failed to cache customer",
			domain.Field{Key: "customer_id", Value: id},
			domain.Field{Key: "error", Value: err})
		// Don't fail the request for cache errors
	}

	return customer, nil
}

// CreateCustomerWithValidation demonstrates comprehensive validation with detailed errors
func (s *ErrorHandlingService) CreateCustomerWithValidation(ctx context.Context, customer *domain.Customer) (*domain.Customer, error) {
	// Comprehensive validation with specific errors
	if err := s.validateCustomerForCreation(customer); err != nil {
		s.metrics.Counter("customer_create_validation_errors").Inc()
		return nil, fmt.Errorf("customer validation failed: %w", err)
	}

	// Check for existing customer (conflict detection)
	if existing, err := s.repo.GetCustomer(ctx, customer.ID); err == nil && existing != nil {
		return nil, customerrors.NewConflictError("customer", "id", customer.ID)
	}

	// Attempt creation with proper error wrapping
	created, err := s.repo.CreateCustomer(ctx, customer)
	if err != nil {
		s.logger.Error("customer creation failed",
			domain.Field{Key: "customer_email", Value: customer.Email},
			domain.Field{Key: "error", Value: err})
		s.metrics.Counter("customer_create_errors").Inc()
		return nil, customerrors.NewInternalError("customer creation", err)
	}

	s.metrics.Counter("customer_create_success").Inc()
	s.logger.Info("customer created successfully",
		domain.Field{Key: "customer_id", Value: created.ID},
		domain.Field{Key: "customer_email", Value: created.Email})

	return created, nil
}

// validateCustomerForCreation performs detailed validation
func (s *ErrorHandlingService) validateCustomerForCreation(customer *domain.Customer) error {
	if customer == nil {
		return customerrors.NewValidationError("customer", nil, "customer cannot be nil")
	}

	if customer.Name == "" {
		return customerrors.NewValidationError("name", customer.Name, "name is required")
	}

	if len(customer.Name) < 2 {
		return customerrors.NewValidationError("name", customer.Name, "name must be at least 2 characters")
	}

	if len(customer.Name) > 100 {
		return customerrors.NewValidationError("name", customer.Name, "name must be less than 100 characters")
	}

	if customer.Email == "" {
		return customerrors.NewValidationError("email", customer.Email, "email is required")
	}

	if !s.isValidEmail(customer.Email) {
		return customerrors.NewValidationError("email", customer.Email, "email format is invalid")
	}

	return nil
}

// Circuit breaker pattern for external dependencies
type CircuitBreakerState int

const (
	Closed CircuitBreakerState = iota
	Open
	HalfOpen
)

type CircuitBreaker struct {
	maxFailures int
	timeout     time.Duration
	failures    int
	lastFailure time.Time
	state       CircuitBreakerState
}

func NewCircuitBreaker(maxFailures int, timeout time.Duration) *CircuitBreaker {
	return &CircuitBreaker{
		maxFailures: maxFailures,
		timeout:     timeout,
		state:       Closed,
	}
}

func (cb *CircuitBreaker) Call(fn func() error) error {
	switch cb.state {
	case Open:
		if time.Since(cb.lastFailure) > cb.timeout {
			cb.state = HalfOpen
			cb.failures = 0
		} else {
			return customerrors.ErrServiceUnavailable
		}
	case HalfOpen:
		// Allow one request through
	case Closed:
		// Normal operation
	}

	err := fn()
	if err != nil {
		cb.onFailure()
		return err
	}

	cb.onSuccess()
	return nil
}

func (cb *CircuitBreaker) onFailure() {
	cb.failures++
	cb.lastFailure = time.Now()
	
	if cb.failures >= cb.maxFailures {
		cb.state = Open
	}
}

func (cb *CircuitBreaker) onSuccess() {
	cb.failures = 0
	cb.state = Closed
}

// GetCustomerWithCircuitBreaker demonstrates circuit breaker pattern
func (s *ErrorHandlingService) GetCustomerWithCircuitBreaker(ctx context.Context, id int64, cb *CircuitBreaker) (*domain.Customer, error) {
	var customer *domain.Customer
	var err error

	cbErr := cb.Call(func() error {
		customer, err = s.repo.GetCustomer(ctx, id)
		return err
	})

	if cbErr != nil {
		if cbErr == customerrors.ErrServiceUnavailable {
			s.logger.Warn("circuit breaker open, request rejected",
				domain.Field{Key: "customer_id", Value: id})
			s.metrics.Counter("customer_get_circuit_breaker_open").Inc()
		}
		return nil, cbErr
	}

	return customer, err
}

// Helper methods
func (s *ErrorHandlingService) getFromCache(ctx context.Context, id int64) (*domain.Customer, error) {
	key := fmt.Sprintf("customer:%d", id)
	data, err := s.cache.Get(ctx, key)
	if err != nil {
		return nil, fmt.Errorf("cache get failed: %w", err)
	}

	// Deserialize customer (simplified)
	customer := &domain.Customer{ID: id, Name: "Cached Customer", Email: "cached@example.com"}
	return customer, nil
}

func (s *ErrorHandlingService) setInCache(ctx context.Context, id int64, customer *domain.Customer) error {
	key := fmt.Sprintf("customer:%d", id)
	data := []byte(fmt.Sprintf("%d:%s:%s", customer.ID, customer.Name, customer.Email))
	return s.cache.Set(ctx, key, data, 5*time.Minute)
}

func (s *ErrorHandlingService) isValidEmail(email string) bool {
	// Simplified email validation
	return len(email) > 5 && contains(email, "@") && contains(email, ".")
}

func contains(s, substr string) bool {
	for i := 0; i <= len(s)-len(substr); i++ {
		if s[i:i+len(substr)] == substr {
			return true
		}
	}
	return false
}
```

### Step 3: Test Error Handling Patterns
Create `cmd/error-handling-test/main.go`:

```go
package main

import (
	"context"
	"fmt"
	"log"
	"time"

	"example.com/chinook/data-pipeline/internal/domain"
	customerrors "example.com/chinook/data-pipeline/internal/errors"
	"example.com/chinook/data-pipeline/internal/mocks"
	"example.com/chinook/data-pipeline/internal/service"
)

func main() {
	fmt.Println("üîÑ Error Handling Patterns Laboratory")
	fmt.Println("====================================")

	testCustomErrorTypes()
	testErrorClassification()
	testRetryPattern()
	testCircuitBreaker()
	testValidationErrors()
}

func testCustomErrorTypes() {
	fmt.Println("\nüè∑Ô∏è Testing Custom Error Types")

	// Test validation error
	validationErr := customerrors.NewValidationError("email", "invalid-email", "email format is invalid")
	fmt.Printf("Validation error: %s\n", validationErr)
	fmt.Printf("Is validation error: %t\n", customerrors.IsValidationError(validationErr))

	// Test not found error
	notFoundErr := customerrors.NewNotFoundError("customer", 123)
	fmt.Printf("Not found error: %s\n", notFoundErr)
	fmt.Printf("Is not found error: %t\n", customerrors.IsNotFoundError(notFoundErr))

	// Test error wrapping
	originalErr := fmt.Errorf("database connection timeout")
	wrappedErr := customerrors.NewInternalError("customer retrieval", originalErr)
	fmt.Printf("Wrapped error: %s\n", wrappedErr)
	
	// Test error unwrapping
	if unwrapped := errors.Unwrap(wrappedErr); unwrapped != nil {
		fmt.Printf("Unwrapped error: %s\n", unwrapped)
	}

	// Test HTTP status mapping
	fmt.Printf("HTTP status for validation error: %d\n", customerrors.HTTPStatusFromError(validationErr))
	fmt.Printf("HTTP status for not found error: %d\n", customerrors.HTTPStatusFromError(notFoundErr))
}

func testErrorClassification() {
	fmt.Println("\nüîç Testing Error Classification")

	errors := []error{
		customerrors.ErrCustomerNotFound,
		customerrors.ErrInvalidEmail,
		customerrors.ErrCacheUnavailable,
		customerrors.NewValidationError("name", "", "name is required"),
		customerrors.NewConflictError("customer", "email", "test@example.com"),
	}

	for _, err := range errors {
		fmt.Printf("\nError: %s\n", err)
		fmt.Printf("  Is validation: %t\n", customerrors.IsValidationError(err))
		fmt.Printf("  Is not found: %t\n", customerrors.IsNotFoundError(err))
		fmt.Printf("  Is conflict: %t\n", customerrors.IsConflictError(err))
		fmt.Printf("  Is temporary: %t\n", customerrors.IsTemporaryError(err))
		fmt.Printf("  HTTP status: %d\n", customerrors.HTTPStatusFromError(err))
		
		response := customerrors.ToErrorResponse(err)
		fmt.Printf("  API response: %+v\n", response)
	}
}

func testRetryPattern() {
	fmt.Println("\nüîÑ Testing Retry Pattern")

	// Create service with mock that fails then succeeds
	repo := mocks.NewMockCustomerRepository()
	cache := mocks.NewMockCache()
	logger := mocks.NewMockLogger()
	metrics := mocks.NewMockMetrics()

	service := service.NewErrorHandlingService(repo, cache, logger, metrics)
	ctx := context.Background()

	// Test successful retry after temporary failure
	repo.GetError = customerrors.ErrServiceUnavailable
	go func() {
		// Clear error after short delay to simulate recovery
		time.Sleep(300 * time.Millisecond)
		repo.GetError = nil
	}()

	start := time.Now()
	customer, err := service.GetCustomerWithRetry(ctx, 1)
	duration := time.Since(start)

	if err != nil {
		fmt.Printf("‚ùå Retry failed: %v\n", err)
	} else {
		fmt.Printf("‚úÖ Retry succeeded after %v\n", duration)
		fmt.Printf("   Customer: %+v\n", customer)
	}

	// Check log messages
	messages := logger.GetMessages()
	fmt.Printf("   Log messages during retry: %d\n", len(messages))
	for _, msg := range messages {
		if msg.Level == "WARN" || msg.Level == "INFO" {
			fmt.Printf("   %s: %s\n", msg.Level, msg.Message)
		}
	}
}

func testCircuitBreaker() {
	fmt.Println("\n‚ö° Testing Circuit Breaker Pattern")

	// Create circuit breaker with low threshold for testing
	cb := service.NewCircuitBreaker(2, 1*time.Second)

	// Create service with failing repo
	repo := mocks.NewMockCustomerRepository()
	cache := mocks.NewMockCache()
	logger := mocks.NewMockLogger()
	metrics := mocks.NewMockMetrics()

	service := service.NewErrorHandlingService(repo, cache, logger, metrics)
	ctx := context.Background()

	// Cause failures to open circuit breaker
	repo.GetError = fmt.Errorf("database connection failed")

	fmt.Println("   Causing failures to open circuit breaker...")
	for i := 0; i < 3; i++ {
		_, err := service.GetCustomerWithCircuitBreaker(ctx, 1, cb)
		if err != nil {
			fmt.Printf("   Attempt %d: %v\n", i+1, err)
		}
	}

	// Test that circuit breaker is now open
	fmt.Println("   Testing circuit breaker open state...")
	_, err := service.GetCustomerWithCircuitBreaker(ctx, 1, cb)
	if err == customerrors.ErrServiceUnavailable {
		fmt.Printf("‚úÖ Circuit breaker correctly rejected request\n")
	} else {
		fmt.Printf("‚ùå Circuit breaker failed to reject request: %v\n", err)
	}

	// Wait for circuit breaker to go to half-open, then test recovery
	fmt.Println("   Waiting for circuit breaker recovery...")
	time.Sleep(1100 * time.Millisecond)
	
	// Fix the "database"
	repo.GetError = nil
	
	_, err = service.GetCustomerWithCircuitBreaker(ctx, 1, cb)
	if err == nil {
		fmt.Printf("‚úÖ Circuit breaker allowed request after recovery\n")
	} else {
		fmt.Printf("‚ùå Circuit breaker failed recovery: %v\n", err)
	}
}

func testValidationErrors() {
	fmt.Println("\n‚úÖ Testing Validation Errors")

	repo := mocks.NewMockCustomerRepository()
	cache := mocks.NewMockCache()
	logger := mocks.NewMockLogger()
	metrics := mocks.NewMockMetrics()

	service := service.NewErrorHandlingService(repo, cache, logger, metrics)
	ctx := context.Background()

	// Test various validation scenarios
	testCases := []struct {
		name     string
		customer *domain.Customer
		expectErr bool
	}{
		{
			name:      "nil customer",
			customer:  nil,
			expectErr: true,
		},
		{
			name:      "empty name",
			customer:  &domain.Customer{Name: "", Email: "test@example.com"},
			expectErr: true,
		},
		{
			name:      "short name",
			customer:  &domain.Customer{Name: "A", Email: "test@example.com"},
			expectErr: true,
		},
		{
			name:      "long name",
			customer:  &domain.Customer{Name: string(make([]byte, 101)), Email: "test@example.com"},
			expectErr: true,
		},
		{
			name:      "empty email",
			customer:  &domain.Customer{Name: "Valid Name", Email: ""},
			expectErr: true,
		},
		{
			name:      "invalid email",
			customer:  &domain.Customer{Name: "Valid Name", Email: "invalid-email"},
			expectErr: true,
		},
		{
			name:      "valid customer",
			customer:  &domain.Customer{Name: "Valid Name", Email: "valid@example.com"},
			expectErr: false,
		},
	}

	for _, tc := range testCases {
		fmt.Printf("\n   Testing: %s\n", tc.name)
		
		_, err := service.CreateCustomerWithValidation(ctx, tc.customer)
		
		if tc.expectErr && err != nil {
			fmt.Printf("   ‚úÖ Expected error: %v\n", err)
			if customerrors.IsValidationError(err) {
				fmt.Printf("   ‚úÖ Correctly classified as validation error\n")
			}
		} else if !tc.expectErr && err == nil {
			fmt.Printf("   ‚úÖ Valid customer accepted\n")
		} else if tc.expectErr && err == nil {
			fmt.Printf("   ‚ùå Expected error but got none\n")
		} else {
			fmt.Printf("   ‚ùå Unexpected error: %v\n", err)
		}
	}

	fmt.Println("\nüéâ Error handling testing completed!")
}
```

## üí• Deliberate Failure: Error Recovery

### Break It:
1. Set mock repo to always fail and test retry exhaustion
2. Create invalid customers and see detailed validation errors
3. Test circuit breaker behavior under load

### Fix It:
The error handling patterns should gracefully handle all failure scenarios with proper logging and metrics.

## ‚úÖ Victory Conditions

- [ ] Custom error types provide detailed context
- [ ] Error classification works correctly
- [ ] Retry patterns handle temporary failures
- [ ] Circuit breaker protects against cascading failures
- [ ] Validation errors are comprehensive and helpful

---

**Next**: Head to `lab03/` for dependency injection mastery! üß¨