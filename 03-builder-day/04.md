# Lab 4: 🧪 Testing Architecture

Master comprehensive testing in Go! Build table-driven tests, integration helpers, and performance benchmarks for bulletproof services.

## 🎯 Objectives
- Create comprehensive test suites with table-driven tests
- Build integration test helpers and fixtures
- Implement performance benchmarks
- Design testable service architectures

## 🛠️ Tasks

### Step 1: Create Test Utilities
Create `internal/testing/utilities.go`:

```go
package testing

import (
	"context"
	"fmt"
	"reflect"
	"testing"
	"time"

	"example.com/chinook/data-pipeline/internal/domain"
)

// TestContext provides common testing utilities
type TestContext struct {
	t       *testing.T
	cleanup []func()
}

// NewTestContext creates a new test context
func NewTestContext(t *testing.T) *TestContext {
	return &TestContext{
		t:       t,
		cleanup: make([]func(), 0),
	}
}

// Cleanup runs all cleanup functions
func (tc *TestContext) Cleanup() {
	for i := len(tc.cleanup) - 1; i >= 0; i-- {
		tc.cleanup[i]()
	}
}

// AddCleanup adds a cleanup function
func (tc *TestContext) AddCleanup(fn func()) {
	tc.cleanup = append(tc.cleanup, fn)
}

// AssertNoError fails the test if err is not nil
func (tc *TestContext) AssertNoError(err error) {
	tc.t.Helper()
	if err != nil {
		tc.t.Fatalf("unexpected error: %v", err)
	}
}

// AssertError fails the test if err is nil
func (tc *TestContext) AssertError(err error) {
	tc.t.Helper()
	if err == nil {
		tc.t.Fatal("expected error but got nil")
	}
}

// AssertEqual fails the test if expected != actual
func (tc *TestContext) AssertEqual(expected, actual interface{}) {
	tc.t.Helper()
	if !reflect.DeepEqual(expected, actual) {
		tc.t.Fatalf("expected %+v, got %+v", expected, actual)
	}
}

// AssertNotEqual fails the test if expected == actual
func (tc *TestContext) AssertNotEqual(expected, actual interface{}) {
	tc.t.Helper()
	if reflect.DeepEqual(expected, actual) {
		tc.t.Fatalf("expected %+v to not equal %+v", expected, actual)
	}
}

// AssertTrue fails the test if condition is false
func (tc *TestContext) AssertTrue(condition bool, message string) {
	tc.t.Helper()
	if !condition {
		tc.t.Fatalf("assertion failed: %s", message)
	}
}

// AssertContains fails the test if slice doesn't contain item
func (tc *TestContext) AssertContains(slice []interface{}, item interface{}) {
	tc.t.Helper()
	for _, s := range slice {
		if reflect.DeepEqual(s, item) {
			return
		}
	}
	tc.t.Fatalf("slice %+v does not contain %+v", slice, item)
}

// WithTimeout creates a context with timeout for tests
func (tc *TestContext) WithTimeout(timeout time.Duration) (context.Context, context.CancelFunc) {
	return context.WithTimeout(context.Background(), timeout)
}

// CustomerBuilder provides a fluent API for building test customers
type CustomerBuilder struct {
	customer *domain.Customer
}

// NewCustomerBuilder creates a new customer builder
func NewCustomerBuilder() *CustomerBuilder {
	return &CustomerBuilder{
		customer: &domain.Customer{
			ID:    1,
			Name:  "Test Customer",
			Email: "test@example.com",
		},
	}
}

// WithID sets the customer ID
func (b *CustomerBuilder) WithID(id int64) *CustomerBuilder {
	b.customer.ID = id
	return b
}

// WithName sets the customer name
func (b *CustomerBuilder) WithName(name string) *CustomerBuilder {
	b.customer.Name = name
	return b
}

// WithEmail sets the customer email
func (b *CustomerBuilder) WithEmail(email string) *CustomerBuilder {
	b.customer.Email = email
	return b
}

// Build returns the built customer
func (b *CustomerBuilder) Build() *domain.Customer {
	// Return a copy to prevent test interference
	return &domain.Customer{
		ID:    b.customer.ID,
		Name:  b.customer.Name,
		Email: b.customer.Email,
	}
}

// TestEventCollector collects events for testing
type TestEventCollector struct {
	events []domain.Event
}

// NewTestEventCollector creates a new event collector
func NewTestEventCollector() *TestEventCollector {
	return &TestEventCollector{
		events: make([]domain.Event, 0),
	}
}

// PublishEvent implements domain.EventPublisher for testing
func (c *TestEventCollector) PublishEvent(ctx context.Context, event domain.Event) error {
	c.events = append(c.events, event)
	return nil
}

// GetEvents returns all collected events
func (c *TestEventCollector) GetEvents() []domain.Event {
	return c.events
}

// GetEventsByType returns events of a specific type
func (c *TestEventCollector) GetEventsByType(eventType string) []domain.Event {
	var filtered []domain.Event
	for _, event := range c.events {
		if event.Type == eventType {
			filtered = append(filtered, event)
		}
	}
	return filtered
}

// HasEvent checks if an event type was published
func (c *TestEventCollector) HasEvent(eventType string) bool {
	return len(c.GetEventsByType(eventType)) > 0
}

// Clear clears all collected events
func (c *TestEventCollector) Clear() {
	c.events = c.events[:0]
}

// TestFixtures provides common test data
type TestFixtures struct{}

// ValidCustomers returns a set of valid test customers
func (f *TestFixtures) ValidCustomers() []*domain.Customer {
	return []*domain.Customer{
		{ID: 1, Name: "Alice Smith", Email: "alice@example.com"},
		{ID: 2, Name: "Bob Johnson", Email: "bob@example.com"},
		{ID: 3, Name: "Charlie Brown", Email: "charlie@example.com"},
	}
}

// InvalidCustomers returns customers with various validation issues
func (f *TestFixtures) InvalidCustomers() []struct {
	Name     string
	Customer *domain.Customer
	Error    string
} {
	return []struct {
		Name     string
		Customer *domain.Customer
		Error    string
	}{
		{
			Name:     "nil customer",
			Customer: nil,
			Error:    "customer cannot be nil",
		},
		{
			Name:     "empty name",
			Customer: &domain.Customer{Name: "", Email: "test@example.com"},
			Error:    "name is required",
		},
		{
			Name:     "short name",
			Customer: &domain.Customer{Name: "A", Email: "test@example.com"},
			Error:    "name must be at least 2 characters",
		},
		{
			Name:     "empty email",
			Customer: &domain.Customer{Name: "Valid Name", Email: ""},
			Error:    "email is required",
		},
		{
			Name:     "invalid email",
			Customer: &domain.Customer{Name: "Valid Name", Email: "invalid-email"},
			Error:    "email format is invalid",
		},
	}
}

// PerformanceTestConfig holds configuration for performance tests
type PerformanceTestConfig struct {
	Operations    int
	Concurrency   int
	Timeout       time.Duration
	WarmupRounds  int
}

// DefaultPerformanceConfig returns default performance test configuration
func DefaultPerformanceConfig() *PerformanceTestConfig {
	return &PerformanceTestConfig{
		Operations:   1000,
		Concurrency:  10,
		Timeout:      30 * time.Second,
		WarmupRounds: 2,
	}
}

// TestDatabase provides database testing utilities
type TestDatabase struct {
	// In a real implementation, this would manage test database connections
	// For now, we'll use mock implementations
}

// NewTestDatabase creates a new test database
func NewTestDatabase() *TestDatabase {
	return &TestDatabase{}
}

// Setup sets up test database schema and data
func (db *TestDatabase) Setup() error {
	// In real implementation: create tables, insert test data
	return nil
}

// Teardown cleans up test database
func (db *TestDatabase) Teardown() error {
	// In real implementation: drop tables, clean up
	return nil
}

// Transaction runs a function in a database transaction (rolled back)
func (db *TestDatabase) Transaction(fn func() error) error {
	// In real implementation: start transaction, run fn, rollback
	return fn()
}
```

### Step 2: Create Comprehensive Service Tests
Create `internal/service/customer_service_test.go`:

```go
package service

import (
	"context"
	"fmt"
	"testing"
	"time"

	"example.com/chinook/data-pipeline/internal/domain"
	customerrors "example.com/chinook/data-pipeline/internal/errors"
	"example.com/chinook/data-pipeline/internal/mocks"
	testutil "example.com/chinook/data-pipeline/internal/testing"
)

func TestCustomerService_GetCustomer(t *testing.T) {
	tests := []struct {
		name           string
		customerID     int64
		setupMocks     func(*mocks.MockCustomerRepository, *mocks.MockCache)
		expectedResult *domain.Customer
		expectedError  string
	}{
		{
			name:       "successful get from repository",
			customerID: 1,
			setupMocks: func(repo *mocks.MockCustomerRepository, cache *mocks.MockCache) {
				// Cache miss, repository hit
				cache.GetError = fmt.Errorf("cache miss")
				// Repository will return default mock customer
			},
			expectedResult: &domain.Customer{ID: 1, Name: "Test Customer", Email: "test@example.com"},
			expectedError:  "",
		},
		{
			name:       "successful get from cache",
			customerID: 1,
			setupMocks: func(repo *mocks.MockCustomerRepository, cache *mocks.MockCache) {
				// Cache hit - no repository call needed
				// Cache mock will return success by default
			},
			expectedResult: &domain.Customer{ID: 1, Name: "Cached Customer", Email: "cached@example.com"},
			expectedError:  "",
		},
		{
			name:       "customer not found",
			customerID: 999,
			setupMocks: func(repo *mocks.MockCustomerRepository, cache *mocks.MockCache) {
				cache.GetError = fmt.Errorf("cache miss")
				repo.GetError = customerrors.ErrCustomerNotFound
			},
			expectedResult: nil,
			expectedError:  "failed to get customer 999",
		},
		{
			name:       "invalid customer ID",
			customerID: -1,
			setupMocks: func(repo *mocks.MockCustomerRepository, cache *mocks.MockCache) {
				// No setup needed - validation should fail first
			},
			expectedResult: nil,
			expectedError:  "invalid customer ID",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tc := testutil.NewTestContext(t)
			defer tc.Cleanup()

			// Setup dependencies
			repo := mocks.NewMockCustomerRepository()
			eventPub := mocks.NewMockEventPublisher()
			cache := mocks.NewMockCache()
			logger := mocks.NewMockLogger()
			metrics := mocks.NewMockMetrics()

			// Apply test-specific mock setup
			tt.setupMocks(repo, cache)

			// Create service
			service := NewCustomerService(repo, eventPub, cache, logger, metrics)

			// Execute test
			ctx, cancel := tc.WithTimeout(5 * time.Second)
			defer cancel()

			result, err := service.GetCustomer(ctx, &domain.GetCustomerRequest{Id: tt.customerID})

			// Verify results
			if tt.expectedError != "" {
				tc.AssertError(err)
				tc.AssertTrue(contains(err.Error(), tt.expectedError), 
					fmt.Sprintf("error should contain '%s', got '%s'", tt.expectedError, err.Error()))
			} else {
				tc.AssertNoError(err)
				tc.AssertNotEqual(nil, result)
				tc.AssertEqual(tt.expectedResult.ID, result.Customer.ID)
			}
		})
	}
}

func TestCustomerService_CreateCustomer(t *testing.T) {
	fixtures := &testutil.TestFixtures{}

	t.Run("valid customers", func(t *testing.T) {
		validCustomers := fixtures.ValidCustomers()

		for _, customer := range validCustomers {
			t.Run(fmt.Sprintf("create customer %s", customer.Name), func(t *testing.T) {
				tc := testutil.NewTestContext(t)
				defer tc.Cleanup()

				// Setup
				repo := mocks.NewMockCustomerRepository()
				eventCollector := testutil.NewTestEventCollector()
				cache := mocks.NewMockCache()
				logger := mocks.NewMockLogger()
				metrics := mocks.NewMockMetrics()

				service := NewCustomerService(repo, eventCollector, cache, logger, metrics)

				// Execute
				ctx, cancel := tc.WithTimeout(5 * time.Second)
				defer cancel()

				request := &domain.CreateCustomerRequest{Customer: customer}
				result, err := service.CreateCustomer(ctx, request)

				// Verify
				tc.AssertNoError(err)
				tc.AssertNotEqual(nil, result)
				tc.AssertNotEqual(int64(0), result.Customer.ID)
				tc.AssertEqual(customer.Name, result.Customer.Name)
				tc.AssertEqual(customer.Email, result.Customer.Email)

				// Verify event was published
				tc.AssertTrue(eventCollector.HasEvent("customer.created"), 
					"customer.created event should be published")
			})
		}
	})

	t.Run("invalid customers", func(t *testing.T) {
		invalidCustomers := fixtures.InvalidCustomers()

		for _, testCase := range invalidCustomers {
			t.Run(testCase.Name, func(t *testing.T) {
				tc := testutil.NewTestContext(t)
				defer tc.Cleanup()

				// Setup
				repo := mocks.NewMockCustomerRepository()
				eventCollector := testutil.NewTestEventCollector()
				cache := mocks.NewMockCache()
				logger := mocks.NewMockLogger()
				metrics := mocks.NewMockMetrics()

				service := NewCustomerService(repo, eventCollector, cache, logger, metrics)

				// Execute
				ctx, cancel := tc.WithTimeout(5 * time.Second)
				defer cancel()

				request := &domain.CreateCustomerRequest{Customer: testCase.Customer}
				result, err := service.CreateCustomer(ctx, request)

				// Verify
				tc.AssertError(err)
				tc.AssertEqual((*domain.CreateCustomerResponse)(nil), result)
				tc.AssertTrue(contains(err.Error(), testCase.Error),
					fmt.Sprintf("error should contain '%s', got '%s'", testCase.Error, err.Error()))

				// Verify no event was published for invalid customers
				tc.AssertTrue(!eventCollector.HasEvent("customer.created"),
					"no event should be published for invalid customers")
			})
		}
	})
}

func TestCustomerService_ConcurrentAccess(t *testing.T) {
	tc := testutil.NewTestContext(t)
	defer tc.Cleanup()

	// Setup
	repo := mocks.NewMockCustomerRepository()
	eventCollector := testutil.NewTestEventCollector()
	cache := mocks.NewMockCache()
	logger := mocks.NewMockLogger()
	metrics := mocks.NewMockMetrics()

	service := NewCustomerService(repo, eventCollector, cache, logger, metrics)

	// Test concurrent customer creation
	const numGoroutines = 10
	const customersPerGoroutine = 5

	results := make(chan error, numGoroutines)
	ctx := context.Background()

	for i := 0; i < numGoroutines; i++ {
		go func(goroutineID int) {
			for j := 0; j < customersPerGoroutine; j++ {
				customer := testutil.NewCustomerBuilder().
					WithName(fmt.Sprintf("Customer-%d-%d", goroutineID, j)).
					WithEmail(fmt.Sprintf("customer-%d-%d@example.com", goroutineID, j)).
					Build()

				request := &domain.CreateCustomerRequest{Customer: customer}
				_, err := service.CreateCustomer(ctx, request)
				if err != nil {
					results <- err
					return
				}
			}
			results <- nil
		}(i)
	}

	// Wait for all goroutines to complete
	for i := 0; i < numGoroutines; i++ {
		err := <-results
		tc.AssertNoError(err)
	}

	// Verify all events were published
	events := eventCollector.GetEventsByType("customer.created")
	expectedEvents := numGoroutines * customersPerGoroutine
	tc.AssertEqual(expectedEvents, len(events))
}

// Benchmark tests
func BenchmarkCustomerService_GetCustomer(b *testing.B) {
	// Setup
	repo := mocks.NewMockCustomerRepository()
	eventPub := mocks.NewMockEventPublisher()
	cache := mocks.NewMockCache()
	logger := mocks.NewMockLogger()
	metrics := mocks.NewMockMetrics()

	service := NewCustomerService(repo, eventPub, cache, logger, metrics)
	ctx := context.Background()
	request := &domain.GetCustomerRequest{Id: 1}

	// Benchmark
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		_, err := service.GetCustomer(ctx, request)
		if err != nil {
			b.Fatal(err)
		}
	}
}

func BenchmarkCustomerService_CreateCustomer(b *testing.B) {
	// Setup
	repo := mocks.NewMockCustomerRepository()
	eventPub := mocks.NewMockEventPublisher()
	cache := mocks.NewMockCache()
	logger := mocks.NewMockLogger()
	metrics := mocks.NewMockMetrics()

	service := NewCustomerService(repo, eventPub, cache, logger, metrics)
	ctx := context.Background()

	// Benchmark
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		customer := testutil.NewCustomerBuilder().
			WithName(fmt.Sprintf("Benchmark Customer %d", i)).
			WithEmail(fmt.Sprintf("benchmark%d@example.com", i)).
			Build()

		request := &domain.CreateCustomerRequest{Customer: customer}
		_, err := service.CreateCustomer(ctx, request)
		if err != nil {
			b.Fatal(err)
		}
	}
}

func BenchmarkCustomerService_CreateCustomer_Parallel(b *testing.B) {
	// Setup
	repo := mocks.NewMockCustomerRepository()
	eventPub := mocks.NewMockEventPublisher()
	cache := mocks.NewMockCache()
	logger := mocks.NewMockLogger()
	metrics := mocks.NewMockMetrics()

	service := NewCustomerService(repo, eventPub, cache, logger, metrics)
	ctx := context.Background()

	// Parallel benchmark
	b.ResetTimer()
	b.RunParallel(func(pb *testing.PB) {
		i := 0
		for pb.Next() {
			customer := testutil.NewCustomerBuilder().
				WithName(fmt.Sprintf("Parallel Customer %d", i)).
				WithEmail(fmt.Sprintf("parallel%d@example.com", i)).
				Build()

			request := &domain.CreateCustomerRequest{Customer: customer}
			_, err := service.CreateCustomer(ctx, request)
			if err != nil {
				b.Fatal(err)
			}
			i++
		}
	})
}

// Helper functions
func contains(str, substr string) bool {
	return len(str) >= len(substr) && 
		   str[:len(substr)] == substr ||
		   (len(str) > len(substr) && containsHelper(str, substr))
}

func containsHelper(str, substr string) bool {
	for i := 1; i <= len(str)-len(substr); i++ {
		if str[i:i+len(substr)] == substr {
			return true
		}
	}
	return false
}
```

### Step 3: Create Integration Test Suite
Create `internal/integration/integration_test.go`:

```go
package integration

import (
	"context"
	"testing"
	"time"

	"example.com/chinook/data-pipeline/internal/config"
	"example.com/chinook/data-pipeline/internal/container"
	"example.com/chinook/data-pipeline/internal/domain"
	testutil "example.com/chinook/data-pipeline/internal/testing"
)

// IntegrationTestSuite provides integration testing capabilities
type IntegrationTestSuite struct {
	container *container.Container
	config    *config.Config
	cleanup   []func()
}

func NewIntegrationTestSuite(t *testing.T) *IntegrationTestSuite {
	// Load test configuration
	loader := config.NewEnvironmentConfigLoader()
	cfg, err := loader.Load()
	if err != nil {
		t.Fatalf("failed to load config: %v", err)
	}

	// Override config for testing
	cfg.Cache.Type = "memory"
	cfg.Logging.Level = "debug"

	// Create container
	cont := container.NewContainer(cfg)
	if err := cont.Build(); err != nil {
		t.Fatalf("failed to build container: %v", err)
	}

	suite := &IntegrationTestSuite{
		container: cont,
		config:    cfg,
		cleanup:   make([]func(), 0),
	}

	// Add cleanup for container shutdown
	suite.addCleanup(func() {
		ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
		defer cancel()
		cont.Shutdown(ctx)
	})

	return suite
}

func (suite *IntegrationTestSuite) addCleanup(fn func()) {
	suite.cleanup = append(suite.cleanup, fn)
}

func (suite *IntegrationTestSuite) Cleanup() {
	for i := len(suite.cleanup) - 1; i >= 0; i-- {
		suite.cleanup[i]()
	}
}

func TestIntegration_CustomerService_FullWorkflow(t *testing.T) {
	suite := NewIntegrationTestSuite(t)
	defer suite.Cleanup()

	tc := testutil.NewTestContext(t)
	defer tc.Cleanup()

	customerService := suite.container.CustomerService()
	ctx, cancel := tc.WithTimeout(30 * time.Second)
	defer cancel()

	// Test full customer lifecycle
	t.Run("create and retrieve customer", func(t *testing.T) {
		// Create customer
		customer := testutil.NewCustomerBuilder().
			WithName("Integration Test Customer").
			WithEmail("integration@test.com").
			Build()

		createReq := &domain.CreateCustomerRequest{Customer: customer}
		createResp, err := customerService.CreateCustomer(ctx, createReq)
		tc.AssertNoError(err)
		tc.AssertNotEqual(nil, createResp)

		createdID := createResp.Customer.ID
		tc.AssertTrue(createdID > 0, "created customer should have positive ID")

		// Retrieve customer
		getReq := &domain.GetCustomerRequest{Id: createdID}
		getResp, err := customerService.GetCustomer(ctx, getReq)
		tc.AssertNoError(err)
		tc.AssertNotEqual(nil, getResp)
		tc.AssertEqual(customer.Name, getResp.Customer.Name)
		tc.AssertEqual(customer.Email, getResp.Customer.Email)
	})

	t.Run("list customers", func(t *testing.T) {
		// Create multiple customers
		for i := 0; i < 5; i++ {
			customer := testutil.NewCustomerBuilder().
				WithName(fmt.Sprintf("List Test Customer %d", i)).
				WithEmail(fmt.Sprintf("listtest%d@example.com", i)).
				Build()

			createReq := &domain.CreateCustomerRequest{Customer: customer}
			_, err := customerService.CreateCustomer(ctx, createReq)
			tc.AssertNoError(err)
		}

		// List customers
		listReq := &domain.ListCustomersRequest{
			PageSize: 10,
		}
		listResp, err := customerService.ListCustomers(ctx, listReq)
		tc.AssertNoError(err)
		tc.AssertNotEqual(nil, listResp)
		tc.AssertTrue(len(listResp.Customers) >= 5, 
			"should have at least 5 customers")
	})
}

func TestIntegration_HealthCheck(t *testing.T) {
	suite := NewIntegrationTestSuite(t)
	defer suite.Cleanup()

	tc := testutil.NewTestContext(t)
	defer tc.Cleanup()

	ctx, cancel := tc.WithTimeout(10 * time.Second)
	defer cancel()

	// Test health check
	err := suite.container.HealthCheck(ctx)
	tc.AssertNoError(err)
}

func TestIntegration_ConcurrentOperations(t *testing.T) {
	suite := NewIntegrationTestSuite(t)
	defer suite.Cleanup()

	tc := testutil.NewTestContext(t)
	defer tc.Cleanup()

	customerService := suite.container.CustomerService()

	// Test concurrent customer operations
	const numWorkers = 5
	const operationsPerWorker = 10

	results := make(chan error, numWorkers)
	ctx := context.Background()

	for worker := 0; worker < numWorkers; worker++ {
		go func(workerID int) {
			for op := 0; op < operationsPerWorker; op++ {
				// Create customer
				customer := testutil.NewCustomerBuilder().
					WithName(fmt.Sprintf("Concurrent Customer %d-%d", workerID, op)).
					WithEmail(fmt.Sprintf("concurrent%d%d@example.com", workerID, op)).
					Build()

				createReq := &domain.CreateCustomerRequest{Customer: customer}
				createResp, err := customerService.CreateCustomer(ctx, createReq)
				if err != nil {
					results <- err
					return
				}

				// Immediately retrieve the created customer
				getReq := &domain.GetCustomerRequest{Id: createResp.Customer.ID}
				_, err = customerService.GetCustomer(ctx, getReq)
				if err != nil {
					results <- err
					return
				}
			}
			results <- nil
		}(worker)
	}

	// Wait for all workers to complete
	for i := 0; i < numWorkers; i++ {
		err := <-results
		tc.AssertNoError(err)
	}
}

// Performance integration tests
func TestIntegration_Performance(t *testing.T) {
	if testing.Short() {
		t.Skip("skipping performance test in short mode")
	}

	suite := NewIntegrationTestSuite(t)
	defer suite.Cleanup()

	tc := testutil.NewTestContext(t)
	defer tc.Cleanup()

	customerService := suite.container.CustomerService()
	ctx := context.Background()

	config := testutil.DefaultPerformanceConfig()

	t.Run("create customer performance", func(t *testing.T) {
		start := time.Now()

		for i := 0; i < config.Operations; i++ {
			customer := testutil.NewCustomerBuilder().
				WithName(fmt.Sprintf("Perf Customer %d", i)).
				WithEmail(fmt.Sprintf("perf%d@example.com", i)).
				Build()

			createReq := &domain.CreateCustomerRequest{Customer: customer}
			_, err := customerService.CreateCustomer(ctx, createReq)
			tc.AssertNoError(err)
		}

		duration := time.Since(start)
		opsPerSecond := float64(config.Operations) / duration.Seconds()

		t.Logf("Created %d customers in %v (%.2f ops/sec)", 
			config.Operations, duration, opsPerSecond)

		// Performance assertions
		tc.AssertTrue(opsPerSecond > 100, 
			fmt.Sprintf("performance too slow: %.2f ops/sec (expected > 100)", opsPerSecond))
	})

	t.Run("get customer performance", func(t *testing.T) {
		// First create a customer to retrieve
		customer := testutil.NewCustomerBuilder().Build()
		createReq := &domain.CreateCustomerRequest{Customer: customer}
		createResp, err := customerService.CreateCustomer(ctx, createReq)
		tc.AssertNoError(err)

		customerID := createResp.Customer.ID

		// Performance test
		start := time.Now()

		for i := 0; i < config.Operations; i++ {
			getReq := &domain.GetCustomerRequest{Id: customerID}
			_, err := customerService.GetCustomer(ctx, getReq)
			tc.AssertNoError(err)
		}

		duration := time.Since(start)
		opsPerSecond := float64(config.Operations) / duration.Seconds()

		t.Logf("Retrieved customer %d times in %v (%.2f ops/sec)", 
			config.Operations, duration, opsPerSecond)

		// Get operations should be faster than create
		tc.AssertTrue(opsPerSecond > 500, 
			fmt.Sprintf("get performance too slow: %.2f ops/sec (expected > 500)", opsPerSecond))
	})
}
```

### Step 4: Create Test Runner
Create `cmd/testing-demo/main.go`:

```go
package main

import (
	"context"
	"fmt"
	"log"
	"testing"
	"time"

	"example.com/chinook/data-pipeline/internal/config"
	"example.com/chinook/data-pipeline/internal/container"
	"example.com/chinook/data-pipeline/internal/domain"
	"example.com/chinook/data-pipeline/internal/mocks"
	"example.com/chinook/data-pipeline/internal/service"
	testutil "example.com/chinook/data-pipeline/internal/testing"
)

func main() {
	fmt.Println("🧪 Testing Architecture Laboratory")
	fmt.Println("=================================")

	demonstrateTestUtilities()
	demonstrateTableDrivenTests()
	demonstrateIntegrationTesting()
	demonstratePerformanceTesting()
}

func demonstrateTestUtilities() {
	fmt.Println("\n🔧 Testing Utilities Demo")

	// Demonstrate test context (simulated)
	fmt.Println("   Test context provides:")
	fmt.Println("   ✅ Automatic cleanup management")
	fmt.Println("   ✅ Common assertion helpers")
	fmt.Println("   ✅ Timeout context creation")

	// Demonstrate customer builder
	customer := testutil.NewCustomerBuilder().
		WithID(123).
		WithName("Demo Customer").
		WithEmail("demo@example.com").
		Build()

	fmt.Printf("   Built test customer: %+v\n", customer)

	// Demonstrate event collector
	eventCollector := testutil.NewTestEventCollector()
	event := domain.Event{
		Type: "customer.created",
		Data: customer,
		Timestamp: time.Now(),
	}

	eventCollector.PublishEvent(context.Background(), event)
	fmt.Printf("   Collected %d events\n", len(eventCollector.GetEvents()))
	fmt.Printf("   Has customer.created event: %t\n", eventCollector.HasEvent("customer.created"))

	// Demonstrate test fixtures
	fixtures := &testutil.TestFixtures{}
	validCustomers := fixtures.ValidCustomers()
	invalidCustomers := fixtures.InvalidCustomers()

	fmt.Printf("   Test fixtures provide %d valid and %d invalid customers\n", 
		len(validCustomers), len(invalidCustomers))
}

func demonstrateTableDrivenTests() {
	fmt.Println("\n📊 Table-Driven Tests Demo")

	// Simulate table-driven test structure
	testCases := []struct {
		name          string
		input         *domain.Customer
		expectSuccess bool
		expectedError string
	}{
		{
			name:          "valid customer",
			input:         &domain.Customer{Name: "Valid", Email: "valid@example.com"},
			expectSuccess: true,
		},
		{
			name:          "empty name",
			input:         &domain.Customer{Name: "", Email: "valid@example.com"},
			expectSuccess: false,
			expectedError: "name is required",
		},
		{
			name:          "invalid email",
			input:         &domain.Customer{Name: "Valid", Email: "invalid"},
			expectSuccess: false,
			expectedError: "email format is invalid",
		},
	}

	// Setup service for testing
	repo := mocks.NewMockCustomerRepository()
	eventPub := mocks.NewMockEventPublisher()
	cache := mocks.NewMockCache()
	logger := mocks.NewMockLogger()
	metrics := mocks.NewMockMetrics()

	errorService := service.NewErrorHandlingService(repo, cache, logger, metrics)
	ctx := context.Background()

	fmt.Println("   Running table-driven validation tests:")

	for _, tc := range testCases {
		fmt.Printf("\n   Test: %s\n", tc.name)

		_, err := errorService.CreateCustomerWithValidation(ctx, tc.input)

		if tc.expectSuccess {
			if err == nil {
				fmt.Printf("   ✅ Passed: No error as expected\n")
			} else {
				fmt.Printf("   ❌ Failed: Unexpected error: %v\n", err)
			}
		} else {
			if err != nil && contains(err.Error(), tc.expectedError) {
				fmt.Printf("   ✅ Passed: Got expected error containing '%s'\n", tc.expectedError)
			} else {
				fmt.Printf("   ❌ Failed: Expected error containing '%s', got: %v\n", tc.expectedError, err)
			}
		}
	}
}

func demonstrateIntegrationTesting() {
	fmt.Println("\n🔗 Integration Testing Demo")

	// Create a full integration test environment
	loader := config.NewEnvironmentConfigLoader()
	cfg, err := loader.Load()
	if err != nil {
		log.Printf("Failed to load config: %v", err)
		return
	}

	// Override for testing
	cfg.Cache.Type = "memory"

	// Build container
	container := container.NewContainer(cfg)
	if err := container.Build(); err != nil {
		log.Printf("Failed to build container: %v", err)
		return
	}

	defer func() {
		ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
		defer cancel()
		container.Shutdown(ctx)
	}()

	fmt.Println("   Integration test environment created:")

	// Test health check
	ctx := context.Background()
	if err := container.HealthCheck(ctx); err != nil {
		fmt.Printf("   ❌ Health check failed: %v\n", err)
	} else {
		fmt.Printf("   ✅ Health check passed\n")
	}

	// Test service integration
	customerService := container.CustomerService()
	customer := testutil.NewCustomerBuilder().
		WithName("Integration Test Customer").
		WithEmail("integration@test.com").
		Build()

	createReq := &domain.CreateCustomerRequest{Customer: customer}
	createResp, err := customerService.CreateCustomer(ctx, createReq)
	if err != nil {
		fmt.Printf("   ❌ Customer creation failed: %v\n", err)
	} else {
		fmt.Printf("   ✅ Customer created with ID: %d\n", createResp.Customer.ID)

		// Test retrieval
		getReq := &domain.GetCustomerRequest{Id: createResp.Customer.ID}
		getResp, err := customerService.GetCustomer(ctx, getReq)
		if err != nil {
			fmt.Printf("   ❌ Customer retrieval failed: %v\n", err)
		} else {
			fmt.Printf("   ✅ Customer retrieved: %s\n", getResp.Customer.Name)
		}
	}
}

func demonstratePerformanceTesting() {
	fmt.Println("\n⚡ Performance Testing Demo")

	// Setup for performance testing
	repo := mocks.NewMockCustomerRepository()
	eventPub := mocks.NewMockEventPublisher()
	cache := mocks.NewMockCache()
	logger := mocks.NewMockLogger()
	metrics := mocks.NewMockMetrics()

	service := service.NewCustomerService(repo, eventPub, cache, logger, metrics)
	ctx := context.Background()

	// Performance test: customer creation
	const numOperations = 1000
	start := time.Now()

	for i := 0; i < numOperations; i++ {
		customer := testutil.NewCustomerBuilder().
			WithName(fmt.Sprintf("Perf Customer %d", i)).
			WithEmail(fmt.Sprintf("perf%d@example.com", i)).
			Build()

		req := &domain.CreateCustomerRequest{Customer: customer}
		_, err := service.CreateCustomer(ctx, req)
		if err != nil {
			fmt.Printf("   ❌ Performance test failed at operation %d: %v\n", i, err)
			return
		}
	}

	duration := time.Since(start)
	opsPerSecond := float64(numOperations) / duration.Seconds()

	fmt.Printf("   Performance Results:\n")
	fmt.Printf("   Operations: %d\n", numOperations)
	fmt.Printf("   Duration: %v\n", duration)
	fmt.Printf("   Ops/second: %.2f\n", opsPerSecond)

	if opsPerSecond > 1000 {
		fmt.Printf("   ✅ Performance: Excellent (>1000 ops/sec)\n")
	} else if opsPerSecond > 500 {
		fmt.Printf("   ✅ Performance: Good (>500 ops/sec)\n")
	} else {
		fmt.Printf("   ⚠️  Performance: Could be improved (<500 ops/sec)\n")
	}

	// Concurrent performance test
	fmt.Println("\n   Concurrent Performance Test:")
	const numWorkers = 10
	const opsPerWorker = 100

	start = time.Now()
	results := make(chan error, numWorkers)

	for worker := 0; worker < numWorkers; worker++ {
		go func(workerID int) {
			for op := 0; op < opsPerWorker; op++ {
				customer := testutil.NewCustomerBuilder().
					WithName(fmt.Sprintf("Concurrent %d-%d", workerID, op)).
					WithEmail(fmt.Sprintf("concurrent%d%d@example.com", workerID, op)).
					Build()

				req := &domain.CreateCustomerRequest{Customer: customer}
				_, err := service.CreateCustomer(ctx, req)
				if err != nil {
					results <- err
					return
				}
			}
			results <- nil
		}(worker)
	}

	// Wait for completion
	for i := 0; i < numWorkers; i++ {
		if err := <-results; err != nil {
			fmt.Printf("   ❌ Concurrent test failed: %v\n", err)
			return
		}
	}

	concurrentDuration := time.Since(start)
	totalOps := numWorkers * opsPerWorker
	concurrentOpsPerSecond := float64(totalOps) / concurrentDuration.Seconds()

	fmt.Printf("   Concurrent Results:\n")
	fmt.Printf("   Workers: %d\n", numWorkers)
	fmt.Printf("   Total operations: %d\n", totalOps)
	fmt.Printf("   Duration: %v\n", concurrentDuration)
	fmt.Printf("   Ops/second: %.2f\n", concurrentOpsPerSecond)

	fmt.Println("\n🎉 Testing architecture demonstration completed!")
	fmt.Println("\n💡 Key Testing Patterns Demonstrated:")
	fmt.Println("   ✅ Test utilities and helpers")
	fmt.Println("   ✅ Table-driven test structure")
	fmt.Println("   ✅ Integration test environment")
	fmt.Println("   ✅ Performance and benchmark testing")
	fmt.Println("   ✅ Concurrent testing patterns")
}

func contains(str, substr string) bool {
	return len(str) >= len(substr) && str[:len(substr)] == substr
}
```

## ✅ Victory Conditions

- [ ] Test utilities provide comprehensive helpers
- [ ] Table-driven tests cover all scenarios
- [ ] Integration tests verify end-to-end functionality
- [ ] Performance tests measure and validate speed
- [ ] Concurrent tests ensure thread safety

---

**🎉 Day 3 Complete!** You've mastered Go service architecture with clean interfaces, robust error handling, dependency injection, and comprehensive testing. Tomorrow we dive into database integration! 🔌