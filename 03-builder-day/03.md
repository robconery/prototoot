# Lab 3: ðŸ§¬ Dependency Injection

Master Go's approach to dependency injection! Build clean, testable services with explicit dependencies and configuration management.

## ðŸŽ¯ Objectives
- Implement constructor-based dependency injection
- Build flexible configuration management
- Create service lifecycle management
- Design composable service containers

## ðŸ› ï¸ Tasks

### Step 1: Create Configuration Management
Create `internal/config/config.go`:

```go
package config

import (
	"fmt"
	"os"
	"strconv"
	"strings"
	"time"
)

// Config holds all application configuration
type Config struct {
	// Server configuration
	Server ServerConfig `json:"server"`
	
	// Database configuration
	Database DatabaseConfig `json:"database"`
	
	// Cache configuration
	Cache CacheConfig `json:"cache"`
	
	// Logging configuration
	Logging LoggingConfig `json:"logging"`
	
	// Metrics configuration
	Metrics MetricsConfig `json:"metrics"`
	
	// Business logic configuration
	Business BusinessConfig `json:"business"`
}

type ServerConfig struct {
	Host         string        `json:"host"`
	Port         int           `json:"port"`
	ReadTimeout  time.Duration `json:"read_timeout"`
	WriteTimeout time.Duration `json:"write_timeout"`
	IdleTimeout  time.Duration `json:"idle_timeout"`
}

type DatabaseConfig struct {
	Path            string        `json:"path"`          // SQLite database file path
	MaxConnections  int           `json:"max_connections"`
	MaxIdleTime     time.Duration `json:"max_idle_time"`
	ConnMaxLifetime time.Duration `json:"conn_max_lifetime"`
}

type CacheConfig struct {
	Type     string        `json:"type"` // redis, memory, etc.
	Address  string        `json:"address"`
	Password string        `json:"password"`
	DB       int           `json:"db"`
	TTL      time.Duration `json:"ttl"`
}

type LoggingConfig struct {
	Level  string `json:"level"`
	Format string `json:"format"` // json, text
	Output string `json:"output"` // stdout, file
	File   string `json:"file,omitempty"`
}

type MetricsConfig struct {
	Enabled bool   `json:"enabled"`
	Address string `json:"address"`
	Path    string `json:"path"`
}

type BusinessConfig struct {
	MaxRetries      int           `json:"max_retries"`
	RetryDelay      time.Duration `json:"retry_delay"`
	CacheTTL        time.Duration `json:"cache_ttl"`
	RateLimitRPS    int           `json:"rate_limit_rps"`
	ValidationRules ValidationRules `json:"validation_rules"`
}

type ValidationRules struct {
	MinNameLength    int `json:"min_name_length"`
	MaxNameLength    int `json:"max_name_length"`
	RequireEmail     bool `json:"require_email"`
	RequirePhone     bool `json:"require_phone"`
	AllowedDomains   []string `json:"allowed_domains"`
	BlockedDomains   []string `json:"blocked_domains"`
}

// ConfigLoader interface for different configuration sources
type ConfigLoader interface {
	Load() (*Config, error)
}

// EnvironmentConfigLoader loads configuration from environment variables
type EnvironmentConfigLoader struct{}

func NewEnvironmentConfigLoader() *EnvironmentConfigLoader {
	return &EnvironmentConfigLoader{}
}

func (e *EnvironmentConfigLoader) Load() (*Config, error) {
	config := &Config{
		Server: ServerConfig{
			Host:         getEnvString("SERVER_HOST", "localhost"),
			Port:         getEnvInt("SERVER_PORT", 8080),
			ReadTimeout:  getEnvDuration("SERVER_READ_TIMEOUT", 30*time.Second),
			WriteTimeout: getEnvDuration("SERVER_WRITE_TIMEOUT", 30*time.Second),
			IdleTimeout:  getEnvDuration("SERVER_IDLE_TIMEOUT", 120*time.Second),
		},
		Database: DatabaseConfig{
			Path:            getEnvString("DB_PATH", "../resources/chinook.db"),
			MaxConnections:  getEnvInt("DB_MAX_CONNECTIONS", 25),
			MaxIdleTime:     getEnvDuration("DB_MAX_IDLE_TIME", 15*time.Minute),
			ConnMaxLifetime: getEnvDuration("DB_CONN_MAX_LIFETIME", 1*time.Hour),
		},
		Cache: CacheConfig{
			Type:     getEnvString("CACHE_TYPE", "memory"),
			Address:  getEnvString("CACHE_ADDRESS", "localhost:6379"),
			Password: getEnvString("CACHE_PASSWORD", ""),
			DB:       getEnvInt("CACHE_DB", 0),
			TTL:      getEnvDuration("CACHE_TTL", 5*time.Minute),
		},
		Logging: LoggingConfig{
			Level:  getEnvString("LOG_LEVEL", "info"),
			Format: getEnvString("LOG_FORMAT", "json"),
			Output: getEnvString("LOG_OUTPUT", "stdout"),
			File:   getEnvString("LOG_FILE", ""),
		},
		Metrics: MetricsConfig{
			Enabled: getEnvBool("METRICS_ENABLED", true),
			Address: getEnvString("METRICS_ADDRESS", ":9090"),
			Path:    getEnvString("METRICS_PATH", "/metrics"),
		},
		Business: BusinessConfig{
			MaxRetries:   getEnvInt("BUSINESS_MAX_RETRIES", 3),
			RetryDelay:   getEnvDuration("BUSINESS_RETRY_DELAY", 100*time.Millisecond),
			CacheTTL:     getEnvDuration("BUSINESS_CACHE_TTL", 5*time.Minute),
			RateLimitRPS: getEnvInt("BUSINESS_RATE_LIMIT_RPS", 100),
			ValidationRules: ValidationRules{
				MinNameLength:  getEnvInt("VALIDATION_MIN_NAME_LENGTH", 2),
				MaxNameLength:  getEnvInt("VALIDATION_MAX_NAME_LENGTH", 100),
				RequireEmail:   getEnvBool("VALIDATION_REQUIRE_EMAIL", true),
				RequirePhone:   getEnvBool("VALIDATION_REQUIRE_PHONE", false),
				AllowedDomains: getEnvStringSlice("VALIDATION_ALLOWED_DOMAINS", []string{}),
				BlockedDomains: getEnvStringSlice("VALIDATION_BLOCKED_DOMAINS", []string{}),
			},
		},
	}

	return config, nil
}

// Environment variable helpers
func getEnvString(key, defaultValue string) string {
	if value := os.Getenv(key); value != "" {
		return value
	}
	return defaultValue
}

func getEnvInt(key string, defaultValue int) int {
	if value := os.Getenv(key); value != "" {
		if i, err := strconv.Atoi(value); err == nil {
			return i
		}
	}
	return defaultValue
}

func getEnvBool(key string, defaultValue bool) bool {
	if value := os.Getenv(key); value != "" {
		if b, err := strconv.ParseBool(value); err == nil {
			return b
		}
	}
	return defaultValue
}

func getEnvDuration(key string, defaultValue time.Duration) time.Duration {
	if value := os.Getenv(key); value != "" {
		if d, err := time.ParseDuration(value); err == nil {
			return d
		}
	}
	return defaultValue
}

func getEnvStringSlice(key string, defaultValue []string) []string {
	if value := os.Getenv(key); value != "" {
		return strings.Split(value, ",")
	}
	return defaultValue
}

// ConnectionString returns the SQLite database file path
func (d DatabaseConfig) ConnectionString() string {
	return d.Path
}

// Address returns the server address
func (s ServerConfig) Address() string {
	return fmt.Sprintf("%s:%d", s.Host, s.Port)
}
```

### Step 2: Create Service Container
Create `internal/container/container.go`:

```go
package container

import (
	"context"
	"fmt"
	"sync"

	"example.com/chinook/data-pipeline/internal/config"
	"example.com/chinook/data-pipeline/internal/domain"
	"example.com/chinook/data-pipeline/internal/mocks"
	"example.com/chinook/data-pipeline/internal/service"
)

// Container manages all application dependencies
type Container struct {
	config   *config.Config
	services map[string]interface{}
	mu       sync.RWMutex
	
	// Lifecycle management
	shutdownFns []func(context.Context) error
}

// NewContainer creates a new dependency injection container
func NewContainer(cfg *config.Config) *Container {
	return &Container{
		config:      cfg,
		services:    make(map[string]interface{}),
		shutdownFns: make([]func(context.Context) error, 0),
	}
}

// Build initializes all services and their dependencies
func (c *Container) Build() error {
	// Order matters - build dependencies first
	if err := c.buildInfrastructure(); err != nil {
		return fmt.Errorf("failed to build infrastructure: %w", err)
	}
	
	if err := c.buildRepositories(); err != nil {
		return fmt.Errorf("failed to build repositories: %w", err)
	}
	
	if err := c.buildServices(); err != nil {
		return fmt.Errorf("failed to build services: %w", err)
	}
	
	return nil
}

// buildInfrastructure creates infrastructure components
func (c *Container) buildInfrastructure() error {
	// Logger
	logger := c.buildLogger()
	c.setService("logger", logger)
	
	// Metrics
	metrics := c.buildMetrics()
	c.setService("metrics", metrics)
	
	// Cache
	cache, err := c.buildCache()
	if err != nil {
		return fmt.Errorf("failed to build cache: %w", err)
	}
	c.setService("cache", cache)
	
	// Event Publisher
	eventPublisher := c.buildEventPublisher()
	c.setService("eventPublisher", eventPublisher)
	
	return nil
}

// buildRepositories creates repository implementations
func (c *Container) buildRepositories() error {
	// For now, use mock implementations
	// In a real application, these would connect to actual databases
	
	customerRepo := mocks.NewMockCustomerRepository()
	c.setService("customerRepository", customerRepo)
	
	return nil
}

// buildServices creates business logic services
func (c *Container) buildServices() error {
	// Get dependencies
	customerRepo := c.getService("customerRepository").(domain.CustomerRepository)
	eventPub := c.getService("eventPublisher").(domain.EventPublisher)
	cache := c.getService("cache").(domain.Cache)
	logger := c.getService("logger").(domain.Logger)
	metrics := c.getService("metrics").(domain.Metrics)
	
	// Customer Service
	customerService := service.NewCustomerService(customerRepo, eventPub, cache, logger, metrics)
	c.setService("customerService", customerService)
	
	// Error Handling Service
	errorHandlingService := service.NewErrorHandlingService(customerRepo, cache, logger, metrics)
	c.setService("errorHandlingService", errorHandlingService)
	
	return nil
}

// Service accessor methods
func (c *Container) CustomerService() *service.CustomerService {
	return c.getService("customerService").(*service.CustomerService)
}

func (c *Container) ErrorHandlingService() *service.ErrorHandlingService {
	return c.getService("errorHandlingService").(*service.ErrorHandlingService)
}

func (c *Container) Logger() domain.Logger {
	return c.getService("logger").(domain.Logger)
}

func (c *Container) Metrics() domain.Metrics {
	return c.getService("metrics").(domain.Metrics)
}

// Infrastructure builders
func (c *Container) buildLogger() domain.Logger {
	logger := mocks.NewMockLogger()
	
	// Add shutdown function
	c.addShutdownFn(func(ctx context.Context) error {
		// In real implementation, flush log buffers
		return nil
	})
	
	return logger
}

func (c *Container) buildMetrics() domain.Metrics {
	metrics := mocks.NewMockMetrics()
	
	// Add shutdown function
	c.addShutdownFn(func(ctx context.Context) error {
		// In real implementation, flush metrics
		return nil
	})
	
	return metrics
}

func (c *Container) buildCache() (domain.Cache, error) {
	var cache domain.Cache
	
	switch c.config.Cache.Type {
	case "memory":
		cache = mocks.NewMockCache()
	case "redis":
		// In real implementation, create Redis client
		cache = mocks.NewMockCache()
	default:
		return nil, fmt.Errorf("unsupported cache type: %s", c.config.Cache.Type)
	}
	
	// Add shutdown function
	c.addShutdownFn(func(ctx context.Context) error {
		// In real implementation, close cache connections
		return nil
	})
	
	return cache, nil
}

func (c *Container) buildEventPublisher() domain.EventPublisher {
	eventPub := mocks.NewMockEventPublisher()
	
	// Add shutdown function
	c.addShutdownFn(func(ctx context.Context) error {
		// In real implementation, flush pending events
		return nil
	})
	
	return eventPub
}

// Health check implementation
func (c *Container) HealthCheck(ctx context.Context) error {
	// Check all critical services
	checks := []struct {
		name string
		fn   func(context.Context) error
	}{
		{"cache", c.checkCache},
		{"database", c.checkDatabase},
		{"eventPublisher", c.checkEventPublisher},
	}
	
	for _, check := range checks {
		if err := check.fn(ctx); err != nil {
			return fmt.Errorf("%s health check failed: %w", check.name, err)
		}
	}
	
	return nil
}

func (c *Container) checkCache(ctx context.Context) error {
	cache := c.getService("cache").(domain.Cache)
	
	// Try to set and get a test value
	testKey := "health_check"
	testValue := []byte("ok")
	
	if err := cache.Set(ctx, testKey, testValue, c.config.Cache.TTL); err != nil {
		return fmt.Errorf("cache set failed: %w", err)
	}
	
	if _, err := cache.Get(ctx, testKey); err != nil {
		return fmt.Errorf("cache get failed: %w", err)
	}
	
	return nil
}

func (c *Container) checkDatabase(ctx context.Context) error {
	// In real implementation, ping database
	return nil
}

func (c *Container) checkEventPublisher(ctx context.Context) error {
	// In real implementation, check event publisher connection
	return nil
}

// Graceful shutdown
func (c *Container) Shutdown(ctx context.Context) error {
	c.mu.Lock()
	defer c.mu.Unlock()
	
	// Run shutdown functions in reverse order
	for i := len(c.shutdownFns) - 1; i >= 0; i-- {
		if err := c.shutdownFns[i](ctx); err != nil {
			// Log error but continue shutdown
			logger := c.getService("logger").(domain.Logger)
			logger.Error("shutdown function failed", domain.Field{Key: "error", Value: err})
		}
	}
	
	return nil
}

// Internal service management
func (c *Container) setService(name string, service interface{}) {
	c.mu.Lock()
	defer c.mu.Unlock()
	c.services[name] = service
}

func (c *Container) getService(name string) interface{} {
	c.mu.RLock()
	defer c.mu.RUnlock()
	return c.services[name]
}

func (c *Container) addShutdownFn(fn func(context.Context) error) {
	c.mu.Lock()
	defer c.mu.Unlock()
	c.shutdownFns = append(c.shutdownFns, fn)
}

// ServiceFactory provides a factory pattern for service creation
type ServiceFactory struct {
	container *Container
}

func NewServiceFactory(container *Container) *ServiceFactory {
	return &ServiceFactory{container: container}
}

// CreateCustomerServiceWithOptions demonstrates options pattern
type CustomerServiceOptions struct {
	EnableCache     bool
	EnableMetrics   bool
	EnableRetry     bool
	MaxRetries      int
	CacheTimeout    time.Duration
}

func (f *ServiceFactory) CreateCustomerServiceWithOptions(opts CustomerServiceOptions) *service.CustomerService {
	// Get base dependencies
	repo := f.container.getService("customerRepository").(domain.CustomerRepository)
	eventPub := f.container.getService("eventPublisher").(domain.EventPublisher)
	logger := f.container.getService("logger").(domain.Logger)
	
	var cache domain.Cache
	var metrics domain.Metrics
	
	// Conditional dependencies based on options
	if opts.EnableCache {
		cache = f.container.getService("cache").(domain.Cache)
	} else {
		cache = mocks.NewMockCache() // No-op cache
	}
	
	if opts.EnableMetrics {
		metrics = f.container.getService("metrics").(domain.Metrics)
	} else {
		metrics = mocks.NewMockMetrics() // No-op metrics
	}
	
	// Create service with conditional features
	return service.NewCustomerService(repo, eventPub, cache, logger, metrics)
}
```

### Step 3: Create Application Bootstrap
Create `internal/app/app.go`:

```go
package app

import (
	"context"
	"fmt"
	"net/http"
	"os"
	"os/signal"
	"syscall"
	"time"

	"example.com/chinook/data-pipeline/internal/config"
	"example.com/chinook/data-pipeline/internal/container"
	"example.com/chinook/data-pipeline/internal/domain"
)

// Application represents the main application
type Application struct {
	config    *config.Config
	container *container.Container
	server    *http.Server
	logger    domain.Logger
}

// NewApplication creates a new application instance
func NewApplication() (*Application, error) {
	// Load configuration
	configLoader := config.NewEnvironmentConfigLoader()
	cfg, err := configLoader.Load()
	if err != nil {
		return nil, fmt.Errorf("failed to load configuration: %w", err)
	}

	// Create container
	cont := container.NewContainer(cfg)
	
	// Build all dependencies
	if err := cont.Build(); err != nil {
		return nil, fmt.Errorf("failed to build container: %w", err)
	}

	app := &Application{
		config:    cfg,
		container: cont,
		logger:    cont.Logger(),
	}

	return app, nil
}

// Start starts the application
func (app *Application) Start(ctx context.Context) error {
	app.logger.Info("starting application",
		domain.Field{Key: "version", Value: "1.0.0"},
		domain.Field{Key: "environment", Value: "development"})

	// Health check on startup
	if err := app.container.HealthCheck(ctx); err != nil {
		return fmt.Errorf("health check failed: %w", err)
	}

	// Start HTTP server
	if err := app.startHTTPServer(); err != nil {
		return fmt.Errorf("failed to start HTTP server: %w", err)
	}

	app.logger.Info("application started successfully",
		domain.Field{Key: "address", Value: app.config.Server.Address()})

	return nil
}

// Stop stops the application gracefully
func (app *Application) Stop(ctx context.Context) error {
	app.logger.Info("stopping application")

	// Stop HTTP server
	if app.server != nil {
		if err := app.server.Shutdown(ctx); err != nil {
			app.logger.Error("failed to shutdown HTTP server", domain.Field{Key: "error", Value: err})
		}
	}

	// Shutdown container
	if err := app.container.Shutdown(ctx); err != nil {
		app.logger.Error("failed to shutdown container", domain.Field{Key: "error", Value: err})
		return err
	}

	app.logger.Info("application stopped")
	return nil
}

// Run runs the application with graceful shutdown
func (app *Application) Run() error {
	ctx := context.Background()

	// Start application
	if err := app.Start(ctx); err != nil {
		return err
	}

	// Wait for shutdown signal
	app.waitForShutdown()

	// Graceful shutdown
	shutdownCtx, cancel := context.WithTimeout(ctx, 30*time.Second)
	defer cancel()

	return app.Stop(shutdownCtx)
}

// startHTTPServer starts the HTTP server
func (app *Application) startHTTPServer() error {
	mux := http.NewServeMux()

	// Health check endpoint
	mux.HandleFunc("/health", app.healthHandler)
	mux.HandleFunc("/ready", app.readinessHandler)

	// Customer endpoints (simplified for demo)
	mux.HandleFunc("/customers/", app.customerHandler)

	app.server = &http.Server{
		Addr:         app.config.Server.Address(),
		Handler:      mux,
		ReadTimeout:  app.config.Server.ReadTimeout,
		WriteTimeout: app.config.Server.WriteTimeout,
		IdleTimeout:  app.config.Server.IdleTimeout,
	}

	go func() {
		if err := app.server.ListenAndServe(); err != nil && err != http.ErrServerClosed {
			app.logger.Error("HTTP server error", domain.Field{Key: "error", Value: err})
		}
	}()

	return nil
}

// HTTP handlers
func (app *Application) healthHandler(w http.ResponseWriter, r *http.Request) {
	ctx, cancel := context.WithTimeout(r.Context(), 5*time.Second)
	defer cancel()

	if err := app.container.HealthCheck(ctx); err != nil {
		app.logger.Error("health check failed", domain.Field{Key: "error", Value: err})
		http.Error(w, "unhealthy", http.StatusServiceUnavailable)
		return
	}

	w.WriteHeader(http.StatusOK)
	w.Write([]byte("healthy"))
}

func (app *Application) readinessHandler(w http.ResponseWriter, r *http.Request) {
	// Check if application is ready to serve traffic
	w.WriteHeader(http.StatusOK)
	w.Write([]byte("ready"))
}

func (app *Application) customerHandler(w http.ResponseWriter, r *http.Request) {
	// Simple customer endpoint for demonstration
	customerService := app.container.CustomerService()
	
	switch r.Method {
	case http.MethodGet:
		// Get customer logic
		w.WriteHeader(http.StatusOK)
		w.Write([]byte(`{"message": "customer service available"}`))
	case http.MethodPost:
		// Create customer logic using customerService
		_ = customerService // Use the service here
		w.WriteHeader(http.StatusCreated)
		w.Write([]byte(`{"message": "customer created"}`))
	default:
		http.Error(w, "method not allowed", http.StatusMethodNotAllowed)
	}
}

// waitForShutdown waits for shutdown signals
func (app *Application) waitForShutdown() {
	sigChan := make(chan os.Signal, 1)
	signal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM)

	sig := <-sigChan
	app.logger.Info("received shutdown signal", domain.Field{Key: "signal", Value: sig.String()})
}
```

### Step 4: Test Dependency Injection
Create `cmd/dependency-injection-test/main.go`:

```go
package main

import (
	"context"
	"fmt"
	"os"
	"time"

	"example.com/chinook/data-pipeline/internal/app"
	"example.com/chinook/data-pipeline/internal/config"
	"example.com/chinook/data-pipeline/internal/container"
	"example.com/chinook/data-pipeline/internal/domain"
)

func main() {
	fmt.Println("ðŸ§¬ Dependency Injection Laboratory")
	fmt.Println("=================================")

	testConfigurationLoading()
	testContainerBuilding()
	testServiceFactories()
	testApplicationLifecycle()
}

func testConfigurationLoading() {
	fmt.Println("\nâš™ï¸ Testing Configuration Loading")

	// Set some environment variables for testing
	os.Setenv("SERVER_PORT", "9000")
	os.Setenv("DB_HOST", "test-db")
	os.Setenv("CACHE_TYPE", "redis")
	os.Setenv("LOG_LEVEL", "debug")
	os.Setenv("METRICS_ENABLED", "false")

	// Load configuration
	loader := config.NewEnvironmentConfigLoader()
	cfg, err := loader.Load()
	if err != nil {
		fmt.Printf("âŒ Config loading failed: %v\n", err)
		return
	}

	fmt.Printf("âœ… Configuration loaded successfully\n")
	fmt.Printf("   Server: %s\n", cfg.Server.Address())
	fmt.Printf("   Database: %s:%d\n", cfg.Database.Host, cfg.Database.Port)
	fmt.Printf("   Cache type: %s\n", cfg.Cache.Type)
	fmt.Printf("   Log level: %s\n", cfg.Logging.Level)
	fmt.Printf("   Metrics enabled: %t\n", cfg.Metrics.Enabled)

	// Test connection string building
	fmt.Printf("   DB connection string: %s\n", cfg.Database.ConnectionString())
}

func testContainerBuilding() {
	fmt.Println("\nðŸ—ï¸ Testing Container Building")

	// Load configuration
	loader := config.NewEnvironmentConfigLoader()
	cfg, err := loader.Load()
	if err != nil {
		fmt.Printf("âŒ Config loading failed: %v\n", err)
		return
	}

	// Create and build container
	cont := container.NewContainer(cfg)
	if err := cont.Build(); err != nil {
		fmt.Printf("âŒ Container building failed: %v\n", err)
		return
	}

	fmt.Printf("âœ… Container built successfully\n")

	// Test service retrieval
	customerService := cont.CustomerService()
	if customerService == nil {
		fmt.Printf("âŒ Customer service not available\n")
		return
	}
	fmt.Printf("âœ… Customer service available\n")

	errorService := cont.ErrorHandlingService()
	if errorService == nil {
		fmt.Printf("âŒ Error handling service not available\n")
		return
	}
	fmt.Printf("âœ… Error handling service available\n")

	logger := cont.Logger()
	if logger == nil {
		fmt.Printf("âŒ Logger not available\n")
		return
	}
	fmt.Printf("âœ… Logger available\n")

	// Test service functionality
	ctx := context.Background()
	logger.Info("testing dependency injection", domain.Field{Key: "test", Value: true})

	// Test customer service
	customer := &domain.Customer{
		Name:  "DI Test Customer",
		Email: "di@test.com",
	}

	created, err := customerService.CreateCustomer(ctx, &domain.CreateCustomerRequest{Customer: customer})
	if err != nil {
		fmt.Printf("âŒ Customer creation failed: %v\n", err)
	} else {
		fmt.Printf("âœ… Customer created via DI: ID=%d\n", created.Customer.ID)
	}

	// Test health check
	if err := cont.HealthCheck(ctx); err != nil {
		fmt.Printf("âŒ Health check failed: %v\n", err)
	} else {
		fmt.Printf("âœ… Health check passed\n")
	}
}

func testServiceFactories() {
	fmt.Println("\nðŸ­ Testing Service Factories")

	// Load configuration and build container
	loader := config.NewEnvironmentConfigLoader()
	cfg, err := loader.Load()
	if err != nil {
		fmt.Printf("âŒ Config loading failed: %v\n", err)
		return
	}

	cont := container.NewContainer(cfg)
	if err := cont.Build(); err != nil {
		fmt.Printf("âŒ Container building failed: %v\n", err)
		return
	}

	// Create service factory
	factory := container.NewServiceFactory(cont)

	// Test different service configurations
	fmt.Println("   Testing service factory options:")

	// Full-featured service
	fullService := factory.CreateCustomerServiceWithOptions(container.CustomerServiceOptions{
		EnableCache:   true,
		EnableMetrics: true,
		EnableRetry:   true,
		MaxRetries:    5,
		CacheTimeout:  10 * time.Minute,
	})

	if fullService != nil {
		fmt.Printf("   âœ… Full-featured service created\n")
	}

	// Minimal service
	minimalService := factory.CreateCustomerServiceWithOptions(container.CustomerServiceOptions{
		EnableCache:   false,
		EnableMetrics: false,
		EnableRetry:   false,
	})

	if minimalService != nil {
		fmt.Printf("   âœ… Minimal service created\n")
	}

	// Test that services work differently
	ctx := context.Background()
	
	customer := &domain.Customer{
		Name:  "Factory Test Customer",
		Email: "factory@test.com",
	}

	// Both services should work but with different behaviors
	_, err1 := fullService.CreateCustomer(ctx, &domain.CreateCustomerRequest{Customer: customer})
	_, err2 := minimalService.CreateCustomer(ctx, &domain.CreateCustomerRequest{Customer: customer})

	if err1 == nil && err2 == nil {
		fmt.Printf("   âœ… Both service variants work correctly\n")
	} else {
		fmt.Printf("   âŒ Service variants failed: %v, %v\n", err1, err2)
	}
}

func testApplicationLifecycle() {
	fmt.Println("\nðŸ”„ Testing Application Lifecycle")

	// Create application
	application, err := app.NewApplication()
	if err != nil {
		fmt.Printf("âŒ Application creation failed: %v\n", err)
		return
	}

	fmt.Printf("âœ… Application created successfully\n")

	// Test startup (without actually starting the server)
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	// Note: In a real test, we might start the app in a goroutine
	// For this demo, we'll just test the setup
	
	// Test graceful shutdown preparation
	shutdownCtx, shutdownCancel := context.WithTimeout(context.Background(), 2*time.Second)
	defer shutdownCancel()

	if err := application.Stop(shutdownCtx); err != nil {
		fmt.Printf("âŒ Application shutdown failed: %v\n", err)
	} else {
		fmt.Printf("âœ… Application shutdown successful\n")
	}

	fmt.Println("\nðŸŽ‰ Dependency injection testing completed!")
	fmt.Println("\nðŸ’¡ Key Benefits Demonstrated:")
	fmt.Println("   âœ… Configuration-driven dependency creation")
	fmt.Println("   âœ… Explicit dependency injection (no magic)")
	fmt.Println("   âœ… Service lifecycle management")
	fmt.Println("   âœ… Health checking and graceful shutdown")
	fmt.Println("   âœ… Factory patterns for service customization")
	fmt.Println("   âœ… Testable service composition")
}
```

## ðŸ’¥ Deliberate Failure: Dependency Issues

### Break It:
1. Remove a required service from the container
2. Create circular dependencies between services
3. Test what happens when health checks fail

### Fix It:
The container should provide clear error messages about missing dependencies and prevent circular references.

## âœ… Victory Conditions

- [ ] Configuration loads from environment variables
- [ ] Container builds all services with correct dependencies
- [ ] Service factories support customization options
- [ ] Health checks verify all dependencies
- [ ] Graceful shutdown works for all services

---

**Next**: Head to `lab04/` for comprehensive testing architecture! ðŸ§ª