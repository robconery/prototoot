# Lab 1: üéØ Interface Design Mastery

Master Go's interface philosophy! Build small, focused interfaces that compose into powerful abstractions.

## üéØ Objectives
- Design focused, single-purpose interfaces
- Implement interface composition patterns
- Create mock implementations for testing
- Master interface segregation principle

## üõ†Ô∏è Tasks

### Step 1: Create Domain Interfaces
Create `internal/domain/interfaces.go`:

```go
package domain

import (
    "context"
    "io"
    "time"
)

// Core domain interfaces - small and focused

// Reader interfaces
type CustomerReader interface {
    GetCustomer(ctx context.Context, id int64) (*Customer, error)
}

type CustomerLister interface {
    ListCustomers(ctx context.Context, filter ListFilter) ([]*Customer, error)
}

// Writer interfaces  
type CustomerWriter interface {
    CreateCustomer(ctx context.Context, customer *Customer) (*Customer, error)
    UpdateCustomer(ctx context.Context, customer *Customer) (*Customer, error)
}

type CustomerDeleter interface {
    DeleteCustomer(ctx context.Context, id int64) error
}

// Compose interfaces for different use cases
type CustomerRepository interface {
    CustomerReader
    CustomerLister
    CustomerWriter
    CustomerDeleter
}

type CustomerReadOnlyRepository interface {
    CustomerReader
    CustomerLister
}

// Event interfaces
type EventPublisher interface {
    PublishEvent(ctx context.Context, event Event) error
}

type EventSubscriber interface {
    Subscribe(ctx context.Context, topic string, handler EventHandler) error
}

// Observability interfaces
type Logger interface {
    Debug(msg string, fields ...Field)
    Info(msg string, fields ...Field)
    Warn(msg string, fields ...Field)
    Error(msg string, fields ...Field)
}

type Metrics interface {
    Counter(name string) Counter
    Histogram(name string) Histogram
    Gauge(name string) Gauge
}

type Tracer interface {
    StartSpan(ctx context.Context, name string) (context.Context, Span)
}

// Cache interface
type Cache interface {
    Get(ctx context.Context, key string) ([]byte, error)
    Set(ctx context.Context, key string, value []byte, ttl time.Duration) error
    Delete(ctx context.Context, key string) error
}

// Configuration interface
type Config interface {
    GetString(key string) string
    GetInt(key string) int
    GetBool(key string) bool
    GetDuration(key string) time.Duration
}

// Health check interface
type HealthChecker interface {
    HealthCheck(ctx context.Context) error
}

// Graceful shutdown interface
type Shutdowner interface {
    Shutdown(ctx context.Context) error
}

// Domain types
type Customer struct {
    ID    int64
    Name  string
    Email string
}

type Event struct {
    Type      string
    Data      interface{}
    Timestamp time.Time
}

type EventHandler func(ctx context.Context, event Event) error

type ListFilter struct {
    Limit  int
    Offset int
    Query  string
}

// Observability types
type Field struct {
    Key   string
    Value interface{}
}

type Counter interface {
    Inc()
    Add(delta float64)
}

type Histogram interface {
    Observe(value float64)
}

type Gauge interface {
    Set(value float64)
    Inc()
    Dec()
}

type Span interface {
    SetTag(key string, value interface{})
    Finish()
}
```

### Step 2: Implement Service with Interface Composition
Create `internal/service/customer_service.go`:

```go
package service

import (
    "context"
    "fmt"
    "time"

    "github.com/chinook/data-pipeline/internal/domain"
)

// CustomerService implements business logic using composed interfaces
type CustomerService struct {
    repo      domain.CustomerRepository
    eventPub  domain.EventPublisher
    cache     domain.Cache
    logger    domain.Logger
    metrics   domain.Metrics
}

// NewCustomerService creates a new customer service with all dependencies
func NewCustomerService(
    repo domain.CustomerRepository,
    eventPub domain.EventPublisher,
    cache domain.Cache,
    logger domain.Logger,
    metrics domain.Metrics,
) *CustomerService {
    return &CustomerService{
        repo:     repo,
        eventPub: eventPub,
        cache:    cache,
        logger:   logger,
        metrics:  metrics,
    }
}

// GetCustomer retrieves a customer with caching
func (s *CustomerService) GetCustomer(ctx context.Context, id int64) (*domain.Customer, error) {
    s.logger.Info("getting customer", domain.Field{Key: "customer_id", Value: id})
    s.metrics.Counter("customer_get_requests").Inc()
    
    start := time.Now()
    defer func() {
        s.metrics.Histogram("customer_get_duration").Observe(time.Since(start).Seconds())
    }()

    // Try cache first
    cacheKey := fmt.Sprintf("customer:%d", id)
    if cached, err := s.cache.Get(ctx, cacheKey); err == nil {
        s.metrics.Counter("customer_cache_hits").Inc()
        customer := deserializeCustomer(cached)
        return customer, nil
    }
    
    s.metrics.Counter("customer_cache_misses").Inc()

    // Get from repository
    customer, err := s.repo.GetCustomer(ctx, id)
    if err != nil {
        s.logger.Error("failed to get customer", 
            domain.Field{Key: "customer_id", Value: id},
            domain.Field{Key: "error", Value: err})
        s.metrics.Counter("customer_get_errors").Inc()
        return nil, fmt.Errorf("failed to get customer %d: %w", id, err)
    }

    // Cache the result
    if serialized := serializeCustomer(customer); serialized != nil {
        s.cache.Set(ctx, cacheKey, serialized, 5*time.Minute)
    }

    return customer, nil
}

// CreateCustomer creates a new customer with event publishing
func (s *CustomerService) CreateCustomer(ctx context.Context, customer *domain.Customer) (*domain.Customer, error) {
    s.logger.Info("creating customer", domain.Field{Key: "email", Value: customer.Email})
    s.metrics.Counter("customer_create_requests").Inc()

    // Validate customer
    if err := s.validateCustomer(customer); err != nil {
        s.metrics.Counter("customer_validation_errors").Inc()
        return nil, fmt.Errorf("validation failed: %w", err)
    }

    // Create in repository
    created, err := s.repo.CreateCustomer(ctx, customer)
    if err != nil {
        s.logger.Error("failed to create customer", 
            domain.Field{Key: "error", Value: err})
        s.metrics.Counter("customer_create_errors").Inc()
        return nil, fmt.Errorf("failed to create customer: %w", err)
    }

    // Publish event
    event := domain.Event{
        Type:      "customer.created",
        Data:      created,
        Timestamp: time.Now(),
    }
    
    if err := s.eventPub.PublishEvent(ctx, event); err != nil {
        s.logger.Warn("failed to publish customer created event", 
            domain.Field{Key: "customer_id", Value: created.ID},
            domain.Field{Key: "error", Value: err})
        // Don't fail the request for event publishing failures
    }

    s.metrics.Counter("customer_create_success").Inc()
    return created, nil
}

// validateCustomer validates customer data
func (s *CustomerService) validateCustomer(customer *domain.Customer) error {
    if customer.Name == "" {
        return fmt.Errorf("name is required")
    }
    if customer.Email == "" {
        return fmt.Errorf("email is required")
    }
    // Add more validation as needed
    return nil
}

// Placeholder serialization functions
func serializeCustomer(customer *domain.Customer) []byte {
    // In real implementation, use JSON, protobuf, etc.
    return []byte(fmt.Sprintf("%d:%s:%s", customer.ID, customer.Name, customer.Email))
}

func deserializeCustomer(data []byte) *domain.Customer {
    // In real implementation, deserialize properly
    return &domain.Customer{ID: 1, Name: "Cached", Email: "cached@example.com"}
}
```

### Step 3: Create Mock Implementations
Create `internal/mocks/mocks.go`:

```go
package mocks

import (
    "context"
    "fmt"
    "sync"
    "time"

    "github.com/chinook/data-pipeline/internal/domain"
)

// MockCustomerRepository implements domain.CustomerRepository for testing
type MockCustomerRepository struct {
    mu        sync.RWMutex
    customers map[int64]*domain.Customer
    nextID    int64
    
    // For testing error scenarios
    GetError    error
    CreateError error
    UpdateError error
    DeleteError error
}

func NewMockCustomerRepository() *MockCustomerRepository {
    return &MockCustomerRepository{
        customers: make(map[int64]*domain.Customer),
        nextID:    1,
    }
}

func (m *MockCustomerRepository) GetCustomer(ctx context.Context, id int64) (*domain.Customer, error) {
    if m.GetError != nil {
        return nil, m.GetError
    }
    
    m.mu.RLock()
    defer m.mu.RUnlock()
    
    customer, exists := m.customers[id]
    if !exists {
        return nil, fmt.Errorf("customer %d not found", id)
    }
    
    return &domain.Customer{
        ID:    customer.ID,
        Name:  customer.Name,
        Email: customer.Email,
    }, nil
}

func (m *MockCustomerRepository) CreateCustomer(ctx context.Context, customer *domain.Customer) (*domain.Customer, error) {
    if m.CreateError != nil {
        return nil, m.CreateError
    }
    
    m.mu.Lock()
    defer m.mu.Unlock()
    
    newCustomer := &domain.Customer{
        ID:    m.nextID,
        Name:  customer.Name,
        Email: customer.Email,
    }
    
    m.customers[m.nextID] = newCustomer
    m.nextID++
    
    return newCustomer, nil
}

func (m *MockCustomerRepository) UpdateCustomer(ctx context.Context, customer *domain.Customer) (*domain.Customer, error) {
    if m.UpdateError != nil {
        return nil, m.UpdateError
    }
    
    m.mu.Lock()
    defer m.mu.Unlock()
    
    if _, exists := m.customers[customer.ID]; !exists {
        return nil, fmt.Errorf("customer %d not found", customer.ID)
    }
    
    m.customers[customer.ID] = customer
    return customer, nil
}

func (m *MockCustomerRepository) DeleteCustomer(ctx context.Context, id int64) error {
    if m.DeleteError != nil {
        return m.DeleteError
    }
    
    m.mu.Lock()
    defer m.mu.Unlock()
    
    delete(m.customers, id)
    return nil
}

func (m *MockCustomerRepository) ListCustomers(ctx context.Context, filter domain.ListFilter) ([]*domain.Customer, error) {
    m.mu.RLock()
    defer m.mu.RUnlock()
    
    var customers []*domain.Customer
    for _, customer := range m.customers {
        customers = append(customers, customer)
    }
    
    return customers, nil
}

// MockEventPublisher implements domain.EventPublisher for testing
type MockEventPublisher struct {
    mu     sync.RWMutex
    events []domain.Event
    
    PublishError error
}

func NewMockEventPublisher() *MockEventPublisher {
    return &MockEventPublisher{
        events: make([]domain.Event, 0),
    }
}

func (m *MockEventPublisher) PublishEvent(ctx context.Context, event domain.Event) error {
    if m.PublishError != nil {
        return m.PublishError
    }
    
    m.mu.Lock()
    defer m.mu.Unlock()
    
    m.events = append(m.events, event)
    return nil
}

func (m *MockEventPublisher) GetEvents() []domain.Event {
    m.mu.RLock()
    defer m.mu.RUnlock()
    
    events := make([]domain.Event, len(m.events))
    copy(events, m.events)
    return events
}

// MockCache implements domain.Cache for testing
type MockCache struct {
    mu   sync.RWMutex
    data map[string][]byte
    
    GetError error
    SetError error
}

func NewMockCache() *MockCache {
    return &MockCache{
        data: make(map[string][]byte),
    }
}

func (m *MockCache) Get(ctx context.Context, key string) ([]byte, error) {
    if m.GetError != nil {
        return nil, m.GetError
    }
    
    m.mu.RLock()
    defer m.mu.RUnlock()
    
    value, exists := m.data[key]
    if !exists {
        return nil, fmt.Errorf("key %s not found", key)
    }
    
    return value, nil
}

func (m *MockCache) Set(ctx context.Context, key string, value []byte, ttl time.Duration) error {
    if m.SetError != nil {
        return m.SetError
    }
    
    m.mu.Lock()
    defer m.mu.Unlock()
    
    m.data[key] = value
    return nil
}

func (m *MockCache) Delete(ctx context.Context, key string) error {
    m.mu.Lock()
    defer m.mu.Unlock()
    
    delete(m.data, key)
    return nil
}

// MockLogger implements domain.Logger for testing
type MockLogger struct {
    mu       sync.RWMutex
    messages []LogMessage
}

type LogMessage struct {
    Level   string
    Message string
    Fields  []domain.Field
}

func NewMockLogger() *MockLogger {
    return &MockLogger{
        messages: make([]LogMessage, 0),
    }
}

func (m *MockLogger) Debug(msg string, fields ...domain.Field) {
    m.log("DEBUG", msg, fields)
}

func (m *MockLogger) Info(msg string, fields ...domain.Field) {
    m.log("INFO", msg, fields)
}

func (m *MockLogger) Warn(msg string, fields ...domain.Field) {
    m.log("WARN", msg, fields)
}

func (m *MockLogger) Error(msg string, fields ...domain.Field) {
    m.log("ERROR", msg, fields)
}

func (m *MockLogger) log(level, msg string, fields []domain.Field) {
    m.mu.Lock()
    defer m.mu.Unlock()
    
    m.messages = append(m.messages, LogMessage{
        Level:   level,
        Message: msg,
        Fields:  fields,
    })
}

func (m *MockLogger) GetMessages() []LogMessage {
    m.mu.RLock()
    defer m.mu.RUnlock()
    
    messages := make([]LogMessage, len(m.messages))
    copy(messages, m.messages)
    return messages
}
```

### Step 4: Test Interface Design
Create `cmd/interface-test/main.go`:

```go
package main

import (
    "context"
    "fmt"
    "log"

    "github.com/chinook/data-pipeline/internal/domain"
    "github.com/chinook/data-pipeline/internal/mocks"
    "github.com/chinook/data-pipeline/internal/service"
)

func main() {
    fmt.Println("üéØ Interface Design Mastery Laboratory")
    fmt.Println("======================================")

    testInterfaceComposition()
    testMockImplementations()
    testErrorHandling()
}

func testInterfaceComposition() {
    fmt.Println("\nüîß Testing Interface Composition")
    
    // Create mock dependencies
    repo := mocks.NewMockCustomerRepository()
    eventPub := mocks.NewMockEventPublisher()
    cache := mocks.NewMockCache()
    logger := mocks.NewMockLogger()
    metrics := mocks.NewMockMetrics()
    
    // Create service with composed interfaces
    customerService := service.NewCustomerService(repo, eventPub, cache, logger, metrics)
    
    ctx := context.Background()
    
    // Test customer creation
    customer := &domain.Customer{
        Name:  "Interface Test Customer",
        Email: "interface@test.com",
    }
    
    created, err := customerService.CreateCustomer(ctx, customer)
    if err != nil {
        log.Fatalf("Failed to create customer: %v", err)
    }
    
    fmt.Printf("‚úÖ Created customer: ID=%d, Name=%s\n", created.ID, created.Name)
    
    // Verify event was published
    events := eventPub.GetEvents()
    if len(events) > 0 {
        fmt.Printf("‚úÖ Event published: %s\n", events[0].Type)
    }
    
    // Verify logging
    messages := logger.GetMessages()
    if len(messages) > 0 {
        fmt.Printf("‚úÖ Log messages: %d\n", len(messages))
    }
}

func testMockImplementations() {
    fmt.Println("\nüé≠ Testing Mock Implementations")
    
    // Test mock repository behavior
    repo := mocks.NewMockCustomerRepository()
    ctx := context.Background()
    
    // Test normal operation
    customer := &domain.Customer{Name: "Mock Test", Email: "mock@test.com"}
    created, err := repo.CreateCustomer(ctx, customer)
    if err != nil {
        log.Printf("‚ùå Create failed: %v", err)
    } else {
        fmt.Printf("‚úÖ Mock create works: ID=%d\n", created.ID)
    }
    
    // Test error injection
    repo.GetError = fmt.Errorf("simulated database error")
    _, err = repo.GetCustomer(ctx, 1)
    if err != nil {
        fmt.Printf("‚úÖ Mock error injection works: %v\n", err)
    }
}

func testErrorHandling() {
    fmt.Println("\n‚ùå Testing Error Handling")
    
    // Create service with error-prone dependencies
    repo := mocks.NewMockCustomerRepository()
    eventPub := mocks.NewMockEventPublisher()
    cache := mocks.NewMockCache()
    logger := mocks.NewMockLogger()
    metrics := mocks.NewMockMetrics()
    
    service := service.NewCustomerService(repo, eventPub, cache, logger, metrics)
    ctx := context.Background()
    
    // Test validation errors
    invalidCustomer := &domain.Customer{Name: "", Email: ""}
    _, err := service.CreateCustomer(ctx, invalidCustomer)
    if err != nil {
        fmt.Printf("‚úÖ Validation error caught: %v\n", err)
    }
    
    // Test repository errors
    repo.CreateError = fmt.Errorf("database connection failed")
    validCustomer := &domain.Customer{Name: "Valid", Email: "valid@test.com"}
    _, err = service.CreateCustomer(ctx, validCustomer)
    if err != nil {
        fmt.Printf("‚úÖ Repository error handled: %v\n", err)
    }
    
    fmt.Println("\nüéâ Interface design testing completed!")
}
```

## ‚úÖ Victory Conditions

- [ ] Small, focused interfaces are designed correctly
- [ ] Interface composition works as expected
- [ ] Mock implementations support testing scenarios
- [ ] Error injection and handling work properly

---

**Next**: Master error handling patterns in `lab02/`! ‚ùå